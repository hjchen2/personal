{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1672749034858},{"_id":"source/_posts/ASGD中momentum的影响.md","hash":"9a5fdad6a2bb006f20e545455a558cd9c3c268e9","modified":1672753938110},{"_id":"source/_posts/KunPeng论文阅读.md","hash":"5c2ca306920661becbdd75f1b668fc5c172171c2","modified":1672753960809},{"_id":"source/index.md","hash":"4a716cccb0ba2326d71f3ef267c249cafc54641d","modified":1672749034861},{"_id":"source/_posts/C++调用Python接口.md","hash":"a16e3262b5a58f2a47cfc9c97cf1371d13a69fdf","modified":1672753951742},{"_id":"source/_posts/seq2seq串讲.md","hash":"f4954fd23e7bb4c244597ac96290d2cc050689f7","modified":1672754007268},{"_id":"source/_posts/caffe学习.md","hash":"1682c542e7106e1e388bdae92b7d05f94b7096f9","modified":1672753995540},{"_id":"source/_posts/Mac上搭建基于Github的Hexo博客.md","hash":"58daf3202cd058dbae70f78eecff03b2a97bc6e1","modified":1672753977354},{"_id":"source/_posts/模型压缩论文阅读记录.md","hash":"4d0b3da0b6b7ef19da1715fe3b98c1eeb67b9b81","modified":1672754090159},{"_id":"source/_posts/强化学习（一）.md","hash":"52771cde89d41fc9358c012e5285569d2d361250","modified":1672754783421},{"_id":"source/_posts/强化学习（二）.md","hash":"78226a4a36a5995876a7221ee05a0b47eb698ad4","modified":1672754793028},{"_id":"source/_posts/混合精度训练.md","hash":"e7ea19e3900921afe24ac098b78f62b90ec10ef3","modified":1672754044920},{"_id":"source/_posts/值函数的贝尔曼公式推导.md","hash":"a63574e4515c00b3b84abb30960b9cee133cb943","modified":1672754105274},{"_id":"source/categories/index.md","hash":"4a716cccb0ba2326d71f3ef267c249cafc54641d","modified":1672749034862},{"_id":"source/tags/index.md","hash":"61338bc038be974ce8f950091ee11c4da84c7be0","modified":1672749034861},{"_id":"source/about/index.md","hash":"ededac01e1d85e6f235eec48b9836e963a165e92","modified":1672749034860},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1672750589132},{"_id":"themes/next/.stylelintrc","hash":"dedb8dd4d454cb1bb6aba594ef2cbd05ec2427d8","modified":1672750589136},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1672750589131},{"_id":"themes/next/.gitignore","hash":"417520c4dbbeab9c7e3ab10d944da0886366a0ee","modified":1672750589136},{"_id":"themes/next/_vendors.yml","hash":"932e4a95dbf5a20e28eff736b45b71f5a5715c74","modified":1672750589137},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1672750589132},{"_id":"themes/next/README.md","hash":"36c4b25587ca494102323dab5a38de5490451a64","modified":1672750589136},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1672750589137},{"_id":"themes/next/package.json","hash":"67f1da4652c23470632b45e1bfc3f1357d1c0f21","modified":1672750589167},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1672750589136},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"330656d93b6c03df9fb1f2f0e3534c971969473b","modified":1672750589133},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1672750589167},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1672750589133},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"fa76760856429b6421abc54e63b2d3c815372900","modified":1672750589134},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1672750589134},{"_id":"themes/next/_config.yml","hash":"57730cac14dbb6ade884e706c312f007faea8d74","modified":1672753903434},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1672750589134},{"_id":"themes/next/.github/release.yml","hash":"112310b81f959747f8eaafc2ca2150e1dcf916d8","modified":1672750589134},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1672750589137},{"_id":"themes/next/.github/labeler.yml","hash":"5c4bc2bd561e6d9b33ee118cc12218c5de46f72d","modified":1672750589134},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1672750589138},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1672750589134},{"_id":"themes/next/.githooks/install.js","hash":"4d77dbddf2eac1f3fc78f151d12ed22208ed655b","modified":1672750589132},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1672750589137},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1672750589132},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1672750589140},{"_id":"themes/next/languages/de.yml","hash":"c4fc18c338309271d1afe737e6c404a6fa313bbc","modified":1672750589140},{"_id":"themes/next/languages/ar.yml","hash":"46026e98fe279a9db5d68bf91afa5d8e41f9ccfb","modified":1672750589140},{"_id":"themes/next/languages/bn.yml","hash":"74133a827c104d1d84509177f283947fe9327a80","modified":1672750589140},{"_id":"themes/next/languages/default.yml","hash":"4bbdb4284afe495437cf7817b97b45f60e12d1e4","modified":1672750589141},{"_id":"themes/next/languages/es.yml","hash":"8b6d4a8a056df4362d20ae1f6ac7a590dd7246e5","modified":1672750589142},{"_id":"themes/next/languages/fa.yml","hash":"1e256c8df039ddeba66526c5eb2d6c79177a7fc6","modified":1672750589143},{"_id":"themes/next/languages/en.yml","hash":"4bbdb4284afe495437cf7817b97b45f60e12d1e4","modified":1672750589141},{"_id":"themes/next/languages/fr.yml","hash":"2436942610e38b73b175cb0f8ed1f8f23d42a7ce","modified":1672750589143},{"_id":"themes/next/languages/it.yml","hash":"4d6efcdaea89dfe751b7707d91858bf33d3538b7","modified":1672750589143},{"_id":"themes/next/languages/ja.yml","hash":"a0906702d3c87d0e1661e300ad0bdf7e679a3d91","modified":1672750589143},{"_id":"themes/next/languages/id.yml","hash":"c4bad93b23c7eefa730fd7fec5b05ace3ce9ca4d","modified":1672750589143},{"_id":"themes/next/languages/pt-BR.yml","hash":"10d80915c41328f31a4f2d8ac736bba020f373d8","modified":1672750589144},{"_id":"themes/next/languages/ko.yml","hash":"25ee0d5b9a0464a91af7d2efb33293c09ad5abdf","modified":1672750589144},{"_id":"themes/next/languages/nl.yml","hash":"8a4da307b4a19e3c96b90a07a2da8dc5d50e5d9e","modified":1672750589144},{"_id":"themes/next/languages/pt.yml","hash":"fa7c43ec872aee2739b25dd7260e0764ea9e26fd","modified":1672750589144},{"_id":"themes/next/languages/si.yml","hash":"034c5a0df49144e8f16ae2300dba9fde58b9329e","modified":1672750589145},{"_id":"themes/next/languages/ru.yml","hash":"16b96783ba363255b4c8156c3e1efebdb37676f8","modified":1672750589144},{"_id":"themes/next/languages/vi.yml","hash":"a6ba04c743a5b494ac56612ce6b858d9ae3ae1bd","modified":1672750589146},{"_id":"themes/next/languages/uk.yml","hash":"fbaed3039ed8605b81422003a4ecb2a6514e339d","modified":1672750589145},{"_id":"themes/next/languages/zh-CN.yml","hash":"5cebea74f3198a4a20cacf23069c3b91e4f03d85","modified":1672750589146},{"_id":"themes/next/layout/_layout.njk","hash":"fc0a45112f2dcfc2642404e8934ea32a793c3bd7","modified":1672750589147},{"_id":"themes/next/languages/zh-HK.yml","hash":"8ab7219563dab13885840207a86055000d173465","modified":1672750589146},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1672750589166},{"_id":"themes/next/languages/zh-TW.yml","hash":"9fdce9d316e205fc132b2181254ef3b04007a97d","modified":1672750589146},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1672750589166},{"_id":"themes/next/layout/page.njk","hash":"b0660b2af0ac7d3fda14ca4d9f2c9e79ef06c6f9","modified":1672750589166},{"_id":"themes/next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1672750589166},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1672750589166},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1672750589166},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.yml","hash":"3f19cbf0c2b2fee6bf3788870b842c9ccc1425ca","modified":1672750589133},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1672750589133},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.yml","hash":"10eca518b91a19984f6a5a912d41222042f61d63","modified":1672750589133},{"_id":"themes/next/.github/workflows/codeql.yml","hash":"8da13d7c325addb6b7c1d9ac3683dafd43e3709a","modified":1672750589135},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.yml","hash":"fbc3062cd4591c8329fab9db72803746f0d11920","modified":1672750589133},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1672750589215},{"_id":"themes/next/.github/workflows/linter.yml","hash":"2ab8720e4b9534e48ba324b73b0b58cb54df689f","modified":1672750589135},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"e9d51e93f239a2d4b69722c69db3463b4baf0f4c","modified":1672750589135},{"_id":"themes/next/.github/workflows/lock.yml","hash":"f1bf7f86c11419b63323bd21e388e6bdaf24d27d","modified":1672750589135},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"434cc0674290958b1e9bbc46c3486f073c0722db","modified":1672750589135},{"_id":"themes/next/.github/workflows/pr-reminder.yml","hash":"3ab3e8d9dc0e1d9bd54f44fba476792fb1ee190d","modified":1672750589135},{"_id":"themes/next/.github/workflows/tester.yml","hash":"80a20c3a7522249f051a48239db41d1317e9b552","modified":1672750589135},{"_id":"themes/next/docs/ru/README.md","hash":"ac3c4a7616ea80f0d32d68d6e53233952ba756dc","modified":1672750589138},{"_id":"themes/next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1672750589167},{"_id":"themes/next/docs/zh-CN/README.md","hash":"9bbdbb0656505acceef9b9895a576164175fe888","modified":1672750589139},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1672750589172},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1672750589174},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1672750589174},{"_id":"themes/next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1672750589174},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"fd24abfaba4d91923ddb6aecf0268b216678c8bd","modified":1672750589174},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1672750589173},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1672750589175},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1672750589171},{"_id":"themes/next/scripts/filters/minify.js","hash":"ce8477e7fb226525bae5872cd68a1c2c23ad50c8","modified":1672750589172},{"_id":"themes/next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1672750589172},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1672750589172},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1672750589175},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1672750589176},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1672750589177},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1672750589177},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1672750589176},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1672750589138},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1672750589177},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1672750589177},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1672750589178},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1672750589178},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1672750589178},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1672750589139},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1672750589177},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1672750589178},{"_id":"themes/next/languages/th.yml","hash":"4fac74a39d3906c4a727476be4750530a505933a","modified":1672750589145},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1672750589179},{"_id":"themes/next/source/css/_mixins.styl","hash":"04a07a4dbeb00683d783eff26c44492c35b924e0","modified":1672750589194},{"_id":"themes/next/source/css/main.styl","hash":"921a58577f411cf4eb5cfd66db0a241f8f88578c","modified":1672750589201},{"_id":"themes/next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1672750589201},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1672750589204},{"_id":"themes/next/source/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1672750589204},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1672750589203},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1672750589204},{"_id":"themes/next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1672750589205},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1672750589205},{"_id":"themes/next/source/js/pjax.js","hash":"90fb7f346f777434ea68ab4e4be1d7b999ad63ac","modified":1672750589205},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1672750589204},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1672750589202},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1672750589202},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1672750589202},{"_id":"themes/next/source/js/utils.js","hash":"af59257e46d25dda62967c35a65e2efcbd90d3bc","modified":1672750589214},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1672750589203},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1672750589203},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"547c62ab14d9e05d2d9116db9048a677fbe1fb6d","modified":1672750589147},{"_id":"themes/next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1672750589203},{"_id":"themes/next/layout/_macro/post.njk","hash":"7e8268fd5cbd552322b276f52459fd187c2453d2","modified":1672750589147},{"_id":"themes/next/layout/_partials/footer.njk","hash":"c40760b559c516677c8b11a00ba50c011f2079fd","modified":1672750589148},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1672750589147},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1672750589150},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1672750589152},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1672750589148},{"_id":"themes/next/languages/tr.yml","hash":"890f87f6a33ad8452b771607d4c3ff14810b35fa","modified":1672750589145},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1672750589155},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1672750589162},{"_id":"themes/next/layout/_third-party/index.njk","hash":"aa37f8e98208177b63e3328d6e53b022c6edf3b2","modified":1672750589162},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1672750589163},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1672750589214},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1672750589164},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1672750589156},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1672750589215},{"_id":"themes/next/test/tags/group-pictures.js","hash":"5c68ae0184f9da6e00ba199f2554d503d8e6da71","modified":1672750589215},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1672750589216},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1672750589216},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1672750589215},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1672750589216},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1672750589216},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1672750589216},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1672750589216},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1672750589217},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1672750589217},{"_id":"themes/next/scripts/events/lib/config.js","hash":"9ec51eb61f7fee612ffc5252f489003a0fa301fc","modified":1672750589168},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1672750589217},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1672750589168},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1672750589169},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1672750589169},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1672750589168},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1672750589169},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1672750589169},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1672750589170},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1672750589170},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1672750589170},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1672750589170},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1672750589171},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1672750589170},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1672750589171},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1672750589171},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1672750589200},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1672750589199},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"48f4f277946a168d0db1ea02804e85c22ca2c7db","modified":1672750589201},{"_id":"themes/next/source/css/_variables/base.styl","hash":"9845209c54174a42cbff5b5efd5e2e2fb7e60589","modified":1672750589201},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a1418c9dc8c0f1a0ad4ded0f4627c45bf0db1a10","modified":1672750589199},{"_id":"themes/next/source/js/schemes/muse.js","hash":"0c490e9ba82efbb8bdf8465e6b537fafd51e1ed7","modified":1672750589206},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1672750589211},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1672750589210},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1672750589211},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1672750589149},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1672750589149},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1672750589148},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1672750589149},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1672750589149},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1672750589150},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1672750589149},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1672750589150},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1672750589150},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1672750589151},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1672750589152},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1672750589214},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1672750589215},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1672750589215},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1672750589153},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1672750589153},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1672750589153},{"_id":"themes/next/layout/_partials/post/post-share.njk","hash":"3f28cc4411c0ffc0e41b7970d5ab329c7e46f497","modified":1672750589154},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1672750589153},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1672750589154},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1672750589154},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"70342218473a6e6aa9148de06bfffe121afb8548","modified":1672750589155},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1672750589156},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1672750589156},{"_id":"themes/next/languages/tk.yml","hash":"37d9af426b040004841273d163059cd49cd67d65","modified":1672750589145},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1672750589157},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1672750589157},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1672750589158},{"_id":"themes/next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1672750589158},{"_id":"themes/next/layout/_third-party/analytics/umami.njk","hash":"181f69b6718c7a8642a88652260cc0a26084a3ee","modified":1672750589158},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1672750589163},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1672750589157},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1672750589163},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1672750589163},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1672750589160},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1672750589160},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1672750589160},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1672750589161},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1672750589161},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1672750589161},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1672750589161},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1672750589161},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1672750589161},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1672750589162},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1672750589164},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1672750589164},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1672750589164},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1672750589165},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1672750589165},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1672750589165},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1672750589165},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1672750589165},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"7664491542046df9a3887cf40a06e00c0b4086a9","modified":1672750589179},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1672750589180},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1672750589183},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1672750589189},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1672750589152},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1672750589190},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1672750589153},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1672750589154},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1672750589190},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1672750589191},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"782ee1fc5e669d3ddbfeb82b73ad7fe561f1a4fb","modified":1672750589194},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1672750589186},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1672750589186},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"77b85d4de5ab747e04008ab31200311b29748740","modified":1672750589195},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1672750589195},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1672750589195},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1672750589195},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1672750589195},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"d856127cd7e0a28a88edf0b2eb860ede9c3fdb60","modified":1672750589196},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"7fecfb76420f786d6bf60218a81705bb48fb1d18","modified":1672750589197},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1672750589197},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"cef9c5f9524fd01b59b0a89e51904b42cbdedc8c","modified":1672750589197},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1672750589197},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1672750589197},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"9f77d8c07dff6944b577110fb22f8f7c407a107b","modified":1672750589198},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"ac2dc0ce9c775a83ef7132ae957b54539366ac9c","modified":1672750589198},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1672750589198},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"91dbf3ca5c3a613d4e30618c120da535bf2d0336","modified":1672750589198},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1672750589198},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1672750589199},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1672750589191},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9dfe853c901bdc52fc950bacdf15484dbb9bf140","modified":1672750589194},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1672750589191},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1672750589191},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1672750589208},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1672750589208},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"e7f988ecddb2159313699a00827a45eca5622bd4","modified":1672750589155},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1672750589156},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1672750589208},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1672750589210},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1672750589207},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1672750589207},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1672750589211},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1672750589211},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1672750589206},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1672750589206},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1672750589207},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1672750589206},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1672750589212},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1672750589212},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1672750589208},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1672750589213},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1672750589213},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1672750589213},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1672750589180},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1672750589207},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1672750589180},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1672750589180},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1672750589213},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1672750589210},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1672750589183},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1672750589184},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1672750589184},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"77550e0d3e029b7458e35d8c5ae1fbd612c9673b","modified":1672750589184},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1672750589184},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1672750589184},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1672750589181},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1672750589181},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1ecfd64507954810b07a9d21fb5305b5378feda0","modified":1672750589182},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"11497388f124bfbb4001495a67d3629a9f618405","modified":1672750589182},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1672750589182},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1672750589182},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1672750589181},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"40c9839d3288c3b7de0bf38ac2e18f6c8eba6227","modified":1672750589183},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1672750589183},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"9056be572ec1cfa429abb22be4b45a662d5b0fb1","modified":1672750589191},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1672750589190},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1672750589192},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1672750589192},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1672750589192},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1672750589192},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1672750589193},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1672750589193},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1672750589193},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"98d4c20aff0f0fcfe1824017fb06ab21ef0d218e","modified":1672750589193},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1672750589193},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1672750589185},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1672750589185},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"b750af2fb833c10c4313b5a4258237161a7833d7","modified":1672750589186},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1672750589186},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1672750589210},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"04cf4a69537fc14d3b8904f965d283356853847f","modified":1672750589183},{"_id":"themes/next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1672750589187},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"da5e88f8debd5ac8d7af5c6ba6240df66104955f","modified":1672750589187},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1672750589187},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1672750589187},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1672750589188},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"f3506fd0c0303ea365de1c7774d98a1a3f3027cf","modified":1672750589188},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"9a7c71560fbdc936ad4e736fe15063ea3e8a644b","modified":1672750589189},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"c6a27beb3f741211a14576026f3b4cfc44cc6407","modified":1672750589188},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1672750589189},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1672750589189},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"0c79462439b1361034a03590cd69a8abb3a678a6","modified":1672750589185},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1672750589186},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1672750589185},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1672750589180},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1672750589181},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1672750589182},{"_id":"public/search.xml","hash":"0b95f91f5ffaf6a7ee7272304ce17ceeff604ef0","modified":1672754819712},{"_id":"public/categories/index.html","hash":"d94396fc6b26735160d12bf9ef0f06890959b223","modified":1672754819712},{"_id":"public/about/index.html","hash":"b950cb9e8a4ff43ec310aa2a427b889afb33b433","modified":1672754819712},{"_id":"public/tags/index.html","hash":"8011589f983c64d924bfdcfbae60d7bde5175a33","modified":1672754819712},{"_id":"public/2017/06/21/ASGD中momentum的影响/index.html","hash":"baebb8c9dedaa76db04dc2148ba9bc58759be0d0","modified":1672754819712},{"_id":"public/2017/04/10/值函数的贝尔曼公式推导/index.html","hash":"0e890a5d97c0b82e2b9304753343c33f84c263a5","modified":1672754819712},{"_id":"public/2017/03/22/Mac上搭建基于Github的Hexo博客/index.html","hash":"1e6ee90900a819a22b67eaf9ede2118092e16979","modified":1672754819712},{"_id":"public/archives/index.html","hash":"511b700a20b9b62fbaabb434369dc96e533e4e84","modified":1672754819712},{"_id":"public/archives/page/2/index.html","hash":"85ca9e2dc3916fdf75dc75069dbcf64b9b4cc7ae","modified":1672754819712},{"_id":"public/archives/2017/index.html","hash":"f8a208e26a46d781d2895b03d64524b2cf2df6bd","modified":1672754819712},{"_id":"public/archives/2017/01/index.html","hash":"3c213eb2690b23d29e6d62986fcf1ae81ad557be","modified":1672754819712},{"_id":"public/archives/2017/03/index.html","hash":"ec53390ad71577228d89deb29f09c26afcc21bef","modified":1672754819712},{"_id":"public/archives/2017/04/index.html","hash":"46cc16c7afa46c1b4412850c9965edbb09b3080f","modified":1672754819712},{"_id":"public/archives/2017/06/index.html","hash":"d4b04bd72dfb078d5f9481e122f1821749e0e80c","modified":1672754819712},{"_id":"public/archives/2017/07/index.html","hash":"925e4bfed2db2bac76232253cef22fc22495be7c","modified":1672754819712},{"_id":"public/archives/2017/08/index.html","hash":"b08190eba13d8f54decb866cd78f0af920dbd8d2","modified":1672754819712},{"_id":"public/archives/2017/12/index.html","hash":"9afe9cf30004fc71feb269c2792ebc67610edf46","modified":1672754819712},{"_id":"public/archives/2018/index.html","hash":"f9ea66f5f45ff20aed69f2f03e9d2941c2cb4d07","modified":1672754819712},{"_id":"public/archives/2018/01/index.html","hash":"2f06c99e6074bd6cb13615ec73e50c7fe883927c","modified":1672754819712},{"_id":"public/archives/2018/02/index.html","hash":"c4290629e9ca75f25767aff58e76130b8e409294","modified":1672754819712},{"_id":"public/tags/caffe/index.html","hash":"23f3051423796bad2634a682465b39836c9be7d2","modified":1672754819712},{"_id":"public/page/2/index.html","hash":"077ef0b076eb7f60098f09749ed0b42fd3a053d9","modified":1672754819712},{"_id":"public/tags/deep-learning/index.html","hash":"ae629dd75889a4cf24c3c16db27bd6aeb7943f93","modified":1672754819712},{"_id":"public/tags/momentum/index.html","hash":"8c78a6c74e66bd83139eff41e2ea89739d4a7ea2","modified":1672754819712},{"_id":"public/tags/large-scale-ML-framework/index.html","hash":"44a699b5cb91620a7e994f3e430e736936921493","modified":1672754819712},{"_id":"public/tags/KunPeng/index.html","hash":"01911611c96a8cc8e5b300f1d10b0022873b675c","modified":1672754819712},{"_id":"public/tags/web-technology/index.html","hash":"7f7bc0cb53b9b6123bf2b56e11554bf55c976eab","modified":1672754819712},{"_id":"public/tags/framework/index.html","hash":"a465c46e3a037f7314d42676d48cf678fd91d3e2","modified":1672754819712},{"_id":"public/tags/c/index.html","hash":"54c5c889928fc56ee83cefb52d0de0af4bcafce1","modified":1672754819712},{"_id":"public/tags/python/index.html","hash":"56c9e84f39d9c1ee080f209d99208cae274378a4","modified":1672754819712},{"_id":"public/tags/embedding/index.html","hash":"0038df89dc7e9d972ce170d745992825a125abba","modified":1672754819712},{"_id":"public/tags/reinforcement-learning/index.html","hash":"3601d17925bfea5c8dfa394cb5a560f3e60e9d4e","modified":1672754819712},{"_id":"public/tags/machine-learning，贝尔曼公式推导/index.html","hash":"45104cdbc2a8f75304dd18c10e3d16c43962f7ea","modified":1672754819712},{"_id":"public/tags/seq2seq/index.html","hash":"b59183a84bad0991e21234d8ad9d524a55e3099a","modified":1672754819712},{"_id":"public/tags/machine-translation/index.html","hash":"4bf5c783828f0a8316b5c16851e3e613c66d8176","modified":1672754819712},{"_id":"public/tags/Encoder-Decoder/index.html","hash":"9f717781bec432591a5c99648aa7adb7e991aec9","modified":1672754819712},{"_id":"public/tags/Attention/index.html","hash":"c74700dfae1b495eebc69b641f72ce2d77b4c683","modified":1672754819712},{"_id":"public/tags/machine-learning/index.html","hash":"88b51e9e53ba14acab4331a889ce21ce5af1174b","modified":1672754819712},{"_id":"public/tags/pruning/index.html","hash":"2bba536bb359db0c0445a1534a4df574f4942747","modified":1672754819712},{"_id":"public/tags/int16/index.html","hash":"1c2926200e3f941d41fcc7d52ef8db7a66cf93d1","modified":1672754819712},{"_id":"public/tags/fp16/index.html","hash":"df7b7bdf51315788e3aaeb1249378d808980afe5","modified":1672754819712},{"_id":"public/tags/混合精度训练/index.html","hash":"88cf6298cd275608b05e1d088f9a8670d6fe70a7","modified":1672754819712},{"_id":"public/tags/loss-scaling/index.html","hash":"1ecedf49ac7d6268885861a25d0231fb3ca25511","modified":1672754819712},{"_id":"public/tags/QVNNI16/index.html","hash":"a0bb5a55e1ed299fc721655c3223a45aa593cc0f","modified":1672754819712},{"_id":"public/categories/deep-learning/index.html","hash":"3da20278f57f0df39dfdf804e7ae691269db92e2","modified":1672754819712},{"_id":"public/categories/ML-framework/index.html","hash":"7ba56aa554e9289ac61dce678bdb18bde57a88b3","modified":1672754819712},{"_id":"public/categories/Daily/index.html","hash":"38101c90363fbf3ca3e28d6d8cd4fef732eec892","modified":1672754819712},{"_id":"public/categories/code/index.html","hash":"5380075ee7b2fe0dbb86d71e2a47441c5c2f02fa","modified":1672754819712},{"_id":"public/categories/reinforcement-learning/index.html","hash":"fe54745cb0ff5ad1cc83f5de5557dbd03218c2c6","modified":1672754819712},{"_id":"public/categories/neural-machine-translation/index.html","hash":"0f198e1df2ca32e0df6659da8c85e0d5056d6528","modified":1672754819712},{"_id":"public/categories/model-compression/index.html","hash":"1cf369521f2720554307390627034e99c40f9bbb","modified":1672754819712},{"_id":"public/categories/low-bitwidth/index.html","hash":"5ff4a40337211da59aef2fa56670cbd31c3f4036","modified":1672754819712},{"_id":"public/index.html","hash":"941c92968fd9558de5ed4d6a353b6ac3e07dcb5f","modified":1672754819712},{"_id":"public/2018/02/03/混合精度训练/index.html","hash":"7896feabdd65308bf692aa4f9960bdcc516ebb70","modified":1672754819712},{"_id":"public/2018/01/02/模型压缩论文阅读记录/index.html","hash":"c7e9ed52c66adfeba2d16994a1690d237ed1d7b8","modified":1672754819712},{"_id":"public/2017/12/01/seq2seq串讲/index.html","hash":"309b78e8c76c9a28cc799fe5e287f3ead9f5e6bd","modified":1672754819712},{"_id":"public/2017/08/22/KunPeng论文阅读/index.html","hash":"99e811d5abbabab3349ef7b13078181e6d57e05b","modified":1672754819712},{"_id":"public/2017/07/03/C++调用Python接口/index.html","hash":"f3130308619b6b2dde14e43d2277b1c8f67b1cb8","modified":1672754819712},{"_id":"public/2017/04/25/强化学习（二）/index.html","hash":"5345e8fe27d88ebca48356be8fb4d37625b3e568","modified":1672754819712},{"_id":"public/2017/03/27/强化学习（一）/index.html","hash":"06b64b188db2bcfc1d8cb7e7aa90c95ffeea1028","modified":1672754819712},{"_id":"public/2017/01/19/caffe学习/index.html","hash":"3167f003e6634f6e7b93e087c37e7d5cc176af99","modified":1672754819712},{"_id":"public/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1672754555643},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1672754555643},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1672754555643},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1672754555643},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1672754555643},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1672754555643},{"_id":"public/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1672754555643},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1672754555643},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1672754555643},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1672754555643},{"_id":"public/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1672754555643},{"_id":"public/js/pjax.js","hash":"90fb7f346f777434ea68ab4e4be1d7b999ad63ac","modified":1672754555643},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1672754555643},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1672754555643},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1672754555643},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1672754555643},{"_id":"public/js/schemes/muse.js","hash":"0c490e9ba82efbb8bdf8465e6b537fafd51e1ed7","modified":1672754555643},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1672754555643},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1672754555643},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1672754555643},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1672754555643},{"_id":"public/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1672754555643},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1672754555643},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1672754555643},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1672754555643},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1672754555643},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1672754555643},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1672754555643},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1672754555643},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1672754555643},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1672754555643},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1672754555643},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1672754555643},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1672754555643},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1672754555643},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1672754555643},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1672754555643},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1672754555643},{"_id":"public/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1672754555643},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1672754555643},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1672754555643},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1672754555643},{"_id":"public/css/main.css","hash":"3b18adf5fa724215d6953244f9462ace9c15360a","modified":1672754555643},{"_id":"public/js/utils.js","hash":"af59257e46d25dda62967c35a65e2efcbd90d3bc","modified":1672754555643},{"_id":"source/.DS_Store","hash":"561518c8e3f29eec27d32607704623e48c7277fd","modified":1672754624085},{"_id":"source/_posts/DeepFusion.md","hash":"4524afdc963861ef84f253d2cc70f2b47cd5628b","modified":1672754664168},{"_id":"source/_posts/TVM-PackedFunc实现机制.md","hash":"517588b9f75b8a442a4641300ceecee7a9cebccf","modified":1672754707910},{"_id":"source/_posts/Kaldi决策树如何使用.md","hash":"dde5889a10059c11bbe86baccd466630417091b9","modified":1672754675627},{"_id":"source/_posts/如何在XRT框架下添加自定义的后端引擎.md","hash":"e37cba7a296ef8fd9ca285cfd678b0acc6ef812d","modified":1672754758107},{"_id":"source/_posts/图替换.md","hash":"e2bb61f82c756863dbf4b02c7b6e776fb5f2f2f9","modified":1672754742560},{"_id":"public/archives/2016/index.html","hash":"338fb09764e0ed6f94f8a6d3bcf3547da6bccccf","modified":1672754819712},{"_id":"public/archives/2016/06/index.html","hash":"a998c0e34643f9d0a07c13782a98458c0910b0e7","modified":1672754819712},{"_id":"public/archives/2019/index.html","hash":"425ebb5f0a5e22802dd0e151d447bd8f8468f725","modified":1672754819712},{"_id":"public/archives/2019/11/index.html","hash":"6021370f5ee582ca76f48f68ea148204deb18781","modified":1672754819712},{"_id":"public/archives/2019/12/index.html","hash":"7302833496badbf8d16db0ebecb157e8c284817e","modified":1672754819712},{"_id":"public/archives/2020/index.html","hash":"e64f6af5bc07937d7e24d2028359042abb77bc80","modified":1672754819712},{"_id":"public/archives/2020/01/index.html","hash":"81ffa9f93da4329b057e6710f30f58f07cbd31cf","modified":1672754819712},{"_id":"public/archives/2020/02/index.html","hash":"5e3b6a8d8d020f5967994924794e6d36f19339cb","modified":1672754819712},{"_id":"public/categories/kaldi-decision-tree-决策树/index.html","hash":"8d3ace24e3607a55c0e02f8bfac92e6ad89ddf5b","modified":1672754819712},{"_id":"public/categories/DL-Compiler/index.html","hash":"2af942eacda185bf503404229e0873d57abfa8dc","modified":1672754819712},{"_id":"public/categories/tvm-knowledge/index.html","hash":"d64bc1671a46feb42cc53210627964471e0d6d52","modified":1672754819712},{"_id":"public/categories/graph-optimization-图优化/index.html","hash":"6a5537fd6a4000418517b95e5957701527a2fab4","modified":1672754819712},{"_id":"public/categories/XRT/index.html","hash":"355d939ba7540d862a3fa03a3771a68cc1032779","modified":1672754819712},{"_id":"public/tags/XLA/index.html","hash":"ca4f7e04be97e418386f743b13ac73a51406d26b","modified":1672754819712},{"_id":"public/tags/Deep-Learning-Compiler/index.html","hash":"feebb207a3e4f733d0d3c7176eed3e58580785f5","modified":1672754819712},{"_id":"public/tags/FusionStitching/index.html","hash":"2442bdb89f4963a11646316f03c97f3065cfa98b","modified":1672754819712},{"_id":"public/tags/kaldi/index.html","hash":"6cde9e702e7247a0fec1a18817c6fdf8e24055db","modified":1672754819712},{"_id":"public/tags/decision-tree/index.html","hash":"8374ff1a69a00d499312b4e1a31115fc9336db4e","modified":1672754819712},{"_id":"public/tags/决策树/index.html","hash":"163489ab243cc87a8594da204a8bd4308976cf38","modified":1672754819712},{"_id":"public/tags/HMM/index.html","hash":"7546a109512ffd74d0965ec0e6dba81914b1b695","modified":1672754819712},{"_id":"public/tags/上下文相关音素/index.html","hash":"18b8215a54f1df8aeedddd353f1497703d0d96c7","modified":1672754819712},{"_id":"public/tags/TVM/index.html","hash":"7bd5c6c2177638f29e23d58caf53f89c3fb66d73","modified":1672754819712},{"_id":"public/tags/PackedFunc/index.html","hash":"556b22182cbae22738a7b38a16f07c85f2ab0eb2","modified":1672754819712},{"_id":"public/tags/图替换/index.html","hash":"144a6d861ffa307e2d678d5028be457b30d10ca6","modified":1672754819712},{"_id":"public/tags/超优化/index.html","hash":"aa327224be62c054cfc8e117e07dfe270bcafaef","modified":1672754819712},{"_id":"public/tags/graph-optimization/index.html","hash":"3386645afa13169fc46a0c795698db90222b04c8","modified":1672754819712},{"_id":"public/tags/super-optimization/index.html","hash":"b6e07a735cfe9cc7249f872e0b5cc6786c0e7803","modified":1672754819712},{"_id":"public/tags/substitution/index.html","hash":"da9a083017cbc74472a1d53bec0a52608fda5775","modified":1672754819712},{"_id":"public/tags/XRT/index.html","hash":"c177720423b1c582982f81b166755a4f10284bd9","modified":1672754819712},{"_id":"public/2020/02/25/如何在XRT框架下添加自定义的后端引擎/index.html","hash":"8ca966538a60d4f639275fb49d1ca53336fd41db","modified":1672754819712},{"_id":"public/2020/01/10/TVM-PackedFunc实现机制/index.html","hash":"1f4ebac63c697b63b2806b55dbaa3a8a78686cbb","modified":1672754819712},{"_id":"public/2019/11/27/DeepFusion/index.html","hash":"71a709f7e2758b8229a057ecb587326e01dcd2f6","modified":1672754819712},{"_id":"public/2019/12/26/图替换/index.html","hash":"7e939c8e06eec32a17faa871f72b76c33ca2b661","modified":1672754819712},{"_id":"public/2016/06/08/Kaldi决策树如何使用/index.html","hash":"81e9cf98c8c191f3e15f8734ec34471803c86ba6","modified":1672754819712},{"_id":"public/tags/Compiler/index.html","hash":"717a5034c7c2740f795b9565e8455d641b311168","modified":1672754819712},{"_id":"public/tags/TensorFlow-XLA/index.html","hash":"f8e96d5cae7bc31abc90eb47c0700ee2a6640992","modified":1672754819712},{"_id":"public/tags/TensorRT/index.html","hash":"e8d32e606c65571d8783d14bee05fabbcb3d43c0","modified":1672754819712}],"Category":[{"name":"deep learning","_id":"clcgavftk0004hbeqesxbg8qv"},{"name":"ML framework","_id":"clcgavftp000bhbeqhj4feo2v"},{"name":"Daily","_id":"clcgavftr000ghbeq4v6t94oj"},{"name":"code","_id":"clcgavftx000rhbeqb11dc7rw"},{"name":"reinforcement learning","_id":"clcgavfty000whbeq4rio6iuo"},{"name":"neural machine translation","_id":"clcgavftz0011hbeqd5lw01r4"},{"name":"model compression","_id":"clcgavfu00017hbeq9nrn4zl9"},{"name":"low bitwidth","_id":"clcgavfu1001dhbeq75qs20f4"},{"name":"DL Compiler","_id":"clcgb13uj0002j6eq2scfhv71"},{"name":"kaldi, decision tree, 决策树","_id":"clcgb13up0007j6eq8u9d2429"},{"name":"tvm knowledge","_id":"clcgb13ut000aj6eqg29b4trk"},{"name":"graph optimization, 图优化","_id":"clcgb13uu000dj6eqfvidf5y2"},{"name":"XRT","_id":"clcgb13uv000ij6eq69ca8xtn"}],"Data":[],"Page":[{"date":"2017-03-23T03:45:32.000Z","type":"categories","comments":0,"_content":"","source":"index.md","raw":"---\n#title: 分类\ndate: 2017-03-23 11:45:32\ntype: \"categories\"\ncomments: false\n---\n","updated":"2023-01-03T12:30:34.861Z","path":"index.html","title":"","layout":"page","_id":"clcgavftc0000hbeq9vuublni","content":"\n","site":{"data":{}},"excerpt":"","more":"\n"},{"date":"2017-03-23T03:45:32.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\n#title: 分类\ndate: 2017-03-23 11:45:32\ntype: \"categories\"\ncomments: false\n---\n","updated":"2023-01-03T12:30:34.862Z","path":"categories/index.html","title":"","layout":"page","_id":"clcgavfti0002hbeqgt6d46jf","content":"\n","site":{"data":{}},"excerpt":"","more":"\n"},{"title":"关于","date":"2017-03-24T07:07:18.000Z","type":"about","comments":0,"_content":"\n\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-03-24 15:07:18\ntype: \"about\"\ncomments: false\n---\n\n\n","updated":"2023-01-03T12:30:34.860Z","path":"about/index.html","layout":"page","_id":"clcgavftm0006hbeq0503060e","content":"\n","site":{"data":{}},"excerpt":"","more":"\n"},{"title":"标签","date":"2017-03-23T03:53:23.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-03-23 11:53:23\ntype: \"tags\"\ncomments: false\n---\n","updated":"2023-01-03T12:30:34.861Z","path":"tags/index.html","layout":"page","_id":"clcgavftn0008hbeq0tcb86k8","content":"\n","site":{"data":{}},"excerpt":"","more":"\n"}],"Post":[{"title":"多节点异步更新中momentum的影响","date":"2017-06-21T04:31:08.000Z","_content":"\n\n这几天的主要工作是将caffe移植到组内新开发的某个计算框架，在验证正确性时遇到一个问题。由于计算框架只支持异步更新的方式，因此采用全异步SGD算法训练Alexnet时非常容易发散。另外调研了一下近期发布的异步更新算法DC-ASGD，实验结果只能说对收敛有些正向效果，仍无法解决训练发散的问题。在另外一个DNN的网络上发现在多机时momentum对收敛结果有较大影响，momentum会导致收敛出现较大波动。\n\n<!-- more -->\n\n网上找了一圈，似乎也就这个有些参考价值：\nhttp://stanford.edu/~imit/tuneyourmomentum/theory/\n\n看来近期得做一些调momentum和学习率的实验了。。。\n","source":"_posts/ASGD中momentum的影响.md","raw":"---\ntitle: 多节点异步更新中momentum的影响\ndate: 2017-06-21 12:31:08\ncategory: deep learning\ntags: [caffe, deep learning, momentum]\n---\n\n\n这几天的主要工作是将caffe移植到组内新开发的某个计算框架，在验证正确性时遇到一个问题。由于计算框架只支持异步更新的方式，因此采用全异步SGD算法训练Alexnet时非常容易发散。另外调研了一下近期发布的异步更新算法DC-ASGD，实验结果只能说对收敛有些正向效果，仍无法解决训练发散的问题。在另外一个DNN的网络上发现在多机时momentum对收敛结果有较大影响，momentum会导致收敛出现较大波动。\n\n<!-- more -->\n\n网上找了一圈，似乎也就这个有些参考价值：\nhttp://stanford.edu/~imit/tuneyourmomentum/theory/\n\n看来近期得做一些调momentum和学习率的实验了。。。\n","slug":"ASGD中momentum的影响","published":1,"updated":"2023-01-03T13:52:18.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgavftf0001hbeq4w698lua","content":"<p>这几天的主要工作是将caffe移植到组内新开发的某个计算框架，在验证正确性时遇到一个问题。由于计算框架只支持异步更新的方式，因此采用全异步SGD算法训练Alexnet时非常容易发散。另外调研了一下近期发布的异步更新算法DC-ASGD，实验结果只能说对收敛有些正向效果，仍无法解决训练发散的问题。在另外一个DNN的网络上发现在多机时momentum对收敛结果有较大影响，momentum会导致收敛出现较大波动。</p>\n<span id=\"more\"></span>\n<p>网上找了一圈，似乎也就这个有些参考价值：\nhttp://stanford.edu/~imit/tuneyourmomentum/theory/</p>\n<p>看来近期得做一些调momentum和学习率的实验了。。。</p>\n","site":{"data":{}},"excerpt":"<p>这几天的主要工作是将caffe移植到组内新开发的某个计算框架，在验证正确性时遇到一个问题。由于计算框架只支持异步更新的方式，因此采用全异步SGD算法训练Alexnet时非常容易发散。另外调研了一下近期发布的异步更新算法DC-ASGD，实验结果只能说对收敛有些正向效果，仍无法解决训练发散的问题。在另外一个DNN的网络上发现在多机时momentum对收敛结果有较大影响，momentum会导致收敛出现较大波动。</p>","more":"<p>网上找了一圈，似乎也就这个有些参考价值：\nhttp://stanford.edu/~imit/tuneyourmomentum/theory/</p>\n<p>看来近期得做一些调momentum和学习率的实验了。。。</p>"},{"title":"阿里KunPeng框架学习","date":"2017-08-22T04:53:08.000Z","_content":"\n\nKunPeng是阿里最新公布的一个大规模机器学习框架，不仅包括了数据/模型并行、负载均衡、模型同步、稀疏表达、工业级容错等特性，而且还提供了易于使用的接口，在很多机器学习算法上都带来了非常大的性能提升。\n原始论文 KunPeng: Parameter Server based Distributed Learning Systems and Its Applications in Alibaba and Ant Financial。\n\n<!-- more -->\n\n## Introduction\n主要对一些通用分布式计算框架进行比较。  \n \nHadoop：只提供了一些粗粒度的操作，比如Map、Reduce和Join等。很多限制导致基于Hadoop的机器学习算法效率都非常低，这些限制包括中间结果会落盘、只能在shuffling阶段进行数据交换等。   \n\nSpark：使用RDD弥补了Hadoop的一些缺点，提供MLlib库，MLlib整合了很多机器学习算法，并且非常容易使用。但MLlib只支持中等规模的特征，计算和通信效率都比较低。一些公司使用第三方组件来弥补Spark的缺陷，但至今没有一个完美的方案。    \n\nGraphLab和GraphX：基于图的并行计算框架，允许用户进行细粒度的控制，但并不适合通用的机器学习算法，比如LR、深度学习等，并且也存在效率低的问题。    \n\nMPI：接口灵活高效，代码自由度比较高，比如在代码中所有进程之间可以随时通信。但使用MPI开发一个新算法的开销非常大，比如一个复杂的异步矩阵分解算法需要2000多行代码。MPI没有提供分布式ML平台通用的组件，比如分布式数据读取，内存管理和多线程并行的组件。更重要的是MPI没有提供单点失败的本地解决方案，根据他们的统计数据显示MPI作业在节点数越多时失败率越高。     \n\nparameter server框架：包含无状态的workers和有状态的servers，workers负责大部分的计算任务，servers负责保存和更新模型参数。servers可以定期将模型参数快照保存到一个缓存位置，一旦有节点失败，parameter server会自动从最新的checkpoint中恢复模型参数。parameter server框架只支持pserver和worker之间通信，\t而pserver和pserver、worker和worker之间无法进行点对点通信，并且由于细粒度的接口导致用户编程比较复杂，因此现有的parameter server框架还存在几个问题：一是通信接口比较单一，没有MPI灵活；二是对于用户来说没有Spark易于编程使用。     \n\n正是由于上述框架的种种缺点，他们开发了一个产品级的分布式学习系统—KunPeng。KunPeng结合了parameter server和MPI的优点，提供鲁棒的failover机制，高效的稀疏数据通信接口和与MPI类似的通用接口，并且提供一个C++和Python的SDK，该SDK提供了一个类似单机的开发环境。KunPeng也与阿里的Apsara平台深度对接，提供ML的全工具集，包括基于SQL和MapReduce的数据预处理、预测、评估等等。\n\n## KunPeng整体架构\n\n### Apsara Cloud Platform\nApsara是阿里开发的一个大规模分布式操作系统，目前已运行在跨数十个机房的十几万台服务器上。下图中天蓝色部分就是Apsara的模块，白色部分为运行在Apsara之上的各种云服务，KunPeng就属于图中白色部分，运行在Apsara上，由Apsara提供任务调度和监控、文件系统等服务。\n![b2b0cb8a6973ec2b4281d68c328e4a0f](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/b2b0cb8a6973ec2b4281d68c328e4a0f.png)\n图中红色边框的任务调度模块和资源管理模块被统称为Fuxi（伏羲），Fuxi支持多种特性以保证系统的可扩展性和容错性，这些特性包括：增量资源管理协议、用户透明的失败恢复、故障点自动检测和多级黑名单机制。\n\n## KunPeng Platform\nKunPeng分为ML-Bridge和PS-Core两个子系统，ML-Bridge是KunPeng提供的高级编程模型，用户通过脚本编程的workflow可以方便地实现数据预处理、训练、预测和评估等算法，PS-Core是一个分布式键值对存储的paramter server框架。\n![0313b564c3646a4c4fab16574f9c4b4e](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/0313b564c3646a4c4fab16574f9c4b4e.png?api=v2 =600)\nML-Bridge由三个组件构成：\n\n- 解释器。将用户的脚本解释为系统支持的算法\n- 优化器。根据运行状态的历史统计和启发式方法，分析、调试和优化作业配置\n- 执行器。根据作业的配置生成Fuxi调度的配置，提供整个作业生命周期的监控，并提供用户监控UI\n  ML-Bridge简化了用户编程，比如一个算法流程包括数据入库与预处理、训练、评估和AB测试几个流程，在KunPeng中只需要调用下图中的几行命令就可以实现。整个流程对用户来说都是透明的，用户也不需要关心算法的具体实现和作业调度过程。\n\n![ede2df215585fc86358bc9868565d1ce](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/ede2df215585fc86358bc9868565d1ce.png?api=v2 =500)\n\nPS-Core不仅支持数据并行和模型并行，同时还支持模型同步更新(BSP)、ASP和SSP，稀疏表达和容错机制。\nPS-Core在传统的worker和server基础上，增加了一个用于迭代控制的coordinator。coordinator声明了数据计算和参数更新的操作，构建了整个ML workerflows的作业图，并将这些作业调度到worker和server上运行，并参与servers和workers的failover过程。coordinator在迭代结束时会与Apsara的meta对迭代状态进行同步，并且由Fuxi监控管理，因此不存在SPOF（单点失败）的问题。\n\n### 容错方案\nKunPeng也给出了servers和workers的容错解决方案。对于servers，它们会异步地将参数快照保存到分布式文件系统，并且它们会在内存中对参数进行两备份，支持hot failover加速恢复过程。大多数情况下(比如接收到coordinator的恢复请求)，servers可以立刻通过内存备份的参数中恢复。即使是servers或整个任务被中断或被kill，servers也可以通过最近一次保存的参数进行恢复训练。对于stateless的workers，failover非常简单，只需要从servers上pull对应的参数。对于stateful的workers，同样提供保存快照的接口，因此对于一些workers有本地状态的算法（比如LDA），faliover也非常简单。\n\n总的来说，KunPeng的failover过程是当Fuxi检测到有节点失败时，重新调度新的节点，同时给coordinator发送异步节点失败的消息，coordinator接收消息后给servers和workers发送恢复请求，对于正常的servers接收请求后会直接从内存中恢复，而对于新调度的servers会从checkpoint中恢复，对于workers需要先从servers上pull对应的参数，stateful的workers还需要从保存的checkpoint中恢复状态。\n\n### DAG调度\n这里的调度指的是coordinator对servers和workers的调度。由于coordinator节点会根据算法的workflow构建对应的作业DAG，并将DAG调度到servers和workers上进行执行。为了提高机器资源利用率和作业效率，DAG中相同深度的节点可以并行执行，比如下图中的Calculate for Block 0节点和Load Data for Block 1节点。通过DAG接口用户可以自定义IO操作、计算和通信过程，可以很方便地实现各种模型更新算法。\n\n![e76cf7c13015b83ed7696b5fa7c8dac0](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/e76cf7c13015b83ed7696b5fa7c8dac0.png?api=v2 =600)\n\n下图表示了PS-Core中bounded delay ASGD算法的C++实现，用户可以重写下面的Iterate函数实现自定义的算法。图中的mServerParam和mServerGrad对应servers上的模型参数和梯度，mWorkerParam和mWorkerGrad对应workers本地的模型参数和梯度，mSubDatasetPtr对应当前worker的数据子集。nSync为最大延迟迭代次数，nPull和nPush分别为从servers获取最新参数和将梯度发送给servers的频率。通过设置nSync、nPull和nPush可以很方便地在BSP和SSP之间切换，而去除SyncBarrier就成了ASP算法的实现。\n\n![69ed0d3573fbebf558494bc4a9a14c74](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/69ed0d3573fbebf558494bc4a9a14c74.png?api=v2 =450)\n\n### 负载均衡和通信接口\n由于集群中机器的底层硬件和运行状态存在差异，因此一个任务的执行效率很大程度上取决于运行最慢的那个机器，针对这种情况可以有多种负载均衡的方法，比如可以对负载较高的机器分配更少的数据和计算量，PS-Core也为此设计了一个Backup instance机制。当某个节点被确定为慢节点时，coordinator会把慢节点标记为\"dead\"节点，请求Fuxi重新调度一个新的节点作为该节点的备份节点，并将该节点的负载转移到备份节点上。这种机制通常可以带来10%-20%的效率提升。\n\nKunPeng对不同稀疏度和不同数据类型的数据通信做了深度优化，并且提供workers之间点对点的通信接口，比如AllReduce，ReduceTo和Bcast，这些灵活的通信接口使得KunPeng可以拓展更多的功能，比如模型并行。\n\n## FTRL\n$$w_{t+1}=\\mathop{\\arg\\min}_{w}\\left(\\sum_{s=1}^{t}g_{s}w+\\frac{1}{2}\\sum_{s=1}^{t}\\delta_{s}{\\Vert}w-w_{s}{\\Vert}_{2}^{2}+\\lambda_{1}{\\Vert}w{\\Vert}_{1}+\\lambda_{2}{\\Vert}w{\\Vert}_{2}^{2}\\right)$$\n其中$g$为损失函数对$w$的梯度，$\\delta_{t}=\\frac{1}{\\eta_{t}}-\\frac{1}{\\eta_{t-1}}$，因此$\\sum_{s=1}^{t}{\\delta_{s}}=\\frac{1}{\\eta_{t}}$，$\\eta$为学习率，并且$\\eta_{t,i}=\\frac{\\alpha}{\\beta+\\sqrt{\\sum_{s=1}^{s}{g_{s,i}^2}}}$，通常$\\alpha=1$，$\\beta$是与数据集和特征相关的超参数。$\\lambda_{1}$为L1系数，$\\lambda_{2}$为L2系数。\n更新公式为  \n$$w_{t+1}=\\begin{cases}0& if\\ {\\vert}z_{i}{\\vert}{\\leq}\\lambda_{1}\\\\ -(\\frac{\\beta+\\sqrt{n_{i}}}{\\alpha}+\\lambda_{2})^{-1}(z_{i}-sign(z_{i})\\lambda_{1})& otherwise\\end{cases}$$\n下图表明了LR FTRL-Proximal算法单机更新过程。\n\n![66cf72a181547ae24831af8500b47d72](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/66cf72a181547ae24831af8500b47d72.png?api=v2 =500)\n\n这个算法在单机时很容易实现，但在分布式环境必须要考虑通信效率、servers的负载和算法收敛性问题。考虑到BSP的低效和ASP可能不收敛的问题，他们使用了bounded delay的SSP更新方法，并且设置trust region来调节参数范围，避免模型发散。整个算法具体过程如下：   \n \n- workers本地保存了模型$w$和$z$、$n$，$z$、$n$通过bounded-asynchronous的方式与servers保持同步\n- workers加载数据，根据$z$和$n$更新本地模型$w$，计算梯度并更新本地模型$w$和$z$、$n$，同时使用$\\delta_{z}$和$\\delta_{n}$累加$z$和$n$的增量，在需要与servers同步的时候将累加的$\\delta_{z}$和$\\delta_{n}$ push到servers\n- servers合并所有workers发送的$\\delta_{z}$和$\\delta_{n}$，最后更新全局$z$和$n$。\n\nworkers向servers传递$z$和$n$的增量，而不是直接传递模型梯度，这种做法虽然会带来一些通信开销，但降低了servers的计算负载，这是在通信效率和计算负载之间做的平衡。为了避免发散，servers在trust region下更新模型。trust region的策略有两种：一种是当模型中的元素超出置信阈时，直接回退整个模型；另一种是通过映射的方式将模型的值限制在置信阈中。\n\n![0de2241d38a792bb79446944d65d8c66](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/0de2241d38a792bb79446944d65d8c66.png?api=v2 =600)\n\n## MART\nMART（多增量回归树）又叫做GBDT，是一种应用比较广泛的机器学习算法。KunPeng实现了一个通用的MART算法，支持千亿级样本量和上千维的特征，并在MART的基础上实现了LambdaMART算法。\n\n- MART\n  为了处理超大规模的数据量，KunPeng-MART使用数据并行的方式减少内存使用量，并采用了XGBoost的分布式加权直方图算法优化分裂点查找过程。具体来说就是，每个worker都保存了整颗树，在分割叶节点时，\n  （1）每个worker使用分配的数据子集计算一个局部加权直方图，计算完成后将直方图push到servers\n  （2）servers收到workers发送的直方图后，采用多路合并算法得到全局直方图，并找到最优分割点\n  （3）workers从servers pull分割点，分裂节点并将数据分到分裂后的叶节点\n\n重复上述过程，可以得到整棵树。然后只要按照gradient boosting方法一棵一棵地建树，最终得到MART。随着特征维度和树深度的增加，查找分裂点过程中的计算和通信都可能成为性能瓶颈。为了解决这个问题，他们提到使用KunPeng的通信模式去减少合并局部直方图的开销，但并没有透露具体的方法。\n\n- LambdaMART\n  LambdaMART建树的过程与上面的MART一样，不同的是LambdaMART计算一阶导数和二阶导数的方式。由于LambdaMART要求同一个query group的训练数据按sample两两组成pair对，因此当训练数据不是按照query group连续存储时就会存在问题。对于这个问题，他们提出了两种解决方法：      \n  （1）先全局统计一下每个query id对应的样本总数，然后按照multiway number partitioning algorithm对query id进行分片，每个worker只加载属于自己的query ids对应的训练样本。    \n  （2）第二种是近似的方法。首先要求相同query id的样本在文件系统中是连续存储的，然后每个worker还是按照正常情况加载属于自己的分片数据。如果相同query id的样本被分在两个不同的worker上，则会把这两个worker上相同query id的样本当做不同query id来处理。    \n\n## 其他算法\n- Large-scale sparse Logistic Regression (LR)      \n  实现了不同的优化算法，L-BFGS、OWL-QN和BCD，其中BCD算法是数据和模型同时并行的算法。    \n- Distributed Factorization Machines    \n  workers异步计算梯度，使用AdaGrad优化算法    \n- Caffe    \n  实现了Caffe和KunPeng的对接，a generalized CPU-based large-scale deep learning platform，简化DL算法开发    \n\n## 实验结果\n下面的实验都是在一个拥有5000台服务器的正式集群上进行的，每台机器12个Intel Xeon CPU E5-2430 (2.2 GHz) CPU和96GB内存。\n\n### KunPeng、Spark和MPI的LR算法对比\n![143e082b7f1a6b54e47e9c8b51026dbb](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/143e082b7f1a6b54e47e9c8b51026dbb.png?api=v2)\n\n不同平台的LR都采用L-BFGS算法更新，并且memory history parameter都设置为10，并且使用同一个集群相同的CPU资源，在7个不同的数据集上KunPeng在效率和内存占用上都取得非常明显的优势。\n\n在另外一个18 billion样本和 7 billion特征的数据集上，他们统计了KunPeng在不同workers数量时的加速比。\n\n![00c84f368394ba04d59dbe530f69c387](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/00c84f368394ba04d59dbe530f69c387.png?api=v2)\n\nKunPeng仅使用25个workers就可以训练这么大的数据，workers增加时依然能保持较高的加速比，并且内存占用随着workers增加而近乎直线降低。\n\n###  KunPeng-MART和XGBoost的对比\n下图分别为KunPeng-MAR和XGBoost在不同任务上的峰值内存占用和训练时间对比。\n\n![1b0888cab293242eaccdc2b6e5bf25d9](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/1b0888cab293242eaccdc2b6e5bf25d9.png?api=v2 =500)\n\n![3b99dc82bc268d3da394a688c0234908](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/3b99dc82bc268d3da394a688c0234908.png?api=v2 =500)\n\n### KunPeng-FM、LibFM和DiFacto的对比\n下面是在单机情况下的训练效果对比，并没有训练时间的对比数据和多机实验相关的数据。\n\n![da511a1bb0db987fb74ebb08fa5352c9](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/da511a1bb0db987fb74ebb08fa5352c9.png?api=v2 =500)\n\n## 参考资料\n1、Ad Click Prediction: a View from the Trenches. \n","source":"_posts/KunPeng论文阅读.md","raw":"---\ntitle: 阿里KunPeng框架学习\ndate: 2017-08-22 12:53:08\ncategory: ML framework\ntags: [large scale ML framework, KunPeng]\n---\n\n\nKunPeng是阿里最新公布的一个大规模机器学习框架，不仅包括了数据/模型并行、负载均衡、模型同步、稀疏表达、工业级容错等特性，而且还提供了易于使用的接口，在很多机器学习算法上都带来了非常大的性能提升。\n原始论文 KunPeng: Parameter Server based Distributed Learning Systems and Its Applications in Alibaba and Ant Financial。\n\n<!-- more -->\n\n## Introduction\n主要对一些通用分布式计算框架进行比较。  \n \nHadoop：只提供了一些粗粒度的操作，比如Map、Reduce和Join等。很多限制导致基于Hadoop的机器学习算法效率都非常低，这些限制包括中间结果会落盘、只能在shuffling阶段进行数据交换等。   \n\nSpark：使用RDD弥补了Hadoop的一些缺点，提供MLlib库，MLlib整合了很多机器学习算法，并且非常容易使用。但MLlib只支持中等规模的特征，计算和通信效率都比较低。一些公司使用第三方组件来弥补Spark的缺陷，但至今没有一个完美的方案。    \n\nGraphLab和GraphX：基于图的并行计算框架，允许用户进行细粒度的控制，但并不适合通用的机器学习算法，比如LR、深度学习等，并且也存在效率低的问题。    \n\nMPI：接口灵活高效，代码自由度比较高，比如在代码中所有进程之间可以随时通信。但使用MPI开发一个新算法的开销非常大，比如一个复杂的异步矩阵分解算法需要2000多行代码。MPI没有提供分布式ML平台通用的组件，比如分布式数据读取，内存管理和多线程并行的组件。更重要的是MPI没有提供单点失败的本地解决方案，根据他们的统计数据显示MPI作业在节点数越多时失败率越高。     \n\nparameter server框架：包含无状态的workers和有状态的servers，workers负责大部分的计算任务，servers负责保存和更新模型参数。servers可以定期将模型参数快照保存到一个缓存位置，一旦有节点失败，parameter server会自动从最新的checkpoint中恢复模型参数。parameter server框架只支持pserver和worker之间通信，\t而pserver和pserver、worker和worker之间无法进行点对点通信，并且由于细粒度的接口导致用户编程比较复杂，因此现有的parameter server框架还存在几个问题：一是通信接口比较单一，没有MPI灵活；二是对于用户来说没有Spark易于编程使用。     \n\n正是由于上述框架的种种缺点，他们开发了一个产品级的分布式学习系统—KunPeng。KunPeng结合了parameter server和MPI的优点，提供鲁棒的failover机制，高效的稀疏数据通信接口和与MPI类似的通用接口，并且提供一个C++和Python的SDK，该SDK提供了一个类似单机的开发环境。KunPeng也与阿里的Apsara平台深度对接，提供ML的全工具集，包括基于SQL和MapReduce的数据预处理、预测、评估等等。\n\n## KunPeng整体架构\n\n### Apsara Cloud Platform\nApsara是阿里开发的一个大规模分布式操作系统，目前已运行在跨数十个机房的十几万台服务器上。下图中天蓝色部分就是Apsara的模块，白色部分为运行在Apsara之上的各种云服务，KunPeng就属于图中白色部分，运行在Apsara上，由Apsara提供任务调度和监控、文件系统等服务。\n![b2b0cb8a6973ec2b4281d68c328e4a0f](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/b2b0cb8a6973ec2b4281d68c328e4a0f.png)\n图中红色边框的任务调度模块和资源管理模块被统称为Fuxi（伏羲），Fuxi支持多种特性以保证系统的可扩展性和容错性，这些特性包括：增量资源管理协议、用户透明的失败恢复、故障点自动检测和多级黑名单机制。\n\n## KunPeng Platform\nKunPeng分为ML-Bridge和PS-Core两个子系统，ML-Bridge是KunPeng提供的高级编程模型，用户通过脚本编程的workflow可以方便地实现数据预处理、训练、预测和评估等算法，PS-Core是一个分布式键值对存储的paramter server框架。\n![0313b564c3646a4c4fab16574f9c4b4e](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/0313b564c3646a4c4fab16574f9c4b4e.png?api=v2 =600)\nML-Bridge由三个组件构成：\n\n- 解释器。将用户的脚本解释为系统支持的算法\n- 优化器。根据运行状态的历史统计和启发式方法，分析、调试和优化作业配置\n- 执行器。根据作业的配置生成Fuxi调度的配置，提供整个作业生命周期的监控，并提供用户监控UI\n  ML-Bridge简化了用户编程，比如一个算法流程包括数据入库与预处理、训练、评估和AB测试几个流程，在KunPeng中只需要调用下图中的几行命令就可以实现。整个流程对用户来说都是透明的，用户也不需要关心算法的具体实现和作业调度过程。\n\n![ede2df215585fc86358bc9868565d1ce](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/ede2df215585fc86358bc9868565d1ce.png?api=v2 =500)\n\nPS-Core不仅支持数据并行和模型并行，同时还支持模型同步更新(BSP)、ASP和SSP，稀疏表达和容错机制。\nPS-Core在传统的worker和server基础上，增加了一个用于迭代控制的coordinator。coordinator声明了数据计算和参数更新的操作，构建了整个ML workerflows的作业图，并将这些作业调度到worker和server上运行，并参与servers和workers的failover过程。coordinator在迭代结束时会与Apsara的meta对迭代状态进行同步，并且由Fuxi监控管理，因此不存在SPOF（单点失败）的问题。\n\n### 容错方案\nKunPeng也给出了servers和workers的容错解决方案。对于servers，它们会异步地将参数快照保存到分布式文件系统，并且它们会在内存中对参数进行两备份，支持hot failover加速恢复过程。大多数情况下(比如接收到coordinator的恢复请求)，servers可以立刻通过内存备份的参数中恢复。即使是servers或整个任务被中断或被kill，servers也可以通过最近一次保存的参数进行恢复训练。对于stateless的workers，failover非常简单，只需要从servers上pull对应的参数。对于stateful的workers，同样提供保存快照的接口，因此对于一些workers有本地状态的算法（比如LDA），faliover也非常简单。\n\n总的来说，KunPeng的failover过程是当Fuxi检测到有节点失败时，重新调度新的节点，同时给coordinator发送异步节点失败的消息，coordinator接收消息后给servers和workers发送恢复请求，对于正常的servers接收请求后会直接从内存中恢复，而对于新调度的servers会从checkpoint中恢复，对于workers需要先从servers上pull对应的参数，stateful的workers还需要从保存的checkpoint中恢复状态。\n\n### DAG调度\n这里的调度指的是coordinator对servers和workers的调度。由于coordinator节点会根据算法的workflow构建对应的作业DAG，并将DAG调度到servers和workers上进行执行。为了提高机器资源利用率和作业效率，DAG中相同深度的节点可以并行执行，比如下图中的Calculate for Block 0节点和Load Data for Block 1节点。通过DAG接口用户可以自定义IO操作、计算和通信过程，可以很方便地实现各种模型更新算法。\n\n![e76cf7c13015b83ed7696b5fa7c8dac0](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/e76cf7c13015b83ed7696b5fa7c8dac0.png?api=v2 =600)\n\n下图表示了PS-Core中bounded delay ASGD算法的C++实现，用户可以重写下面的Iterate函数实现自定义的算法。图中的mServerParam和mServerGrad对应servers上的模型参数和梯度，mWorkerParam和mWorkerGrad对应workers本地的模型参数和梯度，mSubDatasetPtr对应当前worker的数据子集。nSync为最大延迟迭代次数，nPull和nPush分别为从servers获取最新参数和将梯度发送给servers的频率。通过设置nSync、nPull和nPush可以很方便地在BSP和SSP之间切换，而去除SyncBarrier就成了ASP算法的实现。\n\n![69ed0d3573fbebf558494bc4a9a14c74](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/69ed0d3573fbebf558494bc4a9a14c74.png?api=v2 =450)\n\n### 负载均衡和通信接口\n由于集群中机器的底层硬件和运行状态存在差异，因此一个任务的执行效率很大程度上取决于运行最慢的那个机器，针对这种情况可以有多种负载均衡的方法，比如可以对负载较高的机器分配更少的数据和计算量，PS-Core也为此设计了一个Backup instance机制。当某个节点被确定为慢节点时，coordinator会把慢节点标记为\"dead\"节点，请求Fuxi重新调度一个新的节点作为该节点的备份节点，并将该节点的负载转移到备份节点上。这种机制通常可以带来10%-20%的效率提升。\n\nKunPeng对不同稀疏度和不同数据类型的数据通信做了深度优化，并且提供workers之间点对点的通信接口，比如AllReduce，ReduceTo和Bcast，这些灵活的通信接口使得KunPeng可以拓展更多的功能，比如模型并行。\n\n## FTRL\n$$w_{t+1}=\\mathop{\\arg\\min}_{w}\\left(\\sum_{s=1}^{t}g_{s}w+\\frac{1}{2}\\sum_{s=1}^{t}\\delta_{s}{\\Vert}w-w_{s}{\\Vert}_{2}^{2}+\\lambda_{1}{\\Vert}w{\\Vert}_{1}+\\lambda_{2}{\\Vert}w{\\Vert}_{2}^{2}\\right)$$\n其中$g$为损失函数对$w$的梯度，$\\delta_{t}=\\frac{1}{\\eta_{t}}-\\frac{1}{\\eta_{t-1}}$，因此$\\sum_{s=1}^{t}{\\delta_{s}}=\\frac{1}{\\eta_{t}}$，$\\eta$为学习率，并且$\\eta_{t,i}=\\frac{\\alpha}{\\beta+\\sqrt{\\sum_{s=1}^{s}{g_{s,i}^2}}}$，通常$\\alpha=1$，$\\beta$是与数据集和特征相关的超参数。$\\lambda_{1}$为L1系数，$\\lambda_{2}$为L2系数。\n更新公式为  \n$$w_{t+1}=\\begin{cases}0& if\\ {\\vert}z_{i}{\\vert}{\\leq}\\lambda_{1}\\\\ -(\\frac{\\beta+\\sqrt{n_{i}}}{\\alpha}+\\lambda_{2})^{-1}(z_{i}-sign(z_{i})\\lambda_{1})& otherwise\\end{cases}$$\n下图表明了LR FTRL-Proximal算法单机更新过程。\n\n![66cf72a181547ae24831af8500b47d72](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/66cf72a181547ae24831af8500b47d72.png?api=v2 =500)\n\n这个算法在单机时很容易实现，但在分布式环境必须要考虑通信效率、servers的负载和算法收敛性问题。考虑到BSP的低效和ASP可能不收敛的问题，他们使用了bounded delay的SSP更新方法，并且设置trust region来调节参数范围，避免模型发散。整个算法具体过程如下：   \n \n- workers本地保存了模型$w$和$z$、$n$，$z$、$n$通过bounded-asynchronous的方式与servers保持同步\n- workers加载数据，根据$z$和$n$更新本地模型$w$，计算梯度并更新本地模型$w$和$z$、$n$，同时使用$\\delta_{z}$和$\\delta_{n}$累加$z$和$n$的增量，在需要与servers同步的时候将累加的$\\delta_{z}$和$\\delta_{n}$ push到servers\n- servers合并所有workers发送的$\\delta_{z}$和$\\delta_{n}$，最后更新全局$z$和$n$。\n\nworkers向servers传递$z$和$n$的增量，而不是直接传递模型梯度，这种做法虽然会带来一些通信开销，但降低了servers的计算负载，这是在通信效率和计算负载之间做的平衡。为了避免发散，servers在trust region下更新模型。trust region的策略有两种：一种是当模型中的元素超出置信阈时，直接回退整个模型；另一种是通过映射的方式将模型的值限制在置信阈中。\n\n![0de2241d38a792bb79446944d65d8c66](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/0de2241d38a792bb79446944d65d8c66.png?api=v2 =600)\n\n## MART\nMART（多增量回归树）又叫做GBDT，是一种应用比较广泛的机器学习算法。KunPeng实现了一个通用的MART算法，支持千亿级样本量和上千维的特征，并在MART的基础上实现了LambdaMART算法。\n\n- MART\n  为了处理超大规模的数据量，KunPeng-MART使用数据并行的方式减少内存使用量，并采用了XGBoost的分布式加权直方图算法优化分裂点查找过程。具体来说就是，每个worker都保存了整颗树，在分割叶节点时，\n  （1）每个worker使用分配的数据子集计算一个局部加权直方图，计算完成后将直方图push到servers\n  （2）servers收到workers发送的直方图后，采用多路合并算法得到全局直方图，并找到最优分割点\n  （3）workers从servers pull分割点，分裂节点并将数据分到分裂后的叶节点\n\n重复上述过程，可以得到整棵树。然后只要按照gradient boosting方法一棵一棵地建树，最终得到MART。随着特征维度和树深度的增加，查找分裂点过程中的计算和通信都可能成为性能瓶颈。为了解决这个问题，他们提到使用KunPeng的通信模式去减少合并局部直方图的开销，但并没有透露具体的方法。\n\n- LambdaMART\n  LambdaMART建树的过程与上面的MART一样，不同的是LambdaMART计算一阶导数和二阶导数的方式。由于LambdaMART要求同一个query group的训练数据按sample两两组成pair对，因此当训练数据不是按照query group连续存储时就会存在问题。对于这个问题，他们提出了两种解决方法：      \n  （1）先全局统计一下每个query id对应的样本总数，然后按照multiway number partitioning algorithm对query id进行分片，每个worker只加载属于自己的query ids对应的训练样本。    \n  （2）第二种是近似的方法。首先要求相同query id的样本在文件系统中是连续存储的，然后每个worker还是按照正常情况加载属于自己的分片数据。如果相同query id的样本被分在两个不同的worker上，则会把这两个worker上相同query id的样本当做不同query id来处理。    \n\n## 其他算法\n- Large-scale sparse Logistic Regression (LR)      \n  实现了不同的优化算法，L-BFGS、OWL-QN和BCD，其中BCD算法是数据和模型同时并行的算法。    \n- Distributed Factorization Machines    \n  workers异步计算梯度，使用AdaGrad优化算法    \n- Caffe    \n  实现了Caffe和KunPeng的对接，a generalized CPU-based large-scale deep learning platform，简化DL算法开发    \n\n## 实验结果\n下面的实验都是在一个拥有5000台服务器的正式集群上进行的，每台机器12个Intel Xeon CPU E5-2430 (2.2 GHz) CPU和96GB内存。\n\n### KunPeng、Spark和MPI的LR算法对比\n![143e082b7f1a6b54e47e9c8b51026dbb](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/143e082b7f1a6b54e47e9c8b51026dbb.png?api=v2)\n\n不同平台的LR都采用L-BFGS算法更新，并且memory history parameter都设置为10，并且使用同一个集群相同的CPU资源，在7个不同的数据集上KunPeng在效率和内存占用上都取得非常明显的优势。\n\n在另外一个18 billion样本和 7 billion特征的数据集上，他们统计了KunPeng在不同workers数量时的加速比。\n\n![00c84f368394ba04d59dbe530f69c387](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/00c84f368394ba04d59dbe530f69c387.png?api=v2)\n\nKunPeng仅使用25个workers就可以训练这么大的数据，workers增加时依然能保持较高的加速比，并且内存占用随着workers增加而近乎直线降低。\n\n###  KunPeng-MART和XGBoost的对比\n下图分别为KunPeng-MAR和XGBoost在不同任务上的峰值内存占用和训练时间对比。\n\n![1b0888cab293242eaccdc2b6e5bf25d9](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/1b0888cab293242eaccdc2b6e5bf25d9.png?api=v2 =500)\n\n![3b99dc82bc268d3da394a688c0234908](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/3b99dc82bc268d3da394a688c0234908.png?api=v2 =500)\n\n### KunPeng-FM、LibFM和DiFacto的对比\n下面是在单机情况下的训练效果对比，并没有训练时间的对比数据和多机实验相关的数据。\n\n![da511a1bb0db987fb74ebb08fa5352c9](https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/da511a1bb0db987fb74ebb08fa5352c9.png?api=v2 =500)\n\n## 参考资料\n1、Ad Click Prediction: a View from the Trenches. \n","slug":"KunPeng论文阅读","published":1,"updated":"2023-01-03T13:52:40.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgavfti0003hbeq3jgohwl0","content":"<p>KunPeng是阿里最新公布的一个大规模机器学习框架，不仅包括了数据/模型并行、负载均衡、模型同步、稀疏表达、工业级容错等特性，而且还提供了易于使用的接口，在很多机器学习算法上都带来了非常大的性能提升。\n原始论文 KunPeng: Parameter Server based Distributed Learning Systems\nand Its Applications in Alibaba and Ant Financial。</p>\n<span id=\"more\"></span>\n<h2 id=\"introduction\">Introduction</h2>\n<p>主要对一些通用分布式计算框架进行比较。</p>\n<p>Hadoop：只提供了一些粗粒度的操作，比如Map、Reduce和Join等。很多限制导致基于Hadoop的机器学习算法效率都非常低，这些限制包括中间结果会落盘、只能在shuffling阶段进行数据交换等。</p>\n<p>Spark：使用RDD弥补了Hadoop的一些缺点，提供MLlib库，MLlib整合了很多机器学习算法，并且非常容易使用。但MLlib只支持中等规模的特征，计算和通信效率都比较低。一些公司使用第三方组件来弥补Spark的缺陷，但至今没有一个完美的方案。</p>\n<p>GraphLab和GraphX：基于图的并行计算框架，允许用户进行细粒度的控制，但并不适合通用的机器学习算法，比如LR、深度学习等，并且也存在效率低的问题。</p>\n<p>MPI：接口灵活高效，代码自由度比较高，比如在代码中所有进程之间可以随时通信。但使用MPI开发一个新算法的开销非常大，比如一个复杂的异步矩阵分解算法需要2000多行代码。MPI没有提供分布式ML平台通用的组件，比如分布式数据读取，内存管理和多线程并行的组件。更重要的是MPI没有提供单点失败的本地解决方案，根据他们的统计数据显示MPI作业在节点数越多时失败率越高。</p>\n<p>parameter\nserver框架：包含无状态的workers和有状态的servers，workers负责大部分的计算任务，servers负责保存和更新模型参数。servers可以定期将模型参数快照保存到一个缓存位置，一旦有节点失败，parameter\nserver会自动从最新的checkpoint中恢复模型参数。parameter\nserver框架只支持pserver和worker之间通信，\n而pserver和pserver、worker和worker之间无法进行点对点通信，并且由于细粒度的接口导致用户编程比较复杂，因此现有的parameter\nserver框架还存在几个问题：一是通信接口比较单一，没有MPI灵活；二是对于用户来说没有Spark易于编程使用。</p>\n<p>正是由于上述框架的种种缺点，他们开发了一个产品级的分布式学习系统—KunPeng。KunPeng结合了parameter\nserver和MPI的优点，提供鲁棒的failover机制，高效的稀疏数据通信接口和与MPI类似的通用接口，并且提供一个C++和Python的SDK，该SDK提供了一个类似单机的开发环境。KunPeng也与阿里的Apsara平台深度对接，提供ML的全工具集，包括基于SQL和MapReduce的数据预处理、预测、评估等等。</p>\n<h2 id=\"kunpeng整体架构\">KunPeng整体架构</h2>\n<h3 id=\"apsara-cloud-platform\">Apsara Cloud Platform</h3>\n<p>Apsara是阿里开发的一个大规模分布式操作系统，目前已运行在跨数十个机房的十几万台服务器上。下图中天蓝色部分就是Apsara的模块，白色部分为运行在Apsara之上的各种云服务，KunPeng就属于图中白色部分，运行在Apsara上，由Apsara提供任务调度和监控、文件系统等服务。\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/b2b0cb8a6973ec2b4281d68c328e4a0f.png\"\nalt=\"b2b0cb8a6973ec2b4281d68c328e4a0f\" />\n图中红色边框的任务调度模块和资源管理模块被统称为Fuxi（伏羲），Fuxi支持多种特性以保证系统的可扩展性和容错性，这些特性包括：增量资源管理协议、用户透明的失败恢复、故障点自动检测和多级黑名单机制。</p>\n<h2 id=\"kunpeng-platform\">KunPeng Platform</h2>\n<p>KunPeng分为ML-Bridge和PS-Core两个子系统，ML-Bridge是KunPeng提供的高级编程模型，用户通过脚本编程的workflow可以方便地实现数据预处理、训练、预测和评估等算法，PS-Core是一个分布式键值对存储的paramter\nserver框架。 <img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/0313b564c3646a4c4fab16574f9c4b4e.png?api=v2%20=600\"\nalt=\"0313b564c3646a4c4fab16574f9c4b4e\" /> ML-Bridge由三个组件构成：</p>\n<ul>\n<li>解释器。将用户的脚本解释为系统支持的算法</li>\n<li>优化器。根据运行状态的历史统计和启发式方法，分析、调试和优化作业配置</li>\n<li>执行器。根据作业的配置生成Fuxi调度的配置，提供整个作业生命周期的监控，并提供用户监控UI\nML-Bridge简化了用户编程，比如一个算法流程包括数据入库与预处理、训练、评估和AB测试几个流程，在KunPeng中只需要调用下图中的几行命令就可以实现。整个流程对用户来说都是透明的，用户也不需要关心算法的具体实现和作业调度过程。</li>\n</ul>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/ede2df215585fc86358bc9868565d1ce.png?api=v2%20=500\"\nalt=\"ede2df215585fc86358bc9868565d1ce\" />\n<figcaption\naria-hidden=\"true\">ede2df215585fc86358bc9868565d1ce</figcaption>\n</figure>\n<p>PS-Core不仅支持数据并行和模型并行，同时还支持模型同步更新(BSP)、ASP和SSP，稀疏表达和容错机制。\nPS-Core在传统的worker和server基础上，增加了一个用于迭代控制的coordinator。coordinator声明了数据计算和参数更新的操作，构建了整个ML\nworkerflows的作业图，并将这些作业调度到worker和server上运行，并参与servers和workers的failover过程。coordinator在迭代结束时会与Apsara的meta对迭代状态进行同步，并且由Fuxi监控管理，因此不存在SPOF（单点失败）的问题。</p>\n<h3 id=\"容错方案\">容错方案</h3>\n<p>KunPeng也给出了servers和workers的容错解决方案。对于servers，它们会异步地将参数快照保存到分布式文件系统，并且它们会在内存中对参数进行两备份，支持hot\nfailover加速恢复过程。大多数情况下(比如接收到coordinator的恢复请求)，servers可以立刻通过内存备份的参数中恢复。即使是servers或整个任务被中断或被kill，servers也可以通过最近一次保存的参数进行恢复训练。对于stateless的workers，failover非常简单，只需要从servers上pull对应的参数。对于stateful的workers，同样提供保存快照的接口，因此对于一些workers有本地状态的算法（比如LDA），faliover也非常简单。</p>\n<p>总的来说，KunPeng的failover过程是当Fuxi检测到有节点失败时，重新调度新的节点，同时给coordinator发送异步节点失败的消息，coordinator接收消息后给servers和workers发送恢复请求，对于正常的servers接收请求后会直接从内存中恢复，而对于新调度的servers会从checkpoint中恢复，对于workers需要先从servers上pull对应的参数，stateful的workers还需要从保存的checkpoint中恢复状态。</p>\n<h3 id=\"dag调度\">DAG调度</h3>\n<p>这里的调度指的是coordinator对servers和workers的调度。由于coordinator节点会根据算法的workflow构建对应的作业DAG，并将DAG调度到servers和workers上进行执行。为了提高机器资源利用率和作业效率，DAG中相同深度的节点可以并行执行，比如下图中的Calculate\nfor Block 0节点和Load Data for Block\n1节点。通过DAG接口用户可以自定义IO操作、计算和通信过程，可以很方便地实现各种模型更新算法。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/e76cf7c13015b83ed7696b5fa7c8dac0.png?api=v2%20=600\"\nalt=\"e76cf7c13015b83ed7696b5fa7c8dac0\" />\n<figcaption\naria-hidden=\"true\">e76cf7c13015b83ed7696b5fa7c8dac0</figcaption>\n</figure>\n<p>下图表示了PS-Core中bounded delay\nASGD算法的C++实现，用户可以重写下面的Iterate函数实现自定义的算法。图中的mServerParam和mServerGrad对应servers上的模型参数和梯度，mWorkerParam和mWorkerGrad对应workers本地的模型参数和梯度，mSubDatasetPtr对应当前worker的数据子集。nSync为最大延迟迭代次数，nPull和nPush分别为从servers获取最新参数和将梯度发送给servers的频率。通过设置nSync、nPull和nPush可以很方便地在BSP和SSP之间切换，而去除SyncBarrier就成了ASP算法的实现。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/69ed0d3573fbebf558494bc4a9a14c74.png?api=v2%20=450\"\nalt=\"69ed0d3573fbebf558494bc4a9a14c74\" />\n<figcaption\naria-hidden=\"true\">69ed0d3573fbebf558494bc4a9a14c74</figcaption>\n</figure>\n<h3 id=\"负载均衡和通信接口\">负载均衡和通信接口</h3>\n<p>由于集群中机器的底层硬件和运行状态存在差异，因此一个任务的执行效率很大程度上取决于运行最慢的那个机器，针对这种情况可以有多种负载均衡的方法，比如可以对负载较高的机器分配更少的数据和计算量，PS-Core也为此设计了一个Backup\ninstance机制。当某个节点被确定为慢节点时，coordinator会把慢节点标记为\"dead\"节点，请求Fuxi重新调度一个新的节点作为该节点的备份节点，并将该节点的负载转移到备份节点上。这种机制通常可以带来10%-20%的效率提升。</p>\n<p>KunPeng对不同稀疏度和不同数据类型的数据通信做了深度优化，并且提供workers之间点对点的通信接口，比如AllReduce，ReduceTo和Bcast，这些灵活的通信接口使得KunPeng可以拓展更多的功能，比如模型并行。</p>\n<h2 id=\"ftrl\">FTRL</h2>\n<p><span\nclass=\"math display\">\\[w_{t+1}=\\mathop{\\arg\\min}_{w}\\left(\\sum_{s=1}^{t}g_{s}w+\\frac{1}{2}\\sum_{s=1}^{t}\\delta_{s}{\\Vert}w-w_{s}{\\Vert}_{2}^{2}+\\lambda_{1}{\\Vert}w{\\Vert}_{1}+\\lambda_{2}{\\Vert}w{\\Vert}_{2}^{2}\\right)\\]</span>\n其中<span class=\"math inline\">\\(g\\)</span>为损失函数对<span\nclass=\"math inline\">\\(w\\)</span>的梯度，<span\nclass=\"math inline\">\\(\\delta_{t}=\\frac{1}{\\eta_{t}}-\\frac{1}{\\eta_{t-1}}\\)</span>，因此<span\nclass=\"math inline\">\\(\\sum_{s=1}^{t}{\\delta_{s}}=\\frac{1}{\\eta_{t}}\\)</span>，<span\nclass=\"math inline\">\\(\\eta\\)</span>为学习率，并且<span\nclass=\"math inline\">\\(\\eta_{t,i}=\\frac{\\alpha}{\\beta+\\sqrt{\\sum_{s=1}^{s}{g_{s,i}^2}}}\\)</span>，通常<span\nclass=\"math inline\">\\(\\alpha=1\\)</span>，<span\nclass=\"math inline\">\\(\\beta\\)</span>是与数据集和特征相关的超参数。<span\nclass=\"math inline\">\\(\\lambda_{1}\\)</span>为L1系数，<span\nclass=\"math inline\">\\(\\lambda_{2}\\)</span>为L2系数。 更新公式为<br />\n<span class=\"math display\">\\[w_{t+1}=\\begin{cases}0&amp; if\\\n{\\vert}z_{i}{\\vert}{\\leq}\\lambda_{1}\\\\\n-(\\frac{\\beta+\\sqrt{n_{i}}}{\\alpha}+\\lambda_{2})^{-1}(z_{i}-sign(z_{i})\\lambda_{1})&amp;\notherwise\\end{cases}\\]</span> 下图表明了LR\nFTRL-Proximal算法单机更新过程。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/66cf72a181547ae24831af8500b47d72.png?api=v2%20=500\"\nalt=\"66cf72a181547ae24831af8500b47d72\" />\n<figcaption\naria-hidden=\"true\">66cf72a181547ae24831af8500b47d72</figcaption>\n</figure>\n<p>这个算法在单机时很容易实现，但在分布式环境必须要考虑通信效率、servers的负载和算法收敛性问题。考虑到BSP的低效和ASP可能不收敛的问题，他们使用了bounded\ndelay的SSP更新方法，并且设置trust\nregion来调节参数范围，避免模型发散。整个算法具体过程如下：</p>\n<ul>\n<li>workers本地保存了模型<span class=\"math inline\">\\(w\\)</span>和<span\nclass=\"math inline\">\\(z\\)</span>、<span\nclass=\"math inline\">\\(n\\)</span>，<span\nclass=\"math inline\">\\(z\\)</span>、<span\nclass=\"math inline\">\\(n\\)</span>通过bounded-asynchronous的方式与servers保持同步</li>\n<li>workers加载数据，根据<span class=\"math inline\">\\(z\\)</span>和<span\nclass=\"math inline\">\\(n\\)</span>更新本地模型<span\nclass=\"math inline\">\\(w\\)</span>，计算梯度并更新本地模型<span\nclass=\"math inline\">\\(w\\)</span>和<span\nclass=\"math inline\">\\(z\\)</span>、<span\nclass=\"math inline\">\\(n\\)</span>，同时使用<span\nclass=\"math inline\">\\(\\delta_{z}\\)</span>和<span\nclass=\"math inline\">\\(\\delta_{n}\\)</span>累加<span\nclass=\"math inline\">\\(z\\)</span>和<span\nclass=\"math inline\">\\(n\\)</span>的增量，在需要与servers同步的时候将累加的<span\nclass=\"math inline\">\\(\\delta_{z}\\)</span>和<span\nclass=\"math inline\">\\(\\delta_{n}\\)</span> push到servers</li>\n<li>servers合并所有workers发送的<span\nclass=\"math inline\">\\(\\delta_{z}\\)</span>和<span\nclass=\"math inline\">\\(\\delta_{n}\\)</span>，最后更新全局<span\nclass=\"math inline\">\\(z\\)</span>和<span\nclass=\"math inline\">\\(n\\)</span>。</li>\n</ul>\n<p>workers向servers传递<span class=\"math inline\">\\(z\\)</span>和<span\nclass=\"math inline\">\\(n\\)</span>的增量，而不是直接传递模型梯度，这种做法虽然会带来一些通信开销，但降低了servers的计算负载，这是在通信效率和计算负载之间做的平衡。为了避免发散，servers在trust\nregion下更新模型。trust\nregion的策略有两种：一种是当模型中的元素超出置信阈时，直接回退整个模型；另一种是通过映射的方式将模型的值限制在置信阈中。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/0de2241d38a792bb79446944d65d8c66.png?api=v2%20=600\"\nalt=\"0de2241d38a792bb79446944d65d8c66\" />\n<figcaption\naria-hidden=\"true\">0de2241d38a792bb79446944d65d8c66</figcaption>\n</figure>\n<h2 id=\"mart\">MART</h2>\n<p>MART（多增量回归树）又叫做GBDT，是一种应用比较广泛的机器学习算法。KunPeng实现了一个通用的MART算法，支持千亿级样本量和上千维的特征，并在MART的基础上实现了LambdaMART算法。</p>\n<ul>\n<li>MART\n为了处理超大规模的数据量，KunPeng-MART使用数据并行的方式减少内存使用量，并采用了XGBoost的分布式加权直方图算法优化分裂点查找过程。具体来说就是，每个worker都保存了整颗树，在分割叶节点时，\n（1）每个worker使用分配的数据子集计算一个局部加权直方图，计算完成后将直方图push到servers\n（2）servers收到workers发送的直方图后，采用多路合并算法得到全局直方图，并找到最优分割点\n（3）workers从servers\npull分割点，分裂节点并将数据分到分裂后的叶节点</li>\n</ul>\n<p>重复上述过程，可以得到整棵树。然后只要按照gradient\nboosting方法一棵一棵地建树，最终得到MART。随着特征维度和树深度的增加，查找分裂点过程中的计算和通信都可能成为性能瓶颈。为了解决这个问题，他们提到使用KunPeng的通信模式去减少合并局部直方图的开销，但并没有透露具体的方法。</p>\n<ul>\n<li>LambdaMART\nLambdaMART建树的过程与上面的MART一样，不同的是LambdaMART计算一阶导数和二阶导数的方式。由于LambdaMART要求同一个query\ngroup的训练数据按sample两两组成pair对，因此当训练数据不是按照query\ngroup连续存储时就会存在问题。对于这个问题，他们提出了两种解决方法：<br />\n（1）先全局统计一下每个query id对应的样本总数，然后按照multiway number\npartitioning algorithm对query\nid进行分片，每个worker只加载属于自己的query ids对应的训练样本。<br />\n（2）第二种是近似的方法。首先要求相同query\nid的样本在文件系统中是连续存储的，然后每个worker还是按照正常情况加载属于自己的分片数据。如果相同query\nid的样本被分在两个不同的worker上，则会把这两个worker上相同query\nid的样本当做不同query id来处理。</li>\n</ul>\n<h2 id=\"其他算法\">其他算法</h2>\n<ul>\n<li>Large-scale sparse Logistic Regression (LR)<br />\n实现了不同的优化算法，L-BFGS、OWL-QN和BCD，其中BCD算法是数据和模型同时并行的算法。<br />\n</li>\n<li>Distributed Factorization Machines<br />\nworkers异步计算梯度，使用AdaGrad优化算法<br />\n</li>\n<li>Caffe<br />\n实现了Caffe和KunPeng的对接，a generalized CPU-based large-scale deep\nlearning platform，简化DL算法开发</li>\n</ul>\n<h2 id=\"实验结果\">实验结果</h2>\n<p>下面的实验都是在一个拥有5000台服务器的正式集群上进行的，每台机器12个Intel\nXeon CPU E5-2430 (2.2 GHz) CPU和96GB内存。</p>\n<h3\nid=\"kunpengspark和mpi的lr算法对比\">KunPeng、Spark和MPI的LR算法对比</h3>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/143e082b7f1a6b54e47e9c8b51026dbb.png?api=v2\"\nalt=\"143e082b7f1a6b54e47e9c8b51026dbb\" />\n<figcaption\naria-hidden=\"true\">143e082b7f1a6b54e47e9c8b51026dbb</figcaption>\n</figure>\n<p>不同平台的LR都采用L-BFGS算法更新，并且memory history\nparameter都设置为10，并且使用同一个集群相同的CPU资源，在7个不同的数据集上KunPeng在效率和内存占用上都取得非常明显的优势。</p>\n<p>在另外一个18 billion样本和 7\nbillion特征的数据集上，他们统计了KunPeng在不同workers数量时的加速比。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/00c84f368394ba04d59dbe530f69c387.png?api=v2\"\nalt=\"00c84f368394ba04d59dbe530f69c387\" />\n<figcaption\naria-hidden=\"true\">00c84f368394ba04d59dbe530f69c387</figcaption>\n</figure>\n<p>KunPeng仅使用25个workers就可以训练这么大的数据，workers增加时依然能保持较高的加速比，并且内存占用随着workers增加而近乎直线降低。</p>\n<h3 id=\"kunpeng-mart和xgboost的对比\">KunPeng-MART和XGBoost的对比</h3>\n<p>下图分别为KunPeng-MAR和XGBoost在不同任务上的峰值内存占用和训练时间对比。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/1b0888cab293242eaccdc2b6e5bf25d9.png?api=v2%20=500\"\nalt=\"1b0888cab293242eaccdc2b6e5bf25d9\" />\n<figcaption\naria-hidden=\"true\">1b0888cab293242eaccdc2b6e5bf25d9</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/3b99dc82bc268d3da394a688c0234908.png?api=v2%20=500\"\nalt=\"3b99dc82bc268d3da394a688c0234908\" />\n<figcaption\naria-hidden=\"true\">3b99dc82bc268d3da394a688c0234908</figcaption>\n</figure>\n<h3\nid=\"kunpeng-fmlibfm和difacto的对比\">KunPeng-FM、LibFM和DiFacto的对比</h3>\n<p>下面是在单机情况下的训练效果对比，并没有训练时间的对比数据和多机实验相关的数据。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/da511a1bb0db987fb74ebb08fa5352c9.png?api=v2%20=500\"\nalt=\"da511a1bb0db987fb74ebb08fa5352c9\" />\n<figcaption\naria-hidden=\"true\">da511a1bb0db987fb74ebb08fa5352c9</figcaption>\n</figure>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>1、Ad Click Prediction: a View from the Trenches.</p>\n","site":{"data":{}},"excerpt":"<p>KunPeng是阿里最新公布的一个大规模机器学习框架，不仅包括了数据/模型并行、负载均衡、模型同步、稀疏表达、工业级容错等特性，而且还提供了易于使用的接口，在很多机器学习算法上都带来了非常大的性能提升。\n原始论文 KunPeng: Parameter Server based Distributed Learning Systems\nand Its Applications in Alibaba and Ant Financial。</p>","more":"<h2 id=\"introduction\">Introduction</h2>\n<p>主要对一些通用分布式计算框架进行比较。</p>\n<p>Hadoop：只提供了一些粗粒度的操作，比如Map、Reduce和Join等。很多限制导致基于Hadoop的机器学习算法效率都非常低，这些限制包括中间结果会落盘、只能在shuffling阶段进行数据交换等。</p>\n<p>Spark：使用RDD弥补了Hadoop的一些缺点，提供MLlib库，MLlib整合了很多机器学习算法，并且非常容易使用。但MLlib只支持中等规模的特征，计算和通信效率都比较低。一些公司使用第三方组件来弥补Spark的缺陷，但至今没有一个完美的方案。</p>\n<p>GraphLab和GraphX：基于图的并行计算框架，允许用户进行细粒度的控制，但并不适合通用的机器学习算法，比如LR、深度学习等，并且也存在效率低的问题。</p>\n<p>MPI：接口灵活高效，代码自由度比较高，比如在代码中所有进程之间可以随时通信。但使用MPI开发一个新算法的开销非常大，比如一个复杂的异步矩阵分解算法需要2000多行代码。MPI没有提供分布式ML平台通用的组件，比如分布式数据读取，内存管理和多线程并行的组件。更重要的是MPI没有提供单点失败的本地解决方案，根据他们的统计数据显示MPI作业在节点数越多时失败率越高。</p>\n<p>parameter\nserver框架：包含无状态的workers和有状态的servers，workers负责大部分的计算任务，servers负责保存和更新模型参数。servers可以定期将模型参数快照保存到一个缓存位置，一旦有节点失败，parameter\nserver会自动从最新的checkpoint中恢复模型参数。parameter\nserver框架只支持pserver和worker之间通信，\n而pserver和pserver、worker和worker之间无法进行点对点通信，并且由于细粒度的接口导致用户编程比较复杂，因此现有的parameter\nserver框架还存在几个问题：一是通信接口比较单一，没有MPI灵活；二是对于用户来说没有Spark易于编程使用。</p>\n<p>正是由于上述框架的种种缺点，他们开发了一个产品级的分布式学习系统—KunPeng。KunPeng结合了parameter\nserver和MPI的优点，提供鲁棒的failover机制，高效的稀疏数据通信接口和与MPI类似的通用接口，并且提供一个C++和Python的SDK，该SDK提供了一个类似单机的开发环境。KunPeng也与阿里的Apsara平台深度对接，提供ML的全工具集，包括基于SQL和MapReduce的数据预处理、预测、评估等等。</p>\n<h2 id=\"kunpeng整体架构\">KunPeng整体架构</h2>\n<h3 id=\"apsara-cloud-platform\">Apsara Cloud Platform</h3>\n<p>Apsara是阿里开发的一个大规模分布式操作系统，目前已运行在跨数十个机房的十几万台服务器上。下图中天蓝色部分就是Apsara的模块，白色部分为运行在Apsara之上的各种云服务，KunPeng就属于图中白色部分，运行在Apsara上，由Apsara提供任务调度和监控、文件系统等服务。\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/b2b0cb8a6973ec2b4281d68c328e4a0f.png\"\nalt=\"b2b0cb8a6973ec2b4281d68c328e4a0f\" />\n图中红色边框的任务调度模块和资源管理模块被统称为Fuxi（伏羲），Fuxi支持多种特性以保证系统的可扩展性和容错性，这些特性包括：增量资源管理协议、用户透明的失败恢复、故障点自动检测和多级黑名单机制。</p>\n<h2 id=\"kunpeng-platform\">KunPeng Platform</h2>\n<p>KunPeng分为ML-Bridge和PS-Core两个子系统，ML-Bridge是KunPeng提供的高级编程模型，用户通过脚本编程的workflow可以方便地实现数据预处理、训练、预测和评估等算法，PS-Core是一个分布式键值对存储的paramter\nserver框架。 <img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/0313b564c3646a4c4fab16574f9c4b4e.png?api=v2%20=600\"\nalt=\"0313b564c3646a4c4fab16574f9c4b4e\" /> ML-Bridge由三个组件构成：</p>\n<ul>\n<li>解释器。将用户的脚本解释为系统支持的算法</li>\n<li>优化器。根据运行状态的历史统计和启发式方法，分析、调试和优化作业配置</li>\n<li>执行器。根据作业的配置生成Fuxi调度的配置，提供整个作业生命周期的监控，并提供用户监控UI\nML-Bridge简化了用户编程，比如一个算法流程包括数据入库与预处理、训练、评估和AB测试几个流程，在KunPeng中只需要调用下图中的几行命令就可以实现。整个流程对用户来说都是透明的，用户也不需要关心算法的具体实现和作业调度过程。</li>\n</ul>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/ede2df215585fc86358bc9868565d1ce.png?api=v2%20=500\"\nalt=\"ede2df215585fc86358bc9868565d1ce\" />\n<figcaption\naria-hidden=\"true\">ede2df215585fc86358bc9868565d1ce</figcaption>\n</figure>\n<p>PS-Core不仅支持数据并行和模型并行，同时还支持模型同步更新(BSP)、ASP和SSP，稀疏表达和容错机制。\nPS-Core在传统的worker和server基础上，增加了一个用于迭代控制的coordinator。coordinator声明了数据计算和参数更新的操作，构建了整个ML\nworkerflows的作业图，并将这些作业调度到worker和server上运行，并参与servers和workers的failover过程。coordinator在迭代结束时会与Apsara的meta对迭代状态进行同步，并且由Fuxi监控管理，因此不存在SPOF（单点失败）的问题。</p>\n<h3 id=\"容错方案\">容错方案</h3>\n<p>KunPeng也给出了servers和workers的容错解决方案。对于servers，它们会异步地将参数快照保存到分布式文件系统，并且它们会在内存中对参数进行两备份，支持hot\nfailover加速恢复过程。大多数情况下(比如接收到coordinator的恢复请求)，servers可以立刻通过内存备份的参数中恢复。即使是servers或整个任务被中断或被kill，servers也可以通过最近一次保存的参数进行恢复训练。对于stateless的workers，failover非常简单，只需要从servers上pull对应的参数。对于stateful的workers，同样提供保存快照的接口，因此对于一些workers有本地状态的算法（比如LDA），faliover也非常简单。</p>\n<p>总的来说，KunPeng的failover过程是当Fuxi检测到有节点失败时，重新调度新的节点，同时给coordinator发送异步节点失败的消息，coordinator接收消息后给servers和workers发送恢复请求，对于正常的servers接收请求后会直接从内存中恢复，而对于新调度的servers会从checkpoint中恢复，对于workers需要先从servers上pull对应的参数，stateful的workers还需要从保存的checkpoint中恢复状态。</p>\n<h3 id=\"dag调度\">DAG调度</h3>\n<p>这里的调度指的是coordinator对servers和workers的调度。由于coordinator节点会根据算法的workflow构建对应的作业DAG，并将DAG调度到servers和workers上进行执行。为了提高机器资源利用率和作业效率，DAG中相同深度的节点可以并行执行，比如下图中的Calculate\nfor Block 0节点和Load Data for Block\n1节点。通过DAG接口用户可以自定义IO操作、计算和通信过程，可以很方便地实现各种模型更新算法。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/e76cf7c13015b83ed7696b5fa7c8dac0.png?api=v2%20=600\"\nalt=\"e76cf7c13015b83ed7696b5fa7c8dac0\" />\n<figcaption\naria-hidden=\"true\">e76cf7c13015b83ed7696b5fa7c8dac0</figcaption>\n</figure>\n<p>下图表示了PS-Core中bounded delay\nASGD算法的C++实现，用户可以重写下面的Iterate函数实现自定义的算法。图中的mServerParam和mServerGrad对应servers上的模型参数和梯度，mWorkerParam和mWorkerGrad对应workers本地的模型参数和梯度，mSubDatasetPtr对应当前worker的数据子集。nSync为最大延迟迭代次数，nPull和nPush分别为从servers获取最新参数和将梯度发送给servers的频率。通过设置nSync、nPull和nPush可以很方便地在BSP和SSP之间切换，而去除SyncBarrier就成了ASP算法的实现。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/69ed0d3573fbebf558494bc4a9a14c74.png?api=v2%20=450\"\nalt=\"69ed0d3573fbebf558494bc4a9a14c74\" />\n<figcaption\naria-hidden=\"true\">69ed0d3573fbebf558494bc4a9a14c74</figcaption>\n</figure>\n<h3 id=\"负载均衡和通信接口\">负载均衡和通信接口</h3>\n<p>由于集群中机器的底层硬件和运行状态存在差异，因此一个任务的执行效率很大程度上取决于运行最慢的那个机器，针对这种情况可以有多种负载均衡的方法，比如可以对负载较高的机器分配更少的数据和计算量，PS-Core也为此设计了一个Backup\ninstance机制。当某个节点被确定为慢节点时，coordinator会把慢节点标记为\"dead\"节点，请求Fuxi重新调度一个新的节点作为该节点的备份节点，并将该节点的负载转移到备份节点上。这种机制通常可以带来10%-20%的效率提升。</p>\n<p>KunPeng对不同稀疏度和不同数据类型的数据通信做了深度优化，并且提供workers之间点对点的通信接口，比如AllReduce，ReduceTo和Bcast，这些灵活的通信接口使得KunPeng可以拓展更多的功能，比如模型并行。</p>\n<h2 id=\"ftrl\">FTRL</h2>\n<p><span\nclass=\"math display\">\\[w_{t+1}=\\mathop{\\arg\\min}_{w}\\left(\\sum_{s=1}^{t}g_{s}w+\\frac{1}{2}\\sum_{s=1}^{t}\\delta_{s}{\\Vert}w-w_{s}{\\Vert}_{2}^{2}+\\lambda_{1}{\\Vert}w{\\Vert}_{1}+\\lambda_{2}{\\Vert}w{\\Vert}_{2}^{2}\\right)\\]</span>\n其中<span class=\"math inline\">\\(g\\)</span>为损失函数对<span\nclass=\"math inline\">\\(w\\)</span>的梯度，<span\nclass=\"math inline\">\\(\\delta_{t}=\\frac{1}{\\eta_{t}}-\\frac{1}{\\eta_{t-1}}\\)</span>，因此<span\nclass=\"math inline\">\\(\\sum_{s=1}^{t}{\\delta_{s}}=\\frac{1}{\\eta_{t}}\\)</span>，<span\nclass=\"math inline\">\\(\\eta\\)</span>为学习率，并且<span\nclass=\"math inline\">\\(\\eta_{t,i}=\\frac{\\alpha}{\\beta+\\sqrt{\\sum_{s=1}^{s}{g_{s,i}^2}}}\\)</span>，通常<span\nclass=\"math inline\">\\(\\alpha=1\\)</span>，<span\nclass=\"math inline\">\\(\\beta\\)</span>是与数据集和特征相关的超参数。<span\nclass=\"math inline\">\\(\\lambda_{1}\\)</span>为L1系数，<span\nclass=\"math inline\">\\(\\lambda_{2}\\)</span>为L2系数。 更新公式为<br />\n<span class=\"math display\">\\[w_{t+1}=\\begin{cases}0&amp; if\\\n{\\vert}z_{i}{\\vert}{\\leq}\\lambda_{1}\\\\\n-(\\frac{\\beta+\\sqrt{n_{i}}}{\\alpha}+\\lambda_{2})^{-1}(z_{i}-sign(z_{i})\\lambda_{1})&amp;\notherwise\\end{cases}\\]</span> 下图表明了LR\nFTRL-Proximal算法单机更新过程。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/66cf72a181547ae24831af8500b47d72.png?api=v2%20=500\"\nalt=\"66cf72a181547ae24831af8500b47d72\" />\n<figcaption\naria-hidden=\"true\">66cf72a181547ae24831af8500b47d72</figcaption>\n</figure>\n<p>这个算法在单机时很容易实现，但在分布式环境必须要考虑通信效率、servers的负载和算法收敛性问题。考虑到BSP的低效和ASP可能不收敛的问题，他们使用了bounded\ndelay的SSP更新方法，并且设置trust\nregion来调节参数范围，避免模型发散。整个算法具体过程如下：</p>\n<ul>\n<li>workers本地保存了模型<span class=\"math inline\">\\(w\\)</span>和<span\nclass=\"math inline\">\\(z\\)</span>、<span\nclass=\"math inline\">\\(n\\)</span>，<span\nclass=\"math inline\">\\(z\\)</span>、<span\nclass=\"math inline\">\\(n\\)</span>通过bounded-asynchronous的方式与servers保持同步</li>\n<li>workers加载数据，根据<span class=\"math inline\">\\(z\\)</span>和<span\nclass=\"math inline\">\\(n\\)</span>更新本地模型<span\nclass=\"math inline\">\\(w\\)</span>，计算梯度并更新本地模型<span\nclass=\"math inline\">\\(w\\)</span>和<span\nclass=\"math inline\">\\(z\\)</span>、<span\nclass=\"math inline\">\\(n\\)</span>，同时使用<span\nclass=\"math inline\">\\(\\delta_{z}\\)</span>和<span\nclass=\"math inline\">\\(\\delta_{n}\\)</span>累加<span\nclass=\"math inline\">\\(z\\)</span>和<span\nclass=\"math inline\">\\(n\\)</span>的增量，在需要与servers同步的时候将累加的<span\nclass=\"math inline\">\\(\\delta_{z}\\)</span>和<span\nclass=\"math inline\">\\(\\delta_{n}\\)</span> push到servers</li>\n<li>servers合并所有workers发送的<span\nclass=\"math inline\">\\(\\delta_{z}\\)</span>和<span\nclass=\"math inline\">\\(\\delta_{n}\\)</span>，最后更新全局<span\nclass=\"math inline\">\\(z\\)</span>和<span\nclass=\"math inline\">\\(n\\)</span>。</li>\n</ul>\n<p>workers向servers传递<span class=\"math inline\">\\(z\\)</span>和<span\nclass=\"math inline\">\\(n\\)</span>的增量，而不是直接传递模型梯度，这种做法虽然会带来一些通信开销，但降低了servers的计算负载，这是在通信效率和计算负载之间做的平衡。为了避免发散，servers在trust\nregion下更新模型。trust\nregion的策略有两种：一种是当模型中的元素超出置信阈时，直接回退整个模型；另一种是通过映射的方式将模型的值限制在置信阈中。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/0de2241d38a792bb79446944d65d8c66.png?api=v2%20=600\"\nalt=\"0de2241d38a792bb79446944d65d8c66\" />\n<figcaption\naria-hidden=\"true\">0de2241d38a792bb79446944d65d8c66</figcaption>\n</figure>\n<h2 id=\"mart\">MART</h2>\n<p>MART（多增量回归树）又叫做GBDT，是一种应用比较广泛的机器学习算法。KunPeng实现了一个通用的MART算法，支持千亿级样本量和上千维的特征，并在MART的基础上实现了LambdaMART算法。</p>\n<ul>\n<li>MART\n为了处理超大规模的数据量，KunPeng-MART使用数据并行的方式减少内存使用量，并采用了XGBoost的分布式加权直方图算法优化分裂点查找过程。具体来说就是，每个worker都保存了整颗树，在分割叶节点时，\n（1）每个worker使用分配的数据子集计算一个局部加权直方图，计算完成后将直方图push到servers\n（2）servers收到workers发送的直方图后，采用多路合并算法得到全局直方图，并找到最优分割点\n（3）workers从servers\npull分割点，分裂节点并将数据分到分裂后的叶节点</li>\n</ul>\n<p>重复上述过程，可以得到整棵树。然后只要按照gradient\nboosting方法一棵一棵地建树，最终得到MART。随着特征维度和树深度的增加，查找分裂点过程中的计算和通信都可能成为性能瓶颈。为了解决这个问题，他们提到使用KunPeng的通信模式去减少合并局部直方图的开销，但并没有透露具体的方法。</p>\n<ul>\n<li>LambdaMART\nLambdaMART建树的过程与上面的MART一样，不同的是LambdaMART计算一阶导数和二阶导数的方式。由于LambdaMART要求同一个query\ngroup的训练数据按sample两两组成pair对，因此当训练数据不是按照query\ngroup连续存储时就会存在问题。对于这个问题，他们提出了两种解决方法：<br />\n（1）先全局统计一下每个query id对应的样本总数，然后按照multiway number\npartitioning algorithm对query\nid进行分片，每个worker只加载属于自己的query ids对应的训练样本。<br />\n（2）第二种是近似的方法。首先要求相同query\nid的样本在文件系统中是连续存储的，然后每个worker还是按照正常情况加载属于自己的分片数据。如果相同query\nid的样本被分在两个不同的worker上，则会把这两个worker上相同query\nid的样本当做不同query id来处理。</li>\n</ul>\n<h2 id=\"其他算法\">其他算法</h2>\n<ul>\n<li>Large-scale sparse Logistic Regression (LR)<br />\n实现了不同的优化算法，L-BFGS、OWL-QN和BCD，其中BCD算法是数据和模型同时并行的算法。<br />\n</li>\n<li>Distributed Factorization Machines<br />\nworkers异步计算梯度，使用AdaGrad优化算法<br />\n</li>\n<li>Caffe<br />\n实现了Caffe和KunPeng的对接，a generalized CPU-based large-scale deep\nlearning platform，简化DL算法开发</li>\n</ul>\n<h2 id=\"实验结果\">实验结果</h2>\n<p>下面的实验都是在一个拥有5000台服务器的正式集群上进行的，每台机器12个Intel\nXeon CPU E5-2430 (2.2 GHz) CPU和96GB内存。</p>\n<h3\nid=\"kunpengspark和mpi的lr算法对比\">KunPeng、Spark和MPI的LR算法对比</h3>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/143e082b7f1a6b54e47e9c8b51026dbb.png?api=v2\"\nalt=\"143e082b7f1a6b54e47e9c8b51026dbb\" />\n<figcaption\naria-hidden=\"true\">143e082b7f1a6b54e47e9c8b51026dbb</figcaption>\n</figure>\n<p>不同平台的LR都采用L-BFGS算法更新，并且memory history\nparameter都设置为10，并且使用同一个集群相同的CPU资源，在7个不同的数据集上KunPeng在效率和内存占用上都取得非常明显的优势。</p>\n<p>在另外一个18 billion样本和 7\nbillion特征的数据集上，他们统计了KunPeng在不同workers数量时的加速比。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/00c84f368394ba04d59dbe530f69c387.png?api=v2\"\nalt=\"00c84f368394ba04d59dbe530f69c387\" />\n<figcaption\naria-hidden=\"true\">00c84f368394ba04d59dbe530f69c387</figcaption>\n</figure>\n<p>KunPeng仅使用25个workers就可以训练这么大的数据，workers增加时依然能保持较高的加速比，并且内存占用随着workers增加而近乎直线降低。</p>\n<h3 id=\"kunpeng-mart和xgboost的对比\">KunPeng-MART和XGBoost的对比</h3>\n<p>下图分别为KunPeng-MAR和XGBoost在不同任务上的峰值内存占用和训练时间对比。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/1b0888cab293242eaccdc2b6e5bf25d9.png?api=v2%20=500\"\nalt=\"1b0888cab293242eaccdc2b6e5bf25d9\" />\n<figcaption\naria-hidden=\"true\">1b0888cab293242eaccdc2b6e5bf25d9</figcaption>\n</figure>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/3b99dc82bc268d3da394a688c0234908.png?api=v2%20=500\"\nalt=\"3b99dc82bc268d3da394a688c0234908\" />\n<figcaption\naria-hidden=\"true\">3b99dc82bc268d3da394a688c0234908</figcaption>\n</figure>\n<h3\nid=\"kunpeng-fmlibfm和difacto的对比\">KunPeng-FM、LibFM和DiFacto的对比</h3>\n<p>下面是在单机情况下的训练效果对比，并没有训练时间的对比数据和多机实验相关的数据。</p>\n<figure>\n<img\nsrc=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/KunPeng/da511a1bb0db987fb74ebb08fa5352c9.png?api=v2%20=500\"\nalt=\"da511a1bb0db987fb74ebb08fa5352c9\" />\n<figcaption\naria-hidden=\"true\">da511a1bb0db987fb74ebb08fa5352c9</figcaption>\n</figure>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>1、Ad Click Prediction: a View from the Trenches.</p>"},{"title":"Mac上搭建基于Github的Hexo博客 — Testing","date":"2017-03-22T13:31:08.000Z","_content":"## 博客搭建\n搭建过程请参考[原文链接](http://www.jianshu.com/p/13e64c9e2295)。   \n\n注意在mac上安装hexo时选择安装hexo-cli，否则可能会出现以下报错：   \n[Error: Cannot find module './DTraceProviderBindings']\n\n<!-- more -->\n\n## 主题美化\n简单说一下，下次有时间写个详细过程。主要做了以下修改：\n\n1. 使用NexT主题替换默认的landscape主题   \n2. 简化了页脚，看起来更美观   \n3. 修改了左边侧栏黑色背景，改成灰色   \n4. 侧栏加入本地搜索功能    \n5. 使用hypercomments评论插件，支持匿名评论   \n","source":"_posts/Mac上搭建基于Github的Hexo博客.md","raw":"---\ntitle: Mac上搭建基于Github的Hexo博客 — Testing\ndate: 2017-03-22 21:31:08\ncategory: Daily\ntags: web technology\n---\n## 博客搭建\n搭建过程请参考[原文链接](http://www.jianshu.com/p/13e64c9e2295)。   \n\n注意在mac上安装hexo时选择安装hexo-cli，否则可能会出现以下报错：   \n[Error: Cannot find module './DTraceProviderBindings']\n\n<!-- more -->\n\n## 主题美化\n简单说一下，下次有时间写个详细过程。主要做了以下修改：\n\n1. 使用NexT主题替换默认的landscape主题   \n2. 简化了页脚，看起来更美观   \n3. 修改了左边侧栏黑色背景，改成灰色   \n4. 侧栏加入本地搜索功能    \n5. 使用hypercomments评论插件，支持匿名评论   \n","slug":"Mac上搭建基于Github的Hexo博客","published":1,"updated":"2023-01-03T13:52:57.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgavftm0007hbeqcugw52tj","content":"<h2 id=\"博客搭建\">博客搭建</h2>\n<p>搭建过程请参考<a\nhref=\"http://www.jianshu.com/p/13e64c9e2295\">原文链接</a>。</p>\n<p>注意在mac上安装hexo时选择安装hexo-cli，否则可能会出现以下报错：<br />\n[Error: Cannot find module './DTraceProviderBindings']</p>\n<span id=\"more\"></span>\n<h2 id=\"主题美化\">主题美化</h2>\n<p>简单说一下，下次有时间写个详细过程。主要做了以下修改：</p>\n<ol type=\"1\">\n<li>使用NexT主题替换默认的landscape主题<br />\n</li>\n<li>简化了页脚，看起来更美观<br />\n</li>\n<li>修改了左边侧栏黑色背景，改成灰色<br />\n</li>\n<li>侧栏加入本地搜索功能<br />\n</li>\n<li>使用hypercomments评论插件，支持匿名评论</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"博客搭建\">博客搭建</h2>\n<p>搭建过程请参考<a\nhref=\"http://www.jianshu.com/p/13e64c9e2295\">原文链接</a>。</p>\n<p>注意在mac上安装hexo时选择安装hexo-cli，否则可能会出现以下报错：<br />\n[Error: Cannot find module './DTraceProviderBindings']</p>","more":"<h2 id=\"主题美化\">主题美化</h2>\n<p>简单说一下，下次有时间写个详细过程。主要做了以下修改：</p>\n<ol type=\"1\">\n<li>使用NexT主题替换默认的landscape主题<br />\n</li>\n<li>简化了页脚，看起来更美观<br />\n</li>\n<li>修改了左边侧栏黑色背景，改成灰色<br />\n</li>\n<li>侧栏加入本地搜索功能<br />\n</li>\n<li>使用hypercomments评论插件，支持匿名评论</li>\n</ol>"},{"title":"caffe学习总结","date":"2017-01-19T04:31:08.000Z","_content":"\n#caffe学习总结\n\n##caffe的由来\ncaffe是贾扬清在UC Berkeley攻读计算机科学博士学位时开发的一套深度学习框架，由于高效、易读和模块化的设计，开源后经过nvidia的帮助优化和社区不断的完善，如今成为视觉领域主流的框架之一。\n\n<!-- more -->\n\n- 贾扬清其人   \n  清华大学的本硕，UC Berkeley的计算机科学博士，师承Prof. Trevor Darrell，期间在新加坡国立大学、微软亚洲研究院、NEC美国实验室和google研究院实习和工作。博士毕业后一直在google brain担任研究科学家，致力于机器视觉、深度学习和tensorflow相关工作。2016年2月加入facebook，主导facebook大多数AI应用的通用、大规模机器学习平台（目前以caffe2为基础的caffe2go已经开源）。\n  \n- 为什么要开发caffe   \n  贾最早开发的是另一款软件Decaf，主要功能是基于cuda-convnet进行CNN训练。2013年贾扬清读博期间跟心理学老师合作研究使用概率框架来表达人的行为，\"但是因为图像上提取的特征比较弱，所以可以外推的结果比较有限\"，而2012年Alex Krizhevsky提出的AlexNet在ImageNet比赛中大获成功，贾因此也希望将CNN应用到他们的心理学研究上，于是就开始写了Decaf，通过Decaf验证了\"深度学习特征的优异的可移植性\"，因此就开始开发一套通用的深度学习框架，即后来的caffe。\n\n##caffe与其他一些主流框架的比较\ncaffe同期也存在其他一些开源框架，比如cuda-convnet、theano、torch等，并且后来又陆续开源了neon、mxnet、tensorflow、CNTK以及paddled等等。现在对于研究者，如何选择一个框架也成了一个麻烦的问题了。下图是2014年贾扬清在caffe论文中对当时的一些框架做的一个比较：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-001.png?raw=true width=800></div>\n\n下面是近年主流框架的一个简单比较：\n\n- 特性\n\n| | 主语言 | 从语言 | 硬件 | 分布式 | 命令式 | 声明式 | 自动梯度 |\n| ------------- |:-------------:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n| caffe | C++ | Python/Matlab | CPU/GPU | ✖ | ✖ | ✔ | ✖ | \n| mxnet | C++ | Python/R/Julia/Scala | CPU/GPU/Mobile | ✔ | ✔ | ✔ | ✔ |\n| tensorflow | C++ | Python | CPU/GPU/Mobile | ✔ | ✖ | ✔ | ✔ |\n| Torch | Lua | - | CPU/GPU/FPGA | ✔ | ✔ | ✖ | ✔ |\n| theano | Python | - | CPU/GPU | ✖ | ✖ | ✔ | ✔ |\n\n- 效率\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-002.png?raw=true width=420></div>\n\n##caffe代码组织结构\ncaffe代码结构是非常清晰的，主要包含以下文件和目录：\n\n- Makefile和Makefile.config\ncaffe支持cmake和make两种编译方式，不过大部分人只需要用make编译就可以了。Makefile.config可以对一些编译选项进行配置，比如USE_MPI、CPU_ONLY、DEBUG等等。\n- include\n在caffe中除了proto文件生成的头文件外，所有的c++头文件都放在include目录中。\n- src\nsrc与include的目录结构基本上相同，include目录中的文件基本上都能在src目录中找到对应的实现文件。\n- tools\ntools目录下是caffe提供给用户直接使用的接口，比如caffe.cpp用于模型训练、评估以及统计耗时，另外也提供一些数据集转换、计算均值等工具\n- examples\n提供一些训练相关的脚本和网络配置，比如数据预处理脚本、不同的网络配置文件以及训练脚本\n- models\n提供一些模型的网络配置文件，以及训练好的模型，用户可以直接用训练好的模型进行fine-tune或者分类\n- matlab/python\n提供matlab和python的接口\n\n##caffe网络的组织方式\n从LeNet开始，CNN就开始有了一个标准的分层结构——堆叠卷积层，卷积层可能后接一些normalization和pooling层，网络最后接一个或多个全连接层。由于梯度下降算法非常适合逐层计算，因此当时很多的通用框架都将网络（Net）抽象为多个数据处理层（Layer）组成的有向图，并支持灵活地定义网络结构。caffe将神经网络的训练问题分解为四个方面：数据、计算、流动控制以及问题求解，分别对应caffe中的Blob、Layer、Net和Solver。网络中流动的数据以及参数都用Blob来表示，Layer负责前向输出和后向梯度的计算，Net负责控制Layer计算的顺序，Solver是一个求解器的角色，根据Net的梯度对网络参数进行更新。\n\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-003.png?raw=true width=800>\n\n[待补充]\n\n##caffe中的Blob及同步策略\nBlob是caffe中存储数据的基本结构，可以简单理解为一个4维的数组，数据组织格式为（N,C,H,W）。在caffe中上下层流动的数据和每层的权重参数都是用Blob来保存的，为了便于使用，Blob具有一些特性：\n\n- Blob的内存是懒分配的（lazily allocate），只有在真正使用的时候才会分配内存\n- Blob会在CPU和GPU上各自分配一块相同大小的内存，便于在CPU和GPU之间进行切换\n- 用户不需要关心CPU和GPU数据的同步，Blob会根据需要自动同步\n\n下面是Blob的成员变量，data_是Blob存储的数据，diff_保存的是数据的梯度，shape_data_和shape_保存的都是当前数组的形状，count_是当前数据的大小，capacity_是申请的内存的大小，避免每次Reshape都要释放并重新申请内存。\n\n```c++\n  // include/caffe/blob.hpp\n  shared_ptr<SyncedMemory> data_;\n  shared_ptr<SyncedMemory> diff_;\n  shared_ptr<SyncedMemory> shape_data_;\n  vector<int> shape_;\n  int count_;\n  int capacity_;\n```\n\n下面主要说一下Blob的自动同步策略。首先看一下SyncedMemory的成员变量：\n\n```c++\n  // include/caffe/syncedmem.hpp\n  void* cpu_ptr_; // CPU内存数据\n  void* gpu_ptr_; // GPU显存数据\n  size_t size_;   // 数据大小\n  SyncedHead head_;  // 同步标志\n  bool own_cpu_data_; \n  bool cpu_malloc_use_cuda_;\n  bool own_gpu_data_;\n  int gpu_device_; // GPU设备号\n```\n\nhead_的取值范围为UNINITIALIZED, HEAD_AT_CPU, HEAD_AT_GPU, SYNCED。初始化时head_值为UNINITIALIZED，当调用Blob的取值函数时都会调用一次SyncedMemory的to_cpu或者to_gpu进行数据的同步，同步策略为：   \n1、取cpu数据时，会调用to_cpu函数，如果heda_为HEAD_AT_GPU，则需要将GPU的数据同步至CPU，否则不需要同步   \n2、取gpu数据时，会调用to_gpu函数，如果heda_为HEAD_AT_CPU，则需要将CPU的数据同步至GPU，否则不需要同步\n\nhead_标志的赋值：   \n1、每次调用SyncedMemory的mutable_cpu_data时，head_都会被置为HEAD_AT_CPU   \n2、每次调用SyncedMemory的mutable_gpu_data时，head_都会被置为HEAD_AT_GPU   \n3、每次同步之后heda_会被置为SYNCED。\n\n因此Blob通过判断每次修改的位置来自行决定是否需要对不同设备间的两份数据进行同步，使用时就像只有一份数据一样，非常方便。\n\n##caffe中的Layer\nlayer是caffe模型的主要组成部分和基本的计算单元，与很多框架中的operator对应，一个典型的layer在forward时从下层连接获取输入，经过计算后输出到上层，backward时又从上层连接获取误差，计算本层梯度和误差后，将误差传递到下层连接。因此基类Layer实现了三个基本函数setup、forward和backward。\n\n- setup：根据下层连接和配置参数完成本层参数的初始化，以及输出blobs的初始化\n- forward：前向计算过程，并计算本层的loss\n- backward：后向计算过程，并将本层误差传递到下层\n\nforward和backward里面都会对CPU和GPU进行分支，如果是CPU模式，则真正参与计算的是forward_cpu和backward_cpu，如果是GPU模式，则参与计算的是forward_gpu和backward_gpu，并且在基类中forward_gpu和backward_gpu分别调用的是forward_cpu和backward_cpu，当然用户在定义新的layer时可以自行实现forward_gpu和backward_gpu。\n \n基类Layer的成员变量：\n\n```c++\n  // include/caffe/layer.hpp\n  /** The protobuf that stores the layer parameters */\n  LayerParameter layer_param_;\n  /** The phase: TRAIN or TEST */\n  Phase phase_;\n  /** The vector that stores the learnable parameters as a set of blobs. */\n  vector<shared_ptr<Blob<Dtype> > > blobs_;\n  /** Vector indicating whether to compute the diff of each param blob. */\n  vector<bool> param_propagate_down_;\n  /** The vector that indicates whether each top blob has a non-zero weight in\n   *  the objective function. */\n  vector<Dtype> loss_;\n```\n\nlayer_param_是从protobuf文件中反序列化得到的，存放的是layer的配置参数\nphase_指示是训练还是测试\nblobs_是本层的参数，比如权重和偏置\nparam_propagate_down_为每一个参数设定是否需要计算梯度\nloss_是本层的损失值，loss层每个输出blob都有一个损失值，非loss层损失为0\n \n由基类Layer直接或间接派生出各种layer，比如卷积(convolution)、全连接(fully connected或者inner product)、dropout、pooling、relu、softmaxWithLoss等等，每一个派生layer都会强制实现forward_cpu和backward_cpu。早期的caffe将layer分成5类，\n\n- dataLayer类： 各类数据读取的接口\n- neuronLayer类： 各种激活函数、dropout\n- visionLayer类： 卷积层、采样层等2D图像相关的运算\n- commonLayer类：全连接层和其他运算\n- lossLayer类：实现各种代价函数\n\n不过目前最新版本的caffe已经取消了visionLayer和commonLayer的分类。此外由于caffe使用了cuDNN运算加速库，因此部分layer有caffe和cuDNN两种实现，使用时可以通过protobuf文件配置需要使用的engine。\n \n为了保持框架的可扩展性，大多数框架在layer或者operator的实现中使用了工厂模式，使用统一的工厂类来对不同的layer或operator进行实例化。下面是caffe使用工厂模式的代码实现，\n\n```c++\n// include/caffe/layer_factory.hpp\ntemplate <typename Dtype>\nclass LayerRegistry {\npublic:\n  typedef shared_ptr<Layer<Dtype> > (*Creator)(const LayerParameter&);\n  typedef std::map<string, Creator> CreatorRegistry;\n  static CreatorRegistry& Registry() {\n    static CreatorRegistry* g_registry_ = new CreatorRegistry();\n    return *g_registry_;\n  }\n\n  // Adds a creator.\n  static void AddCreator(const string& type, Creator creator) {\n    CreatorRegistry& registry = Registry();\n    CHECK_EQ(registry.count(type), 0)\n        << \"Layer type \" << type << \" already registered.\";\n    registry[type] = creator;\n  }\n...\n};\ntemplate <typename Dtype>\nclass LayerRegisterer {\n public:\n  LayerRegisterer(const string& type,\n                  shared_ptr<Layer<Dtype> > (*creator)(const LayerParameter&)) {\n    // LOG(INFO) << \"Registering layer type: \" << type;\n    LayerRegistry<Dtype>::AddCreator(type, creator);\n  }\n};\n\n#define REGISTER_LAYER_CREATOR(type, creator)                                  \\\n  static LayerRegisterer<float> g_creator_f_##type(#type, creator<float>);     \\\n  static LayerRegisterer<double> g_creator_d_##type(#type, creator<double>)    \\\n```\n```c++\n// src/caffe/layer_factory.cpp\ntemplate <typename Dtype>\nshared_ptr<Layer<Dtype> > GetSigmoidLayer(const LayerParameter& param) {\n  SigmoidParameter_Engine engine = param.sigmoid_param().engine();\n  if (engine == SigmoidParameter_Engine_DEFAULT) {\n    engine = SigmoidParameter_Engine_CAFFE;\n#ifdef USE_CUDNN\n    engine = SigmoidParameter_Engine_CUDNN;\n#endif\n  }\n  if (engine == SigmoidParameter_Engine_CAFFE) {\n    return shared_ptr<Layer<Dtype> >(new SigmoidLayer<Dtype>(param));\n#ifdef USE_CUDNN\n  } else if (engine == SigmoidParameter_Engine_CUDNN) {\n    return shared_ptr<Layer<Dtype> >(new CuDNNSigmoidLayer<Dtype>(param));\n#endif\n  } else {\n    LOG(FATAL) << \"Layer \" << param.name() << \" has unknown engine.\";\n  }\n}\n\nREGISTER_LAYER_CREATOR(Sigmoid, GetSigmoidLayer);\n```\n\n##caffe中的Net\nNet是由Layer组成的有向图，表示整个神经网络的拓扑结构，与很多框架中的graph对应，一般用一个protobuf文件来定义。而且Layer作为有向图中的一个组件，是无法感知自己的上层和下层连接的，需要Net将数据feed给Layer，这样数据在有向图中才能真正流动起来。因此Net至少需要提供构建一个有向图和feed数据流两种功能。\n\n- 构建一个有向图：void Init(const NetParameter& in_param)\n- feed数据流： const vector<Blob<Dtype\\>\\*\\>& Forward(Dtype\\* loss)和void Backward()\n\n在构建有向图时，caffe首先会对不符合规则的layer进行过滤，比如对于test net，则会把只用于train的layer过滤掉。对于有向图中可能存在分支的情况，caffe会自动插入split层，将原输入blob复制多份，分别输入不同的分支，比如：LeNet网络中的数据层的label需要输入到accuracy层和loss层，那么需要在数据层再插入一层，如下图所示。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-004.jpg?raw=true width=600></div>\n \nNet会根据网络结构逐层创建layer，并指定输入输出blobs，以及是否需要backward。\n\n```c++\n// src/caffe/net.cpp:Init\n...\nfor (int layer_id = 0; layer_id < param.layer_size(); ++layer_id) {\n    ...\n    layers_.push_back(LayerRegistry<Dtype>::CreateLayer(layer_param));\n    ...\n    for (int bottom_id = 0; bottom_id < layer_param.bottom_size(); ++bottom_id) {\n      const int blob_id = AppendBottom(param, layer_id, bottom_id,\n                                       &available_blobs, &blob_name_to_idx);\n      // If a blob needs backward, this layer should provide it.\n      need_backward |= blob_need_backward_[blob_id];\n    }\n    int num_top = layer_param.top_size();\n    for (int top_id = 0; top_id < num_top; ++top_id) {\n      AppendTop(param, layer_id, top_id, &available_blobs, &blob_name_to_idx);\n      // Collect Input layer tops as Net inputs.\n      if (layer_param.type() == \"Input\") {\n        const int blob_id = blobs_.size() - 1;\n        net_input_blob_indices_.push_back(blob_id);\n        net_input_blobs_.push_back(blobs_[blob_id].get());\n      }\n    }\n    ...\n    layers_[layer_id]->SetUp(bottom_vecs_[layer_id], top_vecs_[layer_id]);\n    ...\n}\n```\n \n在训练时，train net会首先初始化，test net之后初始化，每次test时会调用ShareTrainedLayersWith共享train net的参数，这样做可以节省显存并且避免不必要的数据拷贝。   \n\n需要注意的是，在protobuf文件中声明网络结构时，必须依照从下到上的顺序一层一层定义网络参数，而且test net和train net对应层的name最好一致(虽然不一致可能不会导致程序报错），因为test net与train net是根据匹配name进行参数共享的，如果name不一致则会导致无法进行参数共享，增加显存消耗的同时还会导致test结果不正确。   \n\n当有向图构建完成后，我们只需要调用Forward和Backward，数据就能流经整个网络，得到每层的输出、loss和每个参数的梯度。   \n\n```c++\n// src/caffe/net.cpp\ntemplate <typename Dtype>\nDtype Net<Dtype>::ForwardFromTo(int start, int end) {\n  CHECK_GE(start, 0);\n  CHECK_LT(end, layers_.size());\n  Dtype loss = 0;\n  for (int i = start; i <= end; ++i) {\n    // LOG(ERROR) << \"Forwarding \" << layer_names_[i];\n    Dtype layer_loss = layers_[i]->Forward(bottom_vecs_[i], top_vecs_[i]);\n    loss += layer_loss;\n    if (debug_info_) { ForwardDebugInfo(i); }\n  }\n  return loss;\n}\n\ntemplate <typename Dtype>\nvoid Net<Dtype>::BackwardFromTo(int start, int end) {\n  CHECK_GE(end, 0);\n  CHECK_LT(start, layers_.size());\n  for (int i = start; i >= end; --i) {\n    if (layer_need_backward_[i]) {\n      layers_[i]->Backward(\n          top_vecs_[i], bottom_need_backward_[i], bottom_vecs_[i]);\n      if (debug_info_) { BackwardDebugInfo(i); }\n    } \n  }   \n}\n```\n##caffe中的Solver\n前面讲到Net通过调用Forward和Backward可以得到每个参数的梯度，而Solver的主要作用就是根据这些梯度进行网络参数的更新。由于caffe将Net作为Solver的底层实现，因此Solver也就成了控制整个训练过程的中枢。Solver提供三个主要函数：Init、Solve、ApplyUpdate。\n\n- Init：创建训练网络和测试网络，初始化一些参数\n\n```c++\n// src/caffe/solver.cpp\ntemplate <typename Dtype>\nvoid Solver<Dtype>::Init(const SolverParameter& param) {\n  ...\n  // Scaffolding code\n  InitTrainNet();\n  if (Caffe::root_solver()) {\n    InitTestNets();\n    LOG(INFO) << \"Solver scaffolding done.\";\n  }\n  iter_ = 0;\n  current_step_ = 0;\n}\n```\n\n- Solve：调用Step进行迭代训练，每次迭代后都会调用ApplyUpdate进行参数的更新\n \n```c++\n// src/caffe/solver.cpp\ntemplate <typename Dtype>\nDtype Solver<Dtype>::ForwardBackward() {\n  ...\n  // accumulate the loss and gradient\n  for (int i = 0; i < param_.iter_size(); ++i) {\n    loss += net_->ForwardBackward();\\\n  }\n  return loss / param_.iter_size();\n}\n \ntemplate <typename Dtype>\nvoid Solver<Dtype>::Step(int iters) {\n  ...\n  while (iter_ < stop_iter) {\n    if (param_.test_interval() && iter_ % param_.test_interval() == 0\n        && (iter_ > 0 || param_.test_initialization())\n        && Caffe::root_solver()) {\n      TestAll(); // 进行测试\n    }\n    ...\n    for (int i = 0; i < callbacks_.size(); ++i) {\n      callbacks_[i]->on_start();\n    }\n    ...\n    Dtype loss = ForwardBackward();\n    ...\n    UpdateSmoothedLoss(loss, start_iter, average_loss);\n    ...\n    for (int i = 0; i < callbacks_.size(); ++i) {\n      callbacks_[i]->on_gradients_ready();\n    }\n    if (!param().disabled_update()) {\n      ApplyUpdate();\n    }\n    ++iter_;\n    ...\n}\n \ntemplate <typename Dtype>\nvoid Solver<Dtype>::Solve(const char* resume_file) {\n  ...\n  Step(param_.max_iter() - iter_);\n  ...\n}\n```\n\n- ApplyUpdate：调用对应的solver进行参数更新，下面是sgd solver的ApplyUpdate函数\n \n```c++\n// src/caffe/solvers/sgd_solver.cpp\ntemplate <typename Dtype>\nvoid SGDSolver<Dtype>::ApplyUpdate() {\n  ...\n  Dtype rate = GetLearningRate(); //获取当前迭代的学习率\n  ...\n  ClipGradients(); // 进行梯度规整\n  // learnable_params存放的是网络中所有需要学习的参数blobs\n  for (int param_id = 0; param_id < this->net_->learnable_params().size();\n       ++param_id) {\n    ApplyUpdate(param_id); // 逐个更新参数\n  }\n}\n```\n \n由于梯度下降算法发展出了非常多的优化算法，目前caffe提供了六种优化算法来求解最优参数，在solver配置文件中，通过设置type类型来选择。\n\n- Stochastic Gradient Descent (type: \"SGD\"),\n- AdaDelta (type: \"AdaDelta\"),\n- Adaptive Gradient (type: \"AdaGrad\"),\n- Adam (type: \"Adam\"),\n- Nesterov’s Accelerated Gradient (type: \"Nesterov\")\n- RMSprop (type: \"RMSProp\")\n \n##caffe断点保存和恢复\n由于训练过程往往非常耗时，为了能够在突发情况后快速恢复训练，caffe提供了断点保存和恢复的功能，在solver的配置文件中可以配置保存的频率及保存时文件名的前缀，一个比较完整的solver配置文件如下：\n\n```c++\n// solver.prototxt\nnet: \"./train_val.prototxt\"  // 定义net的protobuf文件\ntest_iter: 100   // 测试的迭代次数，这个需要根据测试数据的大小和测试时的batch size计算得到，test_iter = test_dataset_size / test_batch_size\ntest_interval: 1000  // 设置test的频率，每训练1000次迭代就测试一次\nbase_lr: 0.01  // 设置学习率\nlr_policy: \"step\"  // 设置学习率衰减策略\ngamma: 0.1  // step衰减因子，\nstepsize: 10000 // 衰减的频率，每训练10000次迭代衰减一次，衰减后的学习率=当前学习率*gamma\ndisplay: 500  // 训练log打印频率\nmax_iter: 45000  // 设置最大训练多少次迭代\ntype: \"SGD\"  // 设置solver类型 \nmomentum: 0.9  // 设置SGD中的动量项\nweight_decay: 0.0005  // 设置正则系数\nsnapshot: 1000  // 设置模型保存频率\nsnapshot_prefix: \"../output/caffe_alexnet_train\"  // 设置模型保存时文件名前缀\nsolver_mode: CPU  // 设置训练模式，CPU还是GPU\n```\n\n当然还有一些其他的参数，比如正则化类型和模型保存文件格式等，都会使用在proto文件中定义的默认值，具体查看src/caffe/proto/caffe.proto文件中的SolverParameter。\n\n\n为了实现断点保存和恢复，caffe在Solver中加入了Snapshot和Restore，分别进行模型保存和模型恢复，相应地，在Net中也加入了ToProto/ToHDF5和CopyTrainedLayersFromBinaryProto/CopyTrainedLayersFromHDF5。Solver调用Step进行训练的时候，每次参数更新结束都会判断是否需要保存模型。\n\n```c++\n// src/caffe/solver.cpp:Step\nif ((param_.snapshot()\n     && iter_ % param_.snapshot() == 0\n     && Caffe::root_solver()) ||\n     (request == SolverAction::SNAPSHOT)) {\n  Snapshot();\n}\n```\nSolver中Snapshot对模型参数和训练状态进行保存，模型参数提供两种保存格式——binary protobuf和hdf5。如果是protobuf格式，则会调用Net的ToProto，否则调用ToHDF5。\n\n```c++\n// src/caffe/net.cpp\ntemplate <typename Dtype>\nvoid Net<Dtype>::ToProto(NetParameter* param, bool write_diff) const {\n  param->Clear();\n  param->set_name(name_);\n  // Add bottom and top\n  DLOG(INFO) << \"Serializing \" << layers_.size() << \" layers\";\n  for (int i = 0; i < layers_.size(); ++i) {\n    LayerParameter* layer_param = param->add_layer();\n    layers_[i]->ToProto(layer_param, write_diff);\n  }\n}\n```\n\nSolver在开始训练时会尝试调用Restore进行断点恢复，根据文件名后缀判断文件格式，并选择RestoreSolverStateFromHDF5还是RestoreSolverStateFromBinaryProto。\n\n```c++\n// src/caffe/solver.cpp:Solve\nif (resume_file) {\n  LOG(INFO) << \"Restoring previous solver status from \" << resume_file;\n  Restore(resume_file);\n}\n```\n##in-place计算\n为了节约显存，caffe支持原址计算，就是输入与输出都是同一个blob。如果前一层的输出和本层的输入都与后向计算时无关，而且本层的输入和输出blob大小相同，就可以使用in-place计算，比如卷积层后面的Sigmoid、Relu等都可以用同址计算，而BatchNorm层也支持in-place计算，是因为BatchNorm在实现时会将输入数据进行备份。使用同址计算只要在protobuf文件中指定该层的top和bottom是同名的就可以了，比如：\n\n```c++\nlayer {\n        bottom: \"conv1\"\n        top: \"conv1\"\n        name: \"conv1_relu\"\n        type: \"ReLU\"\n}\n```\n\n##参数初始化方法\n由于神经网络的目标函数往往是非凸的，参数初始化会对最终的收敛结果造成非常大的影响。为了满足不同的参数初始化需求，caffe提供了多种初始化方法，并且在net的配置文件中可以为每个参数选择一个初始化方法。比如下面的weight_filler和bias_filler：\n\n```c++\nlayer {\n        bottom: \"data\"\n        top: \"conv1\"\n        name: \"conv1\"\n        type: \"Convolution\"\n        convolution_param {\n                num_output: 64\n                kernel_size: 7\n                pad: 3\n                stride: 2\n                weight_filler {\n                  type: \"xavier\"\n                }\n                bias_filler {\n                  type: \"constant\"\n                  value: 0.2\n               }\n        }\n}\n```\n\n在include/caffe/filler.hpp中caffe提供如下的初始化方法：\n\n- constant：常量初始化，参数所有的值都被初始化为相同的值\n- uniform：均匀初始化，参数的值按照指定区间均匀分布随机初始化\n- gaussian：高斯初始化，参数的值按照指定均值和方差的正态分布随机初始化\n- positive unitball\n- xavier：本质上也是一种指定区间均匀分布的随机初始化方式，只是区间是通过参数大小计算得到\n- msra：与xavier类似，不过使用的是指定均值和方差的正态分布随机初始化方式\n- bilinear\n \n##多卡并行策略\n为了提高效率，caffe支持单机多GPU并行训练，目前采用的是数据并行方式，暂不支持模型并行，为此caffe增加了一个P2PSync类，下面主要介绍一下P2PSync如何实现多卡并行的。\n\nP2PSync封装了一个Solver负责训练，每张GPU都会对应一个P2PSync，并且P2PSync之间具有主从关系，它们之间构成一个二叉树的结构。在前向计算时，主P2PSync需要将模型分发给从P2PSync，而在后向传导时，从P2PSync就需要把梯度传给主P2PSync，主P2PSync会在聚合从P2PSync的梯度后传给更上一层的主P2PSync。在二叉树结构中，根节点P2PSync的Solver被叫做root solver，其他solver叫做worker solver，只有root solver才能进行参数更新，worker solver只是将梯度聚合并传递给root solver。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-005.jpg?raw=true width=720></div>\n\n在P2PSync中主要的函数就InternalThreadEntry、on_start和on_gradients_ready。\n \n```c++\n// src/caffe/parallel.cpp\ntemplate<typename Dtype>\nvoid P2PSync<Dtype>::InternalThreadEntry() {\n...\n solver_->Step(solver_->param().max_iter() - initial_iter_);\n }\n\n```\n\nInternalThreadEntry是一个线程函数，Solver调用Step进行训练，在Step中每次前向计算前都会回调on_start获取最新模型，而在后向计算结束后又会回调on_gradients_ready传递梯度。\n \n```c++\n// src/caffe/solver.cpp\ntemplate <typename Dtype>\nvoid Solver<Dtype>::Step(int iters) {\n ...\n while (iter_ < stop_iter) {\n for (int i = 0; i < callbacks_.size(); ++i) {\n callbacks_[i]->on_start(); // 回调P2PSync中的on_start，从主P2PSync获取新模型\n }\n ...\n Dtype loss = Forward_backward();\n ...\n for (int i = 0; i < callbacks_.size(); ++i) {\n callbacks_[i]->on_gradients_ready(); // 回调P2PSync中的on_gradients_ready，依次聚合从P2PSync和自身的梯度，并将梯度发送给主P2PSync\n }\n if (!param().disabled_update()) {\n ApplyUpdate(); // 这里只有root solver才会进行参数更新\n }\n ...\n\n }\n}\n```\n \n```c++\ntemplate<typename Dtype>\nvoid P2PSync<Dtype>::on_start() {\n#ifndef CPU_ONLY\n ...\n // Wait for update from parent\n if (parent_) {\n   /* 除了root solver，其他worker solver都有对应的parent\n      程序执行到这里时会阻塞，当主P2PSync将自身入队后就会通知从P2PSync，pop就能返回\n   */\n   P2PSync<Dtype> *parent = queue_.pop(); // 等待主P2PSync入队\n   CHECK(parent == parent_);\n }\n // Update children\n for (int i = children_.size() - 1; i >= 0; i--) {\n   Dtype* src = data_;\n   Dtype* dst = children_[i]->data_;\n   ...\n   // 主P2PSync将模型直接拷贝给从P2PSync\n   CUDA_CHECK(cudaMemcpyAsync(dst, src, size_ * sizeof(Dtype),\n   cudaMemcpyDeviceToDevice, cudaStreamDefault));\n   CUDA_CHECK(cudaStreamSynchronize(cudaStreamDefault));\n   // 主P2PSync将自身入队，并通知从P2PSync\n   children_[i]->queue_.push(this);\n }\n #endif\n }\n```\n \n```c++\ntemplate<typename Dtype>\nvoid P2PSync<Dtype>::on_gradients_ready() {\n#ifndef CPU_ONLY\n  ...\n  // Sum children gradients as they appear in the queue\n  for (int i = 0; i < children_.size(); ++i) {\n    P2PSync<Dtype> *child = queue_.pop(); // 等待从P2PSync入队\n    // 由于parent_grads_是在主P2PSync设备上开辟的一块缓冲区，因此child->parent_grads_其实就是当前设备上的缓冲区\n    Dtype* src = child->parent_grads_; // 获取从P2PSync的梯度\n    Dtype* dst = diff_;\n    // 合并从P2PSync的梯度\n    caffe_gpu_add(size_, src, dst, dst);\n  }\n  ...\n  // Send gradients to parent\n  if (parent_) {\n    Dtype* src = diff_;\n    Dtype* dst = parent_grads_; \n    // 从P2PSync将梯度复制到主P2PSync的缓冲区\n    CUDA_CHECK(cudaMemcpyAsync(dst, src, size_ * sizeof(Dtype),  //\n        cudaMemcpyDeviceToDevice, cudaStreamDefault));\n    CUDA_CHECK(cudaStreamSynchronize(cudaStreamDefault));\n    // 自身入队，通知主P2PSync\n    parent_->queue_.push(this);\n  } else {\n    // Loss functions divide gradients by the batch size, so to compensate\n    // for split batch, the root solver divides by number of solvers.\n    caffe_gpu_scal(size_, Dtype(1.0 / Caffe::solver_count()), diff_);\n  }\n#endif\n```\n \n##intel caffe多机并行策略\n单机多卡的训练方式已经足够解决目前大部分模型训练的需求了，但随着数据量越来越大、模型越来越复杂，分布式异构计算成为行业通行的解决方案。BVLC caffe是不支持分布式训练的，intel有两个部门将caffe进行了再次开发以支持分布式和最新的Intel MKL-DNN，分别为intel caffe和caffe multinode。目前BML API已经支持intel caffe的模型训练、评估和预测了。   \n\nintel caffe采用的是数据并行的方式，但不同于目前主流的centralized parameter server通信模型，intel caffe借鉴了单机多卡的策略，采用的是一种all-reduce的binary tree模型，也就是将节点按照二叉树组织起来，每个父节点负责1-2个子节点和自己父节点的通信，相比一个中心的PS需要同时与其他多个节点通信的方式，这种binary tree方式将一部分PS的计算平均到了每个节点上，而且相同level的父节点之间可以并行，增加了梯度合并的并行度。   \n\n[待图]\n \n为了更好地掩盖通信开销，子节点不需要等到整个模型的梯度都计算完才发送，而是每个layer计算完梯度后就会立即发送给父节点，父节点收到所有子节点的梯度后将本层的梯度合并后也可以立即发送给上一层的父节点。每个layer的参数会按照buffer的大小分成多个part，每个part都会异步地进行发送，当进行下一次迭代时，除了根节点的所有节点都会被阻塞，等待根节点将最终的梯度进行合并，并更新模型后发送给子节点。   \n\n除了分层通信外，intel caffe也支持梯度量化压缩，可以将全精浮点数编码成指定字节数的数值，减少节点间通信量。   \n\nintel caffe为了支持多种协议的通信，使用了boost的asio::io_service接口，底层实现支持MPI、TCP和UDP，不过目前只实现了MPI接口。 \n  \n训练时交叉验证是在单节点(准确来说是根节点)上进行的，但每个节点上都需要存在验证集文件，这是因为即使不进行test，其他节点也会初始化test网络。   \n\n##实战\n \n##参考\n贾扬清自述http://www.yangfenzi.com/keji/59535.html   \ncaffe官网http://caffe.berkeleyvision.org   \nhttp://ucb-icsi-vision-group.github.io/caffe-paper/caffe.pdf   \nhttps://www.zhihu.com/question/27982282   \nhttp://blog.csdn.net/myarrow/article/details/52064608   \n \n","source":"_posts/caffe学习.md","raw":"---\ntitle: caffe学习总结\ndate: 2017-01-19 12:31:08\ncategory: ML framework\ntags: [caffe, deep learning, framework]\n---\n\n#caffe学习总结\n\n##caffe的由来\ncaffe是贾扬清在UC Berkeley攻读计算机科学博士学位时开发的一套深度学习框架，由于高效、易读和模块化的设计，开源后经过nvidia的帮助优化和社区不断的完善，如今成为视觉领域主流的框架之一。\n\n<!-- more -->\n\n- 贾扬清其人   \n  清华大学的本硕，UC Berkeley的计算机科学博士，师承Prof. Trevor Darrell，期间在新加坡国立大学、微软亚洲研究院、NEC美国实验室和google研究院实习和工作。博士毕业后一直在google brain担任研究科学家，致力于机器视觉、深度学习和tensorflow相关工作。2016年2月加入facebook，主导facebook大多数AI应用的通用、大规模机器学习平台（目前以caffe2为基础的caffe2go已经开源）。\n  \n- 为什么要开发caffe   \n  贾最早开发的是另一款软件Decaf，主要功能是基于cuda-convnet进行CNN训练。2013年贾扬清读博期间跟心理学老师合作研究使用概率框架来表达人的行为，\"但是因为图像上提取的特征比较弱，所以可以外推的结果比较有限\"，而2012年Alex Krizhevsky提出的AlexNet在ImageNet比赛中大获成功，贾因此也希望将CNN应用到他们的心理学研究上，于是就开始写了Decaf，通过Decaf验证了\"深度学习特征的优异的可移植性\"，因此就开始开发一套通用的深度学习框架，即后来的caffe。\n\n##caffe与其他一些主流框架的比较\ncaffe同期也存在其他一些开源框架，比如cuda-convnet、theano、torch等，并且后来又陆续开源了neon、mxnet、tensorflow、CNTK以及paddled等等。现在对于研究者，如何选择一个框架也成了一个麻烦的问题了。下图是2014年贾扬清在caffe论文中对当时的一些框架做的一个比较：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-001.png?raw=true width=800></div>\n\n下面是近年主流框架的一个简单比较：\n\n- 特性\n\n| | 主语言 | 从语言 | 硬件 | 分布式 | 命令式 | 声明式 | 自动梯度 |\n| ------------- |:-------------:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n| caffe | C++ | Python/Matlab | CPU/GPU | ✖ | ✖ | ✔ | ✖ | \n| mxnet | C++ | Python/R/Julia/Scala | CPU/GPU/Mobile | ✔ | ✔ | ✔ | ✔ |\n| tensorflow | C++ | Python | CPU/GPU/Mobile | ✔ | ✖ | ✔ | ✔ |\n| Torch | Lua | - | CPU/GPU/FPGA | ✔ | ✔ | ✖ | ✔ |\n| theano | Python | - | CPU/GPU | ✖ | ✖ | ✔ | ✔ |\n\n- 效率\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-002.png?raw=true width=420></div>\n\n##caffe代码组织结构\ncaffe代码结构是非常清晰的，主要包含以下文件和目录：\n\n- Makefile和Makefile.config\ncaffe支持cmake和make两种编译方式，不过大部分人只需要用make编译就可以了。Makefile.config可以对一些编译选项进行配置，比如USE_MPI、CPU_ONLY、DEBUG等等。\n- include\n在caffe中除了proto文件生成的头文件外，所有的c++头文件都放在include目录中。\n- src\nsrc与include的目录结构基本上相同，include目录中的文件基本上都能在src目录中找到对应的实现文件。\n- tools\ntools目录下是caffe提供给用户直接使用的接口，比如caffe.cpp用于模型训练、评估以及统计耗时，另外也提供一些数据集转换、计算均值等工具\n- examples\n提供一些训练相关的脚本和网络配置，比如数据预处理脚本、不同的网络配置文件以及训练脚本\n- models\n提供一些模型的网络配置文件，以及训练好的模型，用户可以直接用训练好的模型进行fine-tune或者分类\n- matlab/python\n提供matlab和python的接口\n\n##caffe网络的组织方式\n从LeNet开始，CNN就开始有了一个标准的分层结构——堆叠卷积层，卷积层可能后接一些normalization和pooling层，网络最后接一个或多个全连接层。由于梯度下降算法非常适合逐层计算，因此当时很多的通用框架都将网络（Net）抽象为多个数据处理层（Layer）组成的有向图，并支持灵活地定义网络结构。caffe将神经网络的训练问题分解为四个方面：数据、计算、流动控制以及问题求解，分别对应caffe中的Blob、Layer、Net和Solver。网络中流动的数据以及参数都用Blob来表示，Layer负责前向输出和后向梯度的计算，Net负责控制Layer计算的顺序，Solver是一个求解器的角色，根据Net的梯度对网络参数进行更新。\n\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-003.png?raw=true width=800>\n\n[待补充]\n\n##caffe中的Blob及同步策略\nBlob是caffe中存储数据的基本结构，可以简单理解为一个4维的数组，数据组织格式为（N,C,H,W）。在caffe中上下层流动的数据和每层的权重参数都是用Blob来保存的，为了便于使用，Blob具有一些特性：\n\n- Blob的内存是懒分配的（lazily allocate），只有在真正使用的时候才会分配内存\n- Blob会在CPU和GPU上各自分配一块相同大小的内存，便于在CPU和GPU之间进行切换\n- 用户不需要关心CPU和GPU数据的同步，Blob会根据需要自动同步\n\n下面是Blob的成员变量，data_是Blob存储的数据，diff_保存的是数据的梯度，shape_data_和shape_保存的都是当前数组的形状，count_是当前数据的大小，capacity_是申请的内存的大小，避免每次Reshape都要释放并重新申请内存。\n\n```c++\n  // include/caffe/blob.hpp\n  shared_ptr<SyncedMemory> data_;\n  shared_ptr<SyncedMemory> diff_;\n  shared_ptr<SyncedMemory> shape_data_;\n  vector<int> shape_;\n  int count_;\n  int capacity_;\n```\n\n下面主要说一下Blob的自动同步策略。首先看一下SyncedMemory的成员变量：\n\n```c++\n  // include/caffe/syncedmem.hpp\n  void* cpu_ptr_; // CPU内存数据\n  void* gpu_ptr_; // GPU显存数据\n  size_t size_;   // 数据大小\n  SyncedHead head_;  // 同步标志\n  bool own_cpu_data_; \n  bool cpu_malloc_use_cuda_;\n  bool own_gpu_data_;\n  int gpu_device_; // GPU设备号\n```\n\nhead_的取值范围为UNINITIALIZED, HEAD_AT_CPU, HEAD_AT_GPU, SYNCED。初始化时head_值为UNINITIALIZED，当调用Blob的取值函数时都会调用一次SyncedMemory的to_cpu或者to_gpu进行数据的同步，同步策略为：   \n1、取cpu数据时，会调用to_cpu函数，如果heda_为HEAD_AT_GPU，则需要将GPU的数据同步至CPU，否则不需要同步   \n2、取gpu数据时，会调用to_gpu函数，如果heda_为HEAD_AT_CPU，则需要将CPU的数据同步至GPU，否则不需要同步\n\nhead_标志的赋值：   \n1、每次调用SyncedMemory的mutable_cpu_data时，head_都会被置为HEAD_AT_CPU   \n2、每次调用SyncedMemory的mutable_gpu_data时，head_都会被置为HEAD_AT_GPU   \n3、每次同步之后heda_会被置为SYNCED。\n\n因此Blob通过判断每次修改的位置来自行决定是否需要对不同设备间的两份数据进行同步，使用时就像只有一份数据一样，非常方便。\n\n##caffe中的Layer\nlayer是caffe模型的主要组成部分和基本的计算单元，与很多框架中的operator对应，一个典型的layer在forward时从下层连接获取输入，经过计算后输出到上层，backward时又从上层连接获取误差，计算本层梯度和误差后，将误差传递到下层连接。因此基类Layer实现了三个基本函数setup、forward和backward。\n\n- setup：根据下层连接和配置参数完成本层参数的初始化，以及输出blobs的初始化\n- forward：前向计算过程，并计算本层的loss\n- backward：后向计算过程，并将本层误差传递到下层\n\nforward和backward里面都会对CPU和GPU进行分支，如果是CPU模式，则真正参与计算的是forward_cpu和backward_cpu，如果是GPU模式，则参与计算的是forward_gpu和backward_gpu，并且在基类中forward_gpu和backward_gpu分别调用的是forward_cpu和backward_cpu，当然用户在定义新的layer时可以自行实现forward_gpu和backward_gpu。\n \n基类Layer的成员变量：\n\n```c++\n  // include/caffe/layer.hpp\n  /** The protobuf that stores the layer parameters */\n  LayerParameter layer_param_;\n  /** The phase: TRAIN or TEST */\n  Phase phase_;\n  /** The vector that stores the learnable parameters as a set of blobs. */\n  vector<shared_ptr<Blob<Dtype> > > blobs_;\n  /** Vector indicating whether to compute the diff of each param blob. */\n  vector<bool> param_propagate_down_;\n  /** The vector that indicates whether each top blob has a non-zero weight in\n   *  the objective function. */\n  vector<Dtype> loss_;\n```\n\nlayer_param_是从protobuf文件中反序列化得到的，存放的是layer的配置参数\nphase_指示是训练还是测试\nblobs_是本层的参数，比如权重和偏置\nparam_propagate_down_为每一个参数设定是否需要计算梯度\nloss_是本层的损失值，loss层每个输出blob都有一个损失值，非loss层损失为0\n \n由基类Layer直接或间接派生出各种layer，比如卷积(convolution)、全连接(fully connected或者inner product)、dropout、pooling、relu、softmaxWithLoss等等，每一个派生layer都会强制实现forward_cpu和backward_cpu。早期的caffe将layer分成5类，\n\n- dataLayer类： 各类数据读取的接口\n- neuronLayer类： 各种激活函数、dropout\n- visionLayer类： 卷积层、采样层等2D图像相关的运算\n- commonLayer类：全连接层和其他运算\n- lossLayer类：实现各种代价函数\n\n不过目前最新版本的caffe已经取消了visionLayer和commonLayer的分类。此外由于caffe使用了cuDNN运算加速库，因此部分layer有caffe和cuDNN两种实现，使用时可以通过protobuf文件配置需要使用的engine。\n \n为了保持框架的可扩展性，大多数框架在layer或者operator的实现中使用了工厂模式，使用统一的工厂类来对不同的layer或operator进行实例化。下面是caffe使用工厂模式的代码实现，\n\n```c++\n// include/caffe/layer_factory.hpp\ntemplate <typename Dtype>\nclass LayerRegistry {\npublic:\n  typedef shared_ptr<Layer<Dtype> > (*Creator)(const LayerParameter&);\n  typedef std::map<string, Creator> CreatorRegistry;\n  static CreatorRegistry& Registry() {\n    static CreatorRegistry* g_registry_ = new CreatorRegistry();\n    return *g_registry_;\n  }\n\n  // Adds a creator.\n  static void AddCreator(const string& type, Creator creator) {\n    CreatorRegistry& registry = Registry();\n    CHECK_EQ(registry.count(type), 0)\n        << \"Layer type \" << type << \" already registered.\";\n    registry[type] = creator;\n  }\n...\n};\ntemplate <typename Dtype>\nclass LayerRegisterer {\n public:\n  LayerRegisterer(const string& type,\n                  shared_ptr<Layer<Dtype> > (*creator)(const LayerParameter&)) {\n    // LOG(INFO) << \"Registering layer type: \" << type;\n    LayerRegistry<Dtype>::AddCreator(type, creator);\n  }\n};\n\n#define REGISTER_LAYER_CREATOR(type, creator)                                  \\\n  static LayerRegisterer<float> g_creator_f_##type(#type, creator<float>);     \\\n  static LayerRegisterer<double> g_creator_d_##type(#type, creator<double>)    \\\n```\n```c++\n// src/caffe/layer_factory.cpp\ntemplate <typename Dtype>\nshared_ptr<Layer<Dtype> > GetSigmoidLayer(const LayerParameter& param) {\n  SigmoidParameter_Engine engine = param.sigmoid_param().engine();\n  if (engine == SigmoidParameter_Engine_DEFAULT) {\n    engine = SigmoidParameter_Engine_CAFFE;\n#ifdef USE_CUDNN\n    engine = SigmoidParameter_Engine_CUDNN;\n#endif\n  }\n  if (engine == SigmoidParameter_Engine_CAFFE) {\n    return shared_ptr<Layer<Dtype> >(new SigmoidLayer<Dtype>(param));\n#ifdef USE_CUDNN\n  } else if (engine == SigmoidParameter_Engine_CUDNN) {\n    return shared_ptr<Layer<Dtype> >(new CuDNNSigmoidLayer<Dtype>(param));\n#endif\n  } else {\n    LOG(FATAL) << \"Layer \" << param.name() << \" has unknown engine.\";\n  }\n}\n\nREGISTER_LAYER_CREATOR(Sigmoid, GetSigmoidLayer);\n```\n\n##caffe中的Net\nNet是由Layer组成的有向图，表示整个神经网络的拓扑结构，与很多框架中的graph对应，一般用一个protobuf文件来定义。而且Layer作为有向图中的一个组件，是无法感知自己的上层和下层连接的，需要Net将数据feed给Layer，这样数据在有向图中才能真正流动起来。因此Net至少需要提供构建一个有向图和feed数据流两种功能。\n\n- 构建一个有向图：void Init(const NetParameter& in_param)\n- feed数据流： const vector<Blob<Dtype\\>\\*\\>& Forward(Dtype\\* loss)和void Backward()\n\n在构建有向图时，caffe首先会对不符合规则的layer进行过滤，比如对于test net，则会把只用于train的layer过滤掉。对于有向图中可能存在分支的情况，caffe会自动插入split层，将原输入blob复制多份，分别输入不同的分支，比如：LeNet网络中的数据层的label需要输入到accuracy层和loss层，那么需要在数据层再插入一层，如下图所示。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-004.jpg?raw=true width=600></div>\n \nNet会根据网络结构逐层创建layer，并指定输入输出blobs，以及是否需要backward。\n\n```c++\n// src/caffe/net.cpp:Init\n...\nfor (int layer_id = 0; layer_id < param.layer_size(); ++layer_id) {\n    ...\n    layers_.push_back(LayerRegistry<Dtype>::CreateLayer(layer_param));\n    ...\n    for (int bottom_id = 0; bottom_id < layer_param.bottom_size(); ++bottom_id) {\n      const int blob_id = AppendBottom(param, layer_id, bottom_id,\n                                       &available_blobs, &blob_name_to_idx);\n      // If a blob needs backward, this layer should provide it.\n      need_backward |= blob_need_backward_[blob_id];\n    }\n    int num_top = layer_param.top_size();\n    for (int top_id = 0; top_id < num_top; ++top_id) {\n      AppendTop(param, layer_id, top_id, &available_blobs, &blob_name_to_idx);\n      // Collect Input layer tops as Net inputs.\n      if (layer_param.type() == \"Input\") {\n        const int blob_id = blobs_.size() - 1;\n        net_input_blob_indices_.push_back(blob_id);\n        net_input_blobs_.push_back(blobs_[blob_id].get());\n      }\n    }\n    ...\n    layers_[layer_id]->SetUp(bottom_vecs_[layer_id], top_vecs_[layer_id]);\n    ...\n}\n```\n \n在训练时，train net会首先初始化，test net之后初始化，每次test时会调用ShareTrainedLayersWith共享train net的参数，这样做可以节省显存并且避免不必要的数据拷贝。   \n\n需要注意的是，在protobuf文件中声明网络结构时，必须依照从下到上的顺序一层一层定义网络参数，而且test net和train net对应层的name最好一致(虽然不一致可能不会导致程序报错），因为test net与train net是根据匹配name进行参数共享的，如果name不一致则会导致无法进行参数共享，增加显存消耗的同时还会导致test结果不正确。   \n\n当有向图构建完成后，我们只需要调用Forward和Backward，数据就能流经整个网络，得到每层的输出、loss和每个参数的梯度。   \n\n```c++\n// src/caffe/net.cpp\ntemplate <typename Dtype>\nDtype Net<Dtype>::ForwardFromTo(int start, int end) {\n  CHECK_GE(start, 0);\n  CHECK_LT(end, layers_.size());\n  Dtype loss = 0;\n  for (int i = start; i <= end; ++i) {\n    // LOG(ERROR) << \"Forwarding \" << layer_names_[i];\n    Dtype layer_loss = layers_[i]->Forward(bottom_vecs_[i], top_vecs_[i]);\n    loss += layer_loss;\n    if (debug_info_) { ForwardDebugInfo(i); }\n  }\n  return loss;\n}\n\ntemplate <typename Dtype>\nvoid Net<Dtype>::BackwardFromTo(int start, int end) {\n  CHECK_GE(end, 0);\n  CHECK_LT(start, layers_.size());\n  for (int i = start; i >= end; --i) {\n    if (layer_need_backward_[i]) {\n      layers_[i]->Backward(\n          top_vecs_[i], bottom_need_backward_[i], bottom_vecs_[i]);\n      if (debug_info_) { BackwardDebugInfo(i); }\n    } \n  }   \n}\n```\n##caffe中的Solver\n前面讲到Net通过调用Forward和Backward可以得到每个参数的梯度，而Solver的主要作用就是根据这些梯度进行网络参数的更新。由于caffe将Net作为Solver的底层实现，因此Solver也就成了控制整个训练过程的中枢。Solver提供三个主要函数：Init、Solve、ApplyUpdate。\n\n- Init：创建训练网络和测试网络，初始化一些参数\n\n```c++\n// src/caffe/solver.cpp\ntemplate <typename Dtype>\nvoid Solver<Dtype>::Init(const SolverParameter& param) {\n  ...\n  // Scaffolding code\n  InitTrainNet();\n  if (Caffe::root_solver()) {\n    InitTestNets();\n    LOG(INFO) << \"Solver scaffolding done.\";\n  }\n  iter_ = 0;\n  current_step_ = 0;\n}\n```\n\n- Solve：调用Step进行迭代训练，每次迭代后都会调用ApplyUpdate进行参数的更新\n \n```c++\n// src/caffe/solver.cpp\ntemplate <typename Dtype>\nDtype Solver<Dtype>::ForwardBackward() {\n  ...\n  // accumulate the loss and gradient\n  for (int i = 0; i < param_.iter_size(); ++i) {\n    loss += net_->ForwardBackward();\\\n  }\n  return loss / param_.iter_size();\n}\n \ntemplate <typename Dtype>\nvoid Solver<Dtype>::Step(int iters) {\n  ...\n  while (iter_ < stop_iter) {\n    if (param_.test_interval() && iter_ % param_.test_interval() == 0\n        && (iter_ > 0 || param_.test_initialization())\n        && Caffe::root_solver()) {\n      TestAll(); // 进行测试\n    }\n    ...\n    for (int i = 0; i < callbacks_.size(); ++i) {\n      callbacks_[i]->on_start();\n    }\n    ...\n    Dtype loss = ForwardBackward();\n    ...\n    UpdateSmoothedLoss(loss, start_iter, average_loss);\n    ...\n    for (int i = 0; i < callbacks_.size(); ++i) {\n      callbacks_[i]->on_gradients_ready();\n    }\n    if (!param().disabled_update()) {\n      ApplyUpdate();\n    }\n    ++iter_;\n    ...\n}\n \ntemplate <typename Dtype>\nvoid Solver<Dtype>::Solve(const char* resume_file) {\n  ...\n  Step(param_.max_iter() - iter_);\n  ...\n}\n```\n\n- ApplyUpdate：调用对应的solver进行参数更新，下面是sgd solver的ApplyUpdate函数\n \n```c++\n// src/caffe/solvers/sgd_solver.cpp\ntemplate <typename Dtype>\nvoid SGDSolver<Dtype>::ApplyUpdate() {\n  ...\n  Dtype rate = GetLearningRate(); //获取当前迭代的学习率\n  ...\n  ClipGradients(); // 进行梯度规整\n  // learnable_params存放的是网络中所有需要学习的参数blobs\n  for (int param_id = 0; param_id < this->net_->learnable_params().size();\n       ++param_id) {\n    ApplyUpdate(param_id); // 逐个更新参数\n  }\n}\n```\n \n由于梯度下降算法发展出了非常多的优化算法，目前caffe提供了六种优化算法来求解最优参数，在solver配置文件中，通过设置type类型来选择。\n\n- Stochastic Gradient Descent (type: \"SGD\"),\n- AdaDelta (type: \"AdaDelta\"),\n- Adaptive Gradient (type: \"AdaGrad\"),\n- Adam (type: \"Adam\"),\n- Nesterov’s Accelerated Gradient (type: \"Nesterov\")\n- RMSprop (type: \"RMSProp\")\n \n##caffe断点保存和恢复\n由于训练过程往往非常耗时，为了能够在突发情况后快速恢复训练，caffe提供了断点保存和恢复的功能，在solver的配置文件中可以配置保存的频率及保存时文件名的前缀，一个比较完整的solver配置文件如下：\n\n```c++\n// solver.prototxt\nnet: \"./train_val.prototxt\"  // 定义net的protobuf文件\ntest_iter: 100   // 测试的迭代次数，这个需要根据测试数据的大小和测试时的batch size计算得到，test_iter = test_dataset_size / test_batch_size\ntest_interval: 1000  // 设置test的频率，每训练1000次迭代就测试一次\nbase_lr: 0.01  // 设置学习率\nlr_policy: \"step\"  // 设置学习率衰减策略\ngamma: 0.1  // step衰减因子，\nstepsize: 10000 // 衰减的频率，每训练10000次迭代衰减一次，衰减后的学习率=当前学习率*gamma\ndisplay: 500  // 训练log打印频率\nmax_iter: 45000  // 设置最大训练多少次迭代\ntype: \"SGD\"  // 设置solver类型 \nmomentum: 0.9  // 设置SGD中的动量项\nweight_decay: 0.0005  // 设置正则系数\nsnapshot: 1000  // 设置模型保存频率\nsnapshot_prefix: \"../output/caffe_alexnet_train\"  // 设置模型保存时文件名前缀\nsolver_mode: CPU  // 设置训练模式，CPU还是GPU\n```\n\n当然还有一些其他的参数，比如正则化类型和模型保存文件格式等，都会使用在proto文件中定义的默认值，具体查看src/caffe/proto/caffe.proto文件中的SolverParameter。\n\n\n为了实现断点保存和恢复，caffe在Solver中加入了Snapshot和Restore，分别进行模型保存和模型恢复，相应地，在Net中也加入了ToProto/ToHDF5和CopyTrainedLayersFromBinaryProto/CopyTrainedLayersFromHDF5。Solver调用Step进行训练的时候，每次参数更新结束都会判断是否需要保存模型。\n\n```c++\n// src/caffe/solver.cpp:Step\nif ((param_.snapshot()\n     && iter_ % param_.snapshot() == 0\n     && Caffe::root_solver()) ||\n     (request == SolverAction::SNAPSHOT)) {\n  Snapshot();\n}\n```\nSolver中Snapshot对模型参数和训练状态进行保存，模型参数提供两种保存格式——binary protobuf和hdf5。如果是protobuf格式，则会调用Net的ToProto，否则调用ToHDF5。\n\n```c++\n// src/caffe/net.cpp\ntemplate <typename Dtype>\nvoid Net<Dtype>::ToProto(NetParameter* param, bool write_diff) const {\n  param->Clear();\n  param->set_name(name_);\n  // Add bottom and top\n  DLOG(INFO) << \"Serializing \" << layers_.size() << \" layers\";\n  for (int i = 0; i < layers_.size(); ++i) {\n    LayerParameter* layer_param = param->add_layer();\n    layers_[i]->ToProto(layer_param, write_diff);\n  }\n}\n```\n\nSolver在开始训练时会尝试调用Restore进行断点恢复，根据文件名后缀判断文件格式，并选择RestoreSolverStateFromHDF5还是RestoreSolverStateFromBinaryProto。\n\n```c++\n// src/caffe/solver.cpp:Solve\nif (resume_file) {\n  LOG(INFO) << \"Restoring previous solver status from \" << resume_file;\n  Restore(resume_file);\n}\n```\n##in-place计算\n为了节约显存，caffe支持原址计算，就是输入与输出都是同一个blob。如果前一层的输出和本层的输入都与后向计算时无关，而且本层的输入和输出blob大小相同，就可以使用in-place计算，比如卷积层后面的Sigmoid、Relu等都可以用同址计算，而BatchNorm层也支持in-place计算，是因为BatchNorm在实现时会将输入数据进行备份。使用同址计算只要在protobuf文件中指定该层的top和bottom是同名的就可以了，比如：\n\n```c++\nlayer {\n        bottom: \"conv1\"\n        top: \"conv1\"\n        name: \"conv1_relu\"\n        type: \"ReLU\"\n}\n```\n\n##参数初始化方法\n由于神经网络的目标函数往往是非凸的，参数初始化会对最终的收敛结果造成非常大的影响。为了满足不同的参数初始化需求，caffe提供了多种初始化方法，并且在net的配置文件中可以为每个参数选择一个初始化方法。比如下面的weight_filler和bias_filler：\n\n```c++\nlayer {\n        bottom: \"data\"\n        top: \"conv1\"\n        name: \"conv1\"\n        type: \"Convolution\"\n        convolution_param {\n                num_output: 64\n                kernel_size: 7\n                pad: 3\n                stride: 2\n                weight_filler {\n                  type: \"xavier\"\n                }\n                bias_filler {\n                  type: \"constant\"\n                  value: 0.2\n               }\n        }\n}\n```\n\n在include/caffe/filler.hpp中caffe提供如下的初始化方法：\n\n- constant：常量初始化，参数所有的值都被初始化为相同的值\n- uniform：均匀初始化，参数的值按照指定区间均匀分布随机初始化\n- gaussian：高斯初始化，参数的值按照指定均值和方差的正态分布随机初始化\n- positive unitball\n- xavier：本质上也是一种指定区间均匀分布的随机初始化方式，只是区间是通过参数大小计算得到\n- msra：与xavier类似，不过使用的是指定均值和方差的正态分布随机初始化方式\n- bilinear\n \n##多卡并行策略\n为了提高效率，caffe支持单机多GPU并行训练，目前采用的是数据并行方式，暂不支持模型并行，为此caffe增加了一个P2PSync类，下面主要介绍一下P2PSync如何实现多卡并行的。\n\nP2PSync封装了一个Solver负责训练，每张GPU都会对应一个P2PSync，并且P2PSync之间具有主从关系，它们之间构成一个二叉树的结构。在前向计算时，主P2PSync需要将模型分发给从P2PSync，而在后向传导时，从P2PSync就需要把梯度传给主P2PSync，主P2PSync会在聚合从P2PSync的梯度后传给更上一层的主P2PSync。在二叉树结构中，根节点P2PSync的Solver被叫做root solver，其他solver叫做worker solver，只有root solver才能进行参数更新，worker solver只是将梯度聚合并传递给root solver。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-005.jpg?raw=true width=720></div>\n\n在P2PSync中主要的函数就InternalThreadEntry、on_start和on_gradients_ready。\n \n```c++\n// src/caffe/parallel.cpp\ntemplate<typename Dtype>\nvoid P2PSync<Dtype>::InternalThreadEntry() {\n...\n solver_->Step(solver_->param().max_iter() - initial_iter_);\n }\n\n```\n\nInternalThreadEntry是一个线程函数，Solver调用Step进行训练，在Step中每次前向计算前都会回调on_start获取最新模型，而在后向计算结束后又会回调on_gradients_ready传递梯度。\n \n```c++\n// src/caffe/solver.cpp\ntemplate <typename Dtype>\nvoid Solver<Dtype>::Step(int iters) {\n ...\n while (iter_ < stop_iter) {\n for (int i = 0; i < callbacks_.size(); ++i) {\n callbacks_[i]->on_start(); // 回调P2PSync中的on_start，从主P2PSync获取新模型\n }\n ...\n Dtype loss = Forward_backward();\n ...\n for (int i = 0; i < callbacks_.size(); ++i) {\n callbacks_[i]->on_gradients_ready(); // 回调P2PSync中的on_gradients_ready，依次聚合从P2PSync和自身的梯度，并将梯度发送给主P2PSync\n }\n if (!param().disabled_update()) {\n ApplyUpdate(); // 这里只有root solver才会进行参数更新\n }\n ...\n\n }\n}\n```\n \n```c++\ntemplate<typename Dtype>\nvoid P2PSync<Dtype>::on_start() {\n#ifndef CPU_ONLY\n ...\n // Wait for update from parent\n if (parent_) {\n   /* 除了root solver，其他worker solver都有对应的parent\n      程序执行到这里时会阻塞，当主P2PSync将自身入队后就会通知从P2PSync，pop就能返回\n   */\n   P2PSync<Dtype> *parent = queue_.pop(); // 等待主P2PSync入队\n   CHECK(parent == parent_);\n }\n // Update children\n for (int i = children_.size() - 1; i >= 0; i--) {\n   Dtype* src = data_;\n   Dtype* dst = children_[i]->data_;\n   ...\n   // 主P2PSync将模型直接拷贝给从P2PSync\n   CUDA_CHECK(cudaMemcpyAsync(dst, src, size_ * sizeof(Dtype),\n   cudaMemcpyDeviceToDevice, cudaStreamDefault));\n   CUDA_CHECK(cudaStreamSynchronize(cudaStreamDefault));\n   // 主P2PSync将自身入队，并通知从P2PSync\n   children_[i]->queue_.push(this);\n }\n #endif\n }\n```\n \n```c++\ntemplate<typename Dtype>\nvoid P2PSync<Dtype>::on_gradients_ready() {\n#ifndef CPU_ONLY\n  ...\n  // Sum children gradients as they appear in the queue\n  for (int i = 0; i < children_.size(); ++i) {\n    P2PSync<Dtype> *child = queue_.pop(); // 等待从P2PSync入队\n    // 由于parent_grads_是在主P2PSync设备上开辟的一块缓冲区，因此child->parent_grads_其实就是当前设备上的缓冲区\n    Dtype* src = child->parent_grads_; // 获取从P2PSync的梯度\n    Dtype* dst = diff_;\n    // 合并从P2PSync的梯度\n    caffe_gpu_add(size_, src, dst, dst);\n  }\n  ...\n  // Send gradients to parent\n  if (parent_) {\n    Dtype* src = diff_;\n    Dtype* dst = parent_grads_; \n    // 从P2PSync将梯度复制到主P2PSync的缓冲区\n    CUDA_CHECK(cudaMemcpyAsync(dst, src, size_ * sizeof(Dtype),  //\n        cudaMemcpyDeviceToDevice, cudaStreamDefault));\n    CUDA_CHECK(cudaStreamSynchronize(cudaStreamDefault));\n    // 自身入队，通知主P2PSync\n    parent_->queue_.push(this);\n  } else {\n    // Loss functions divide gradients by the batch size, so to compensate\n    // for split batch, the root solver divides by number of solvers.\n    caffe_gpu_scal(size_, Dtype(1.0 / Caffe::solver_count()), diff_);\n  }\n#endif\n```\n \n##intel caffe多机并行策略\n单机多卡的训练方式已经足够解决目前大部分模型训练的需求了，但随着数据量越来越大、模型越来越复杂，分布式异构计算成为行业通行的解决方案。BVLC caffe是不支持分布式训练的，intel有两个部门将caffe进行了再次开发以支持分布式和最新的Intel MKL-DNN，分别为intel caffe和caffe multinode。目前BML API已经支持intel caffe的模型训练、评估和预测了。   \n\nintel caffe采用的是数据并行的方式，但不同于目前主流的centralized parameter server通信模型，intel caffe借鉴了单机多卡的策略，采用的是一种all-reduce的binary tree模型，也就是将节点按照二叉树组织起来，每个父节点负责1-2个子节点和自己父节点的通信，相比一个中心的PS需要同时与其他多个节点通信的方式，这种binary tree方式将一部分PS的计算平均到了每个节点上，而且相同level的父节点之间可以并行，增加了梯度合并的并行度。   \n\n[待图]\n \n为了更好地掩盖通信开销，子节点不需要等到整个模型的梯度都计算完才发送，而是每个layer计算完梯度后就会立即发送给父节点，父节点收到所有子节点的梯度后将本层的梯度合并后也可以立即发送给上一层的父节点。每个layer的参数会按照buffer的大小分成多个part，每个part都会异步地进行发送，当进行下一次迭代时，除了根节点的所有节点都会被阻塞，等待根节点将最终的梯度进行合并，并更新模型后发送给子节点。   \n\n除了分层通信外，intel caffe也支持梯度量化压缩，可以将全精浮点数编码成指定字节数的数值，减少节点间通信量。   \n\nintel caffe为了支持多种协议的通信，使用了boost的asio::io_service接口，底层实现支持MPI、TCP和UDP，不过目前只实现了MPI接口。 \n  \n训练时交叉验证是在单节点(准确来说是根节点)上进行的，但每个节点上都需要存在验证集文件，这是因为即使不进行test，其他节点也会初始化test网络。   \n\n##实战\n \n##参考\n贾扬清自述http://www.yangfenzi.com/keji/59535.html   \ncaffe官网http://caffe.berkeleyvision.org   \nhttp://ucb-icsi-vision-group.github.io/caffe-paper/caffe.pdf   \nhttps://www.zhihu.com/question/27982282   \nhttp://blog.csdn.net/myarrow/article/details/52064608   \n \n","slug":"caffe学习","published":1,"updated":"2023-01-03T13:53:15.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgavfto0009hbeq1dpe2x8p","content":"<p>#caffe学习总结</p>\n<p>##caffe的由来 caffe是贾扬清在UC\nBerkeley攻读计算机科学博士学位时开发的一套深度学习框架，由于高效、易读和模块化的设计，开源后经过nvidia的帮助优化和社区不断的完善，如今成为视觉领域主流的框架之一。</p>\n<span id=\"more\"></span>\n<ul>\n<li><p>贾扬清其人<br />\n清华大学的本硕，UC Berkeley的计算机科学博士，师承Prof. Trevor\nDarrell，期间在新加坡国立大学、微软亚洲研究院、NEC美国实验室和google研究院实习和工作。博士毕业后一直在google\nbrain担任研究科学家，致力于机器视觉、深度学习和tensorflow相关工作。2016年2月加入facebook，主导facebook大多数AI应用的通用、大规模机器学习平台（目前以caffe2为基础的caffe2go已经开源）。</p></li>\n<li><p>为什么要开发caffe<br />\n贾最早开发的是另一款软件Decaf，主要功能是基于cuda-convnet进行CNN训练。2013年贾扬清读博期间跟心理学老师合作研究使用概率框架来表达人的行为，\"但是因为图像上提取的特征比较弱，所以可以外推的结果比较有限\"，而2012年Alex\nKrizhevsky提出的AlexNet在ImageNet比赛中大获成功，贾因此也希望将CNN应用到他们的心理学研究上，于是就开始写了Decaf，通过Decaf验证了\"深度学习特征的优异的可移植性\"，因此就开始开发一套通用的深度学习框架，即后来的caffe。</p></li>\n</ul>\n<p>##caffe与其他一些主流框架的比较\ncaffe同期也存在其他一些开源框架，比如cuda-convnet、theano、torch等，并且后来又陆续开源了neon、mxnet、tensorflow、CNTK以及paddled等等。现在对于研究者，如何选择一个框架也成了一个麻烦的问题了。下图是2014年贾扬清在caffe论文中对当时的一些框架做的一个比较：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-001.png?raw=true width=800>\n</div>\n<p>下面是近年主流框架的一个简单比较：</p>\n<ul>\n<li>特性</li>\n</ul>\n<table style=\"width:100%;\">\n<colgroup>\n<col style=\"width: 18%\" />\n<col style=\"width: 21%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th style=\"text-align: center;\">主语言</th>\n<th style=\"text-align: center;\">从语言</th>\n<th style=\"text-align: center;\">硬件</th>\n<th style=\"text-align: center;\">分布式</th>\n<th style=\"text-align: center;\">命令式</th>\n<th style=\"text-align: center;\">声明式</th>\n<th style=\"text-align: center;\">自动梯度</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>caffe</td>\n<td style=\"text-align: center;\">C++</td>\n<td style=\"text-align: center;\">Python/Matlab</td>\n<td style=\"text-align: center;\">CPU/GPU</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✖</td>\n</tr>\n<tr class=\"even\">\n<td>mxnet</td>\n<td style=\"text-align: center;\">C++</td>\n<td style=\"text-align: center;\">Python/R/Julia/Scala</td>\n<td style=\"text-align: center;\">CPU/GPU/Mobile</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n</tr>\n<tr class=\"odd\">\n<td>tensorflow</td>\n<td style=\"text-align: center;\">C++</td>\n<td style=\"text-align: center;\">Python</td>\n<td style=\"text-align: center;\">CPU/GPU/Mobile</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n</tr>\n<tr class=\"even\">\n<td>Torch</td>\n<td style=\"text-align: center;\">Lua</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">CPU/GPU/FPGA</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✔</td>\n</tr>\n<tr class=\"odd\">\n<td>theano</td>\n<td style=\"text-align: center;\">Python</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">CPU/GPU</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>效率\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-002.png?raw=true width=420>\n</div></li>\n</ul>\n<p>##caffe代码组织结构\ncaffe代码结构是非常清晰的，主要包含以下文件和目录：</p>\n<ul>\n<li>Makefile和Makefile.config\ncaffe支持cmake和make两种编译方式，不过大部分人只需要用make编译就可以了。Makefile.config可以对一些编译选项进行配置，比如USE_MPI、CPU_ONLY、DEBUG等等。</li>\n<li>include\n在caffe中除了proto文件生成的头文件外，所有的c++头文件都放在include目录中。</li>\n<li>src\nsrc与include的目录结构基本上相同，include目录中的文件基本上都能在src目录中找到对应的实现文件。</li>\n<li>tools\ntools目录下是caffe提供给用户直接使用的接口，比如caffe.cpp用于模型训练、评估以及统计耗时，另外也提供一些数据集转换、计算均值等工具</li>\n<li>examples\n提供一些训练相关的脚本和网络配置，比如数据预处理脚本、不同的网络配置文件以及训练脚本</li>\n<li>models\n提供一些模型的网络配置文件，以及训练好的模型，用户可以直接用训练好的模型进行fine-tune或者分类</li>\n<li>matlab/python 提供matlab和python的接口</li>\n</ul>\n<p>##caffe网络的组织方式\n从LeNet开始，CNN就开始有了一个标准的分层结构——堆叠卷积层，卷积层可能后接一些normalization和pooling层，网络最后接一个或多个全连接层。由于梯度下降算法非常适合逐层计算，因此当时很多的通用框架都将网络（Net）抽象为多个数据处理层（Layer）组成的有向图，并支持灵活地定义网络结构。caffe将神经网络的训练问题分解为四个方面：数据、计算、流动控制以及问题求解，分别对应caffe中的Blob、Layer、Net和Solver。网络中流动的数据以及参数都用Blob来表示，Layer负责前向输出和后向梯度的计算，Net负责控制Layer计算的顺序，Solver是一个求解器的角色，根据Net的梯度对网络参数进行更新。</p>\n<p><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-003.png?raw=true width=800></p>\n<p>[待补充]</p>\n<p>##caffe中的Blob及同步策略\nBlob是caffe中存储数据的基本结构，可以简单理解为一个4维的数组，数据组织格式为（N,C,H,W）。在caffe中上下层流动的数据和每层的权重参数都是用Blob来保存的，为了便于使用，Blob具有一些特性：</p>\n<ul>\n<li>Blob的内存是懒分配的（lazily\nallocate），只有在真正使用的时候才会分配内存</li>\n<li>Blob会在CPU和GPU上各自分配一块相同大小的内存，便于在CPU和GPU之间进行切换</li>\n<li>用户不需要关心CPU和GPU数据的同步，Blob会根据需要自动同步</li>\n</ul>\n<p>下面是Blob的成员变量，data_是Blob存储的数据，diff_保存的是数据的梯度，shape_data_和shape_保存的都是当前数组的形状，count_是当前数据的大小，capacity_是申请的内存的大小，避免每次Reshape都要释放并重新申请内存。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/caffe/blob.hpp</span></span><br><span class=\"line\">shared_ptr&lt;SyncedMemory&gt; data_;</span><br><span class=\"line\">shared_ptr&lt;SyncedMemory&gt; diff_;</span><br><span class=\"line\">shared_ptr&lt;SyncedMemory&gt; shape_data_;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; shape_;</span><br><span class=\"line\"><span class=\"type\">int</span> count_;</span><br><span class=\"line\"><span class=\"type\">int</span> capacity_;</span><br></pre></td></tr></table></figure>\n<p>下面主要说一下Blob的自动同步策略。首先看一下SyncedMemory的成员变量：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/caffe/syncedmem.hpp</span></span><br><span class=\"line\"><span class=\"type\">void</span>* cpu_ptr_; <span class=\"comment\">// CPU内存数据</span></span><br><span class=\"line\"><span class=\"type\">void</span>* gpu_ptr_; <span class=\"comment\">// GPU显存数据</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> size_;   <span class=\"comment\">// 数据大小</span></span><br><span class=\"line\">SyncedHead head_;  <span class=\"comment\">// 同步标志</span></span><br><span class=\"line\"><span class=\"type\">bool</span> own_cpu_data_; </span><br><span class=\"line\"><span class=\"type\">bool</span> cpu_malloc_use_cuda_;</span><br><span class=\"line\"><span class=\"type\">bool</span> own_gpu_data_;</span><br><span class=\"line\"><span class=\"type\">int</span> gpu_device_; <span class=\"comment\">// GPU设备号</span></span><br></pre></td></tr></table></figure>\n<p>head_的取值范围为UNINITIALIZED, HEAD_AT_CPU, HEAD_AT_GPU,\nSYNCED。初始化时head_值为UNINITIALIZED，当调用Blob的取值函数时都会调用一次SyncedMemory的to_cpu或者to_gpu进行数据的同步，同步策略为：<br />\n1、取cpu数据时，会调用to_cpu函数，如果heda_为HEAD_AT_GPU，则需要将GPU的数据同步至CPU，否则不需要同步<br />\n2、取gpu数据时，会调用to_gpu函数，如果heda_为HEAD_AT_CPU，则需要将CPU的数据同步至GPU，否则不需要同步</p>\n<p>head_标志的赋值：<br />\n1、每次调用SyncedMemory的mutable_cpu_data时，head_都会被置为HEAD_AT_CPU<br />\n2、每次调用SyncedMemory的mutable_gpu_data时，head_都会被置为HEAD_AT_GPU<br />\n3、每次同步之后heda_会被置为SYNCED。</p>\n<p>因此Blob通过判断每次修改的位置来自行决定是否需要对不同设备间的两份数据进行同步，使用时就像只有一份数据一样，非常方便。</p>\n<p>##caffe中的Layer\nlayer是caffe模型的主要组成部分和基本的计算单元，与很多框架中的operator对应，一个典型的layer在forward时从下层连接获取输入，经过计算后输出到上层，backward时又从上层连接获取误差，计算本层梯度和误差后，将误差传递到下层连接。因此基类Layer实现了三个基本函数setup、forward和backward。</p>\n<ul>\n<li>setup：根据下层连接和配置参数完成本层参数的初始化，以及输出blobs的初始化</li>\n<li>forward：前向计算过程，并计算本层的loss</li>\n<li>backward：后向计算过程，并将本层误差传递到下层</li>\n</ul>\n<p>forward和backward里面都会对CPU和GPU进行分支，如果是CPU模式，则真正参与计算的是forward_cpu和backward_cpu，如果是GPU模式，则参与计算的是forward_gpu和backward_gpu，并且在基类中forward_gpu和backward_gpu分别调用的是forward_cpu和backward_cpu，当然用户在定义新的layer时可以自行实现forward_gpu和backward_gpu。</p>\n<p>基类Layer的成员变量：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/caffe/layer.hpp</span></span><br><span class=\"line\"><span class=\"comment\">/** The protobuf that stores the layer parameters */</span></span><br><span class=\"line\">LayerParameter layer_param_;</span><br><span class=\"line\"><span class=\"comment\">/** The phase: TRAIN or TEST */</span></span><br><span class=\"line\">Phase phase_;</span><br><span class=\"line\"><span class=\"comment\">/** The vector that stores the learnable parameters as a set of blobs. */</span></span><br><span class=\"line\">vector&lt;shared_ptr&lt;Blob&lt;Dtype&gt; &gt; &gt; blobs_;</span><br><span class=\"line\"><span class=\"comment\">/** Vector indicating whether to compute the diff of each param blob. */</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">bool</span>&gt; param_propagate_down_;</span><br><span class=\"line\"><span class=\"comment\">/** The vector that indicates whether each top blob has a non-zero weight in</span></span><br><span class=\"line\"><span class=\"comment\"> *  the objective function. */</span></span><br><span class=\"line\">vector&lt;Dtype&gt; loss_;</span><br></pre></td></tr></table></figure>\n<p>layer_param_是从protobuf文件中反序列化得到的，存放的是layer的配置参数\nphase_指示是训练还是测试 blobs_是本层的参数，比如权重和偏置\nparam_propagate_down_为每一个参数设定是否需要计算梯度\nloss_是本层的损失值，loss层每个输出blob都有一个损失值，非loss层损失为0</p>\n<p>由基类Layer直接或间接派生出各种layer，比如卷积(convolution)、全连接(fully\nconnected或者inner\nproduct)、dropout、pooling、relu、softmaxWithLoss等等，每一个派生layer都会强制实现forward_cpu和backward_cpu。早期的caffe将layer分成5类，</p>\n<ul>\n<li>dataLayer类： 各类数据读取的接口</li>\n<li>neuronLayer类： 各种激活函数、dropout</li>\n<li>visionLayer类： 卷积层、采样层等2D图像相关的运算</li>\n<li>commonLayer类：全连接层和其他运算</li>\n<li>lossLayer类：实现各种代价函数</li>\n</ul>\n<p>不过目前最新版本的caffe已经取消了visionLayer和commonLayer的分类。此外由于caffe使用了cuDNN运算加速库，因此部分layer有caffe和cuDNN两种实现，使用时可以通过protobuf文件配置需要使用的engine。</p>\n<p>为了保持框架的可扩展性，大多数框架在layer或者operator的实现中使用了工厂模式，使用统一的工厂类来对不同的layer或operator进行实例化。下面是caffe使用工厂模式的代码实现，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/caffe/layer_factory.hpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LayerRegistry</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*Creator)(<span class=\"type\">const</span> LayerParameter&amp;);</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> std::map&lt;string, Creator&gt; CreatorRegistry;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> CreatorRegistry&amp; <span class=\"title\">Registry</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> CreatorRegistry* g_registry_ = <span class=\"keyword\">new</span> <span class=\"built_in\">CreatorRegistry</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *g_registry_;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Adds a creator.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">AddCreator</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; type, Creator creator)</span> </span>&#123;</span><br><span class=\"line\">    CreatorRegistry&amp; registry = <span class=\"built_in\">Registry</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_EQ</span>(registry.<span class=\"built_in\">count</span>(type), <span class=\"number\">0</span>)</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot;Layer type &quot;</span> &lt;&lt; type &lt;&lt; <span class=\"string\">&quot; already registered.&quot;</span>;</span><br><span class=\"line\">    registry[type] = creator;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LayerRegisterer</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">LayerRegisterer</span>(<span class=\"type\">const</span> string&amp; type,</span><br><span class=\"line\">                  shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*creator)(<span class=\"type\">const</span> LayerParameter&amp;)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// LOG(INFO) &lt;&lt; &quot;Registering layer type: &quot; &lt;&lt; type;</span></span><br><span class=\"line\">    LayerRegistry&lt;Dtype&gt;::<span class=\"built_in\">AddCreator</span>(type, creator);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REGISTER_LAYER_CREATOR(type, creator)                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  static LayerRegisterer<span class=\"string\">&lt;float&gt;</span> g_creator_f_##type(#type, creator<span class=\"string\">&lt;float&gt;</span>);     \\</span></span><br><span class=\"line\"><span class=\"meta\">  static LayerRegisterer<span class=\"string\">&lt;double&gt;</span> g_creator_d_##type(#type, creator<span class=\"string\">&lt;double&gt;</span>)    \\</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/layer_factory.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\">shared_ptr&lt;Layer&lt;Dtype&gt; &gt; <span class=\"built_in\">GetSigmoidLayer</span>(<span class=\"type\">const</span> LayerParameter&amp; param) &#123;</span><br><span class=\"line\">  SigmoidParameter_Engine engine = param.<span class=\"built_in\">sigmoid_param</span>().<span class=\"built_in\">engine</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (engine == SigmoidParameter_Engine_DEFAULT) &#123;</span><br><span class=\"line\">    engine = SigmoidParameter_Engine_CAFFE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> USE_CUDNN</span></span><br><span class=\"line\">    engine = SigmoidParameter_Engine_CUDNN;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (engine == SigmoidParameter_Engine_CAFFE) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shared_ptr&lt;Layer&lt;Dtype&gt; &gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">SigmoidLayer</span>&lt;Dtype&gt;(param));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> USE_CUDNN</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (engine == SigmoidParameter_Engine_CUDNN) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shared_ptr&lt;Layer&lt;Dtype&gt; &gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">CuDNNSigmoidLayer</span>&lt;Dtype&gt;(param));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">LOG</span>(FATAL) &lt;&lt; <span class=\"string\">&quot;Layer &quot;</span> &lt;&lt; param.<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot; has unknown engine.&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">REGISTER_LAYER_CREATOR</span>(Sigmoid, GetSigmoidLayer);</span><br></pre></td></tr></table></figure>\n<p>##caffe中的Net\nNet是由Layer组成的有向图，表示整个神经网络的拓扑结构，与很多框架中的graph对应，一般用一个protobuf文件来定义。而且Layer作为有向图中的一个组件，是无法感知自己的上层和下层连接的，需要Net将数据feed给Layer，这样数据在有向图中才能真正流动起来。因此Net至少需要提供构建一个有向图和feed数据流两种功能。</p>\n<ul>\n<li>构建一个有向图：void Init(const NetParameter&amp; in_param)</li>\n<li>feed数据流： const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp;\nForward(Dtype* loss)和void Backward()</li>\n</ul>\n<p>在构建有向图时，caffe首先会对不符合规则的layer进行过滤，比如对于test\nnet，则会把只用于train的layer过滤掉。对于有向图中可能存在分支的情况，caffe会自动插入split层，将原输入blob复制多份，分别输入不同的分支，比如：LeNet网络中的数据层的label需要输入到accuracy层和loss层，那么需要在数据层再插入一层，如下图所示。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-004.jpg?raw=true width=600>\n</div>\n<p>Net会根据网络结构逐层创建layer，并指定输入输出blobs，以及是否需要backward。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/net.cpp:Init</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> layer_id = <span class=\"number\">0</span>; layer_id &lt; param.<span class=\"built_in\">layer_size</span>(); ++layer_id) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    layers_.<span class=\"built_in\">push_back</span>(LayerRegistry&lt;Dtype&gt;::<span class=\"built_in\">CreateLayer</span>(layer_param));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> bottom_id = <span class=\"number\">0</span>; bottom_id &lt; layer_param.<span class=\"built_in\">bottom_size</span>(); ++bottom_id) &#123;</span><br><span class=\"line\">      <span class=\"type\">const</span> <span class=\"type\">int</span> blob_id = <span class=\"built_in\">AppendBottom</span>(param, layer_id, bottom_id,</span><br><span class=\"line\">                                       &amp;available_blobs, &amp;blob_name_to_idx);</span><br><span class=\"line\">      <span class=\"comment\">// If a blob needs backward, this layer should provide it.</span></span><br><span class=\"line\">      need_backward |= blob_need_backward_[blob_id];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> num_top = layer_param.<span class=\"built_in\">top_size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> top_id = <span class=\"number\">0</span>; top_id &lt; num_top; ++top_id) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">AppendTop</span>(param, layer_id, top_id, &amp;available_blobs, &amp;blob_name_to_idx);</span><br><span class=\"line\">      <span class=\"comment\">// Collect Input layer tops as Net inputs.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (layer_param.<span class=\"built_in\">type</span>() == <span class=\"string\">&quot;Input&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">int</span> blob_id = blobs_.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        net_input_blob_indices_.<span class=\"built_in\">push_back</span>(blob_id);</span><br><span class=\"line\">        net_input_blobs_.<span class=\"built_in\">push_back</span>(blobs_[blob_id].<span class=\"built_in\">get</span>());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    layers_[layer_id]-&gt;<span class=\"built_in\">SetUp</span>(bottom_vecs_[layer_id], top_vecs_[layer_id]);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在训练时，train net会首先初始化，test\nnet之后初始化，每次test时会调用ShareTrainedLayersWith共享train\nnet的参数，这样做可以节省显存并且避免不必要的数据拷贝。</p>\n<p>需要注意的是，在protobuf文件中声明网络结构时，必须依照从下到上的顺序一层一层定义网络参数，而且test\nnet和train\nnet对应层的name最好一致(虽然不一致可能不会导致程序报错），因为test\nnet与train\nnet是根据匹配name进行参数共享的，如果name不一致则会导致无法进行参数共享，增加显存消耗的同时还会导致test结果不正确。</p>\n<p>当有向图构建完成后，我们只需要调用Forward和Backward，数据就能流经整个网络，得到每层的输出、loss和每个参数的梯度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/net.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\">Dtype Net&lt;Dtype&gt;::<span class=\"built_in\">ForwardFromTo</span>(<span class=\"type\">int</span> start, <span class=\"type\">int</span> end) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">CHECK_GE</span>(start, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">CHECK_LT</span>(end, layers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">  Dtype loss = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// LOG(ERROR) &lt;&lt; &quot;Forwarding &quot; &lt;&lt; layer_names_[i];</span></span><br><span class=\"line\">    Dtype layer_loss = layers_[i]-&gt;<span class=\"built_in\">Forward</span>(bottom_vecs_[i], top_vecs_[i]);</span><br><span class=\"line\">    loss += layer_loss;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (debug_info_) &#123; <span class=\"built_in\">ForwardDebugInfo</span>(i); &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> loss;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Net&lt;Dtype&gt;::<span class=\"built_in\">BackwardFromTo</span>(<span class=\"type\">int</span> start, <span class=\"type\">int</span> end) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">CHECK_GE</span>(end, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">CHECK_LT</span>(start, layers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = start; i &gt;= end; --i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (layer_need_backward_[i]) &#123;</span><br><span class=\"line\">      layers_[i]-&gt;<span class=\"built_in\">Backward</span>(</span><br><span class=\"line\">          top_vecs_[i], bottom_need_backward_[i], bottom_vecs_[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (debug_info_) &#123; <span class=\"built_in\">BackwardDebugInfo</span>(i); &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##caffe中的Solver\n前面讲到Net通过调用Forward和Backward可以得到每个参数的梯度，而Solver的主要作用就是根据这些梯度进行网络参数的更新。由于caffe将Net作为Solver的底层实现，因此Solver也就成了控制整个训练过程的中枢。Solver提供三个主要函数：Init、Solve、ApplyUpdate。</p>\n<ul>\n<li>Init：创建训练网络和测试网络，初始化一些参数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Solver&lt;Dtype&gt;::<span class=\"built_in\">Init</span>(<span class=\"type\">const</span> SolverParameter&amp; param) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// Scaffolding code</span></span><br><span class=\"line\">  <span class=\"built_in\">InitTrainNet</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Caffe::<span class=\"built_in\">root_solver</span>()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">InitTestNets</span>();</span><br><span class=\"line\">    <span class=\"built_in\">LOG</span>(INFO) &lt;&lt; <span class=\"string\">&quot;Solver scaffolding done.&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  iter_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">  current_step_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Solve：调用Step进行迭代训练，每次迭代后都会调用ApplyUpdate进行参数的更新</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\">Dtype Solver&lt;Dtype&gt;::<span class=\"built_in\">ForwardBackward</span>() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// accumulate the loss and gradient</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; param_.<span class=\"built_in\">iter_size</span>(); ++i) &#123;</span><br><span class=\"line\">    loss += net_-&gt;<span class=\"built_in\">ForwardBackward</span>();\\</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> loss / param_.<span class=\"built_in\">iter_size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Solver&lt;Dtype&gt;::<span class=\"built_in\">Step</span>(<span class=\"type\">int</span> iters) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (iter_ &lt; stop_iter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (param_.<span class=\"built_in\">test_interval</span>() &amp;&amp; iter_ % param_.<span class=\"built_in\">test_interval</span>() == <span class=\"number\">0</span></span><br><span class=\"line\">        &amp;&amp; (iter_ &gt; <span class=\"number\">0</span> || param_.<span class=\"built_in\">test_initialization</span>())</span><br><span class=\"line\">        &amp;&amp; Caffe::<span class=\"built_in\">root_solver</span>()) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">TestAll</span>(); <span class=\"comment\">// 进行测试</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; callbacks_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">      callbacks_[i]-&gt;<span class=\"built_in\">on_start</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Dtype loss = <span class=\"built_in\">ForwardBackward</span>();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">UpdateSmoothedLoss</span>(loss, start_iter, average_loss);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; callbacks_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">      callbacks_[i]-&gt;<span class=\"built_in\">on_gradients_ready</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">param</span>().<span class=\"built_in\">disabled_update</span>()) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">ApplyUpdate</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++iter_;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Solver&lt;Dtype&gt;::<span class=\"built_in\">Solve</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* resume_file) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"built_in\">Step</span>(param_.<span class=\"built_in\">max_iter</span>() - iter_);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ApplyUpdate：调用对应的solver进行参数更新，下面是sgd\nsolver的ApplyUpdate函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solvers/sgd_solver.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> SGDSolver&lt;Dtype&gt;::<span class=\"built_in\">ApplyUpdate</span>() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Dtype rate = <span class=\"built_in\">GetLearningRate</span>(); <span class=\"comment\">//获取当前迭代的学习率</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"built_in\">ClipGradients</span>(); <span class=\"comment\">// 进行梯度规整</span></span><br><span class=\"line\">  <span class=\"comment\">// learnable_params存放的是网络中所有需要学习的参数blobs</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> param_id = <span class=\"number\">0</span>; param_id &lt; <span class=\"keyword\">this</span>-&gt;net_-&gt;<span class=\"built_in\">learnable_params</span>().<span class=\"built_in\">size</span>();</span><br><span class=\"line\">       ++param_id) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">ApplyUpdate</span>(param_id); <span class=\"comment\">// 逐个更新参数</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于梯度下降算法发展出了非常多的优化算法，目前caffe提供了六种优化算法来求解最优参数，在solver配置文件中，通过设置type类型来选择。</p>\n<ul>\n<li>Stochastic Gradient Descent (type: \"SGD\"),</li>\n<li>AdaDelta (type: \"AdaDelta\"),</li>\n<li>Adaptive Gradient (type: \"AdaGrad\"),</li>\n<li>Adam (type: \"Adam\"),</li>\n<li>Nesterov’s Accelerated Gradient (type: \"Nesterov\")</li>\n<li>RMSprop (type: \"RMSProp\")</li>\n</ul>\n<p>##caffe断点保存和恢复\n由于训练过程往往非常耗时，为了能够在突发情况后快速恢复训练，caffe提供了断点保存和恢复的功能，在solver的配置文件中可以配置保存的频率及保存时文件名的前缀，一个比较完整的solver配置文件如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solver.prototxt</span></span><br><span class=\"line\">net: <span class=\"string\">&quot;./train_val.prototxt&quot;</span>  <span class=\"comment\">// 定义net的protobuf文件</span></span><br><span class=\"line\">test_iter: <span class=\"number\">100</span>   <span class=\"comment\">// 测试的迭代次数，这个需要根据测试数据的大小和测试时的batch size计算得到，test_iter = test_dataset_size / test_batch_size</span></span><br><span class=\"line\">test_interval: <span class=\"number\">1000</span>  <span class=\"comment\">// 设置test的频率，每训练1000次迭代就测试一次</span></span><br><span class=\"line\">base_lr: <span class=\"number\">0.01</span>  <span class=\"comment\">// 设置学习率</span></span><br><span class=\"line\">lr_policy: <span class=\"string\">&quot;step&quot;</span>  <span class=\"comment\">// 设置学习率衰减策略</span></span><br><span class=\"line\">gamma: <span class=\"number\">0.1</span>  <span class=\"comment\">// step衰减因子，</span></span><br><span class=\"line\">stepsize: <span class=\"number\">10000</span> <span class=\"comment\">// 衰减的频率，每训练10000次迭代衰减一次，衰减后的学习率=当前学习率*gamma</span></span><br><span class=\"line\">display: <span class=\"number\">500</span>  <span class=\"comment\">// 训练log打印频率</span></span><br><span class=\"line\">max_iter: <span class=\"number\">45000</span>  <span class=\"comment\">// 设置最大训练多少次迭代</span></span><br><span class=\"line\">type: <span class=\"string\">&quot;SGD&quot;</span>  <span class=\"comment\">// 设置solver类型 </span></span><br><span class=\"line\">momentum: <span class=\"number\">0.9</span>  <span class=\"comment\">// 设置SGD中的动量项</span></span><br><span class=\"line\">weight_decay: <span class=\"number\">0.0005</span>  <span class=\"comment\">// 设置正则系数</span></span><br><span class=\"line\">snapshot: <span class=\"number\">1000</span>  <span class=\"comment\">// 设置模型保存频率</span></span><br><span class=\"line\">snapshot_prefix: <span class=\"string\">&quot;../output/caffe_alexnet_train&quot;</span>  <span class=\"comment\">// 设置模型保存时文件名前缀</span></span><br><span class=\"line\">solver_mode: CPU  <span class=\"comment\">// 设置训练模式，CPU还是GPU</span></span><br></pre></td></tr></table></figure>\n<p>当然还有一些其他的参数，比如正则化类型和模型保存文件格式等，都会使用在proto文件中定义的默认值，具体查看src/caffe/proto/caffe.proto文件中的SolverParameter。</p>\n<p>为了实现断点保存和恢复，caffe在Solver中加入了Snapshot和Restore，分别进行模型保存和模型恢复，相应地，在Net中也加入了ToProto/ToHDF5和CopyTrainedLayersFromBinaryProto/CopyTrainedLayersFromHDF5。Solver调用Step进行训练的时候，每次参数更新结束都会判断是否需要保存模型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp:Step</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((param_.<span class=\"built_in\">snapshot</span>()</span><br><span class=\"line\">     &amp;&amp; iter_ % param_.<span class=\"built_in\">snapshot</span>() == <span class=\"number\">0</span></span><br><span class=\"line\">     &amp;&amp; Caffe::<span class=\"built_in\">root_solver</span>()) ||</span><br><span class=\"line\">     (request == SolverAction::SNAPSHOT)) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Snapshot</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solver中Snapshot对模型参数和训练状态进行保存，模型参数提供两种保存格式——binary\nprotobuf和hdf5。如果是protobuf格式，则会调用Net的ToProto，否则调用ToHDF5。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/net.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Net&lt;Dtype&gt;::<span class=\"built_in\">ToProto</span>(NetParameter* param, <span class=\"type\">bool</span> write_diff) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">  param-&gt;<span class=\"built_in\">Clear</span>();</span><br><span class=\"line\">  param-&gt;<span class=\"built_in\">set_name</span>(name_);</span><br><span class=\"line\">  <span class=\"comment\">// Add bottom and top</span></span><br><span class=\"line\">  <span class=\"built_in\">DLOG</span>(INFO) &lt;&lt; <span class=\"string\">&quot;Serializing &quot;</span> &lt;&lt; layers_.<span class=\"built_in\">size</span>() &lt;&lt; <span class=\"string\">&quot; layers&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; layers_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">    LayerParameter* layer_param = param-&gt;<span class=\"built_in\">add_layer</span>();</span><br><span class=\"line\">    layers_[i]-&gt;<span class=\"built_in\">ToProto</span>(layer_param, write_diff);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solver在开始训练时会尝试调用Restore进行断点恢复，根据文件名后缀判断文件格式，并选择RestoreSolverStateFromHDF5还是RestoreSolverStateFromBinaryProto。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp:Solve</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (resume_file) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">LOG</span>(INFO) &lt;&lt; <span class=\"string\">&quot;Restoring previous solver status from &quot;</span> &lt;&lt; resume_file;</span><br><span class=\"line\">  <span class=\"built_in\">Restore</span>(resume_file);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##in-place计算\n为了节约显存，caffe支持原址计算，就是输入与输出都是同一个blob。如果前一层的输出和本层的输入都与后向计算时无关，而且本层的输入和输出blob大小相同，就可以使用in-place计算，比如卷积层后面的Sigmoid、Relu等都可以用同址计算，而BatchNorm层也支持in-place计算，是因为BatchNorm在实现时会将输入数据进行备份。使用同址计算只要在protobuf文件中指定该层的top和bottom是同名的就可以了，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layer &#123;</span><br><span class=\"line\">        bottom: <span class=\"string\">&quot;conv1&quot;</span></span><br><span class=\"line\">        top: <span class=\"string\">&quot;conv1&quot;</span></span><br><span class=\"line\">        name: <span class=\"string\">&quot;conv1_relu&quot;</span></span><br><span class=\"line\">        type: <span class=\"string\">&quot;ReLU&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##参数初始化方法\n由于神经网络的目标函数往往是非凸的，参数初始化会对最终的收敛结果造成非常大的影响。为了满足不同的参数初始化需求，caffe提供了多种初始化方法，并且在net的配置文件中可以为每个参数选择一个初始化方法。比如下面的weight_filler和bias_filler：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layer &#123;</span><br><span class=\"line\">        bottom: <span class=\"string\">&quot;data&quot;</span></span><br><span class=\"line\">        top: <span class=\"string\">&quot;conv1&quot;</span></span><br><span class=\"line\">        name: <span class=\"string\">&quot;conv1&quot;</span></span><br><span class=\"line\">        type: <span class=\"string\">&quot;Convolution&quot;</span></span><br><span class=\"line\">        convolution_param &#123;</span><br><span class=\"line\">                num_output: <span class=\"number\">64</span></span><br><span class=\"line\">                kernel_size: <span class=\"number\">7</span></span><br><span class=\"line\">                pad: <span class=\"number\">3</span></span><br><span class=\"line\">                stride: <span class=\"number\">2</span></span><br><span class=\"line\">                weight_filler &#123;</span><br><span class=\"line\">                  type: <span class=\"string\">&quot;xavier&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                bias_filler &#123;</span><br><span class=\"line\">                  type: <span class=\"string\">&quot;constant&quot;</span></span><br><span class=\"line\">                  value: <span class=\"number\">0.2</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在include/caffe/filler.hpp中caffe提供如下的初始化方法：</p>\n<ul>\n<li>constant：常量初始化，参数所有的值都被初始化为相同的值</li>\n<li>uniform：均匀初始化，参数的值按照指定区间均匀分布随机初始化</li>\n<li>gaussian：高斯初始化，参数的值按照指定均值和方差的正态分布随机初始化</li>\n<li>positive unitball</li>\n<li>xavier：本质上也是一种指定区间均匀分布的随机初始化方式，只是区间是通过参数大小计算得到</li>\n<li>msra：与xavier类似，不过使用的是指定均值和方差的正态分布随机初始化方式</li>\n<li>bilinear</li>\n</ul>\n<p>##多卡并行策略\n为了提高效率，caffe支持单机多GPU并行训练，目前采用的是数据并行方式，暂不支持模型并行，为此caffe增加了一个P2PSync类，下面主要介绍一下P2PSync如何实现多卡并行的。</p>\n<p>P2PSync封装了一个Solver负责训练，每张GPU都会对应一个P2PSync，并且P2PSync之间具有主从关系，它们之间构成一个二叉树的结构。在前向计算时，主P2PSync需要将模型分发给从P2PSync，而在后向传导时，从P2PSync就需要把梯度传给主P2PSync，主P2PSync会在聚合从P2PSync的梯度后传给更上一层的主P2PSync。在二叉树结构中，根节点P2PSync的Solver被叫做root\nsolver，其他solver叫做worker solver，只有root\nsolver才能进行参数更新，worker solver只是将梯度聚合并传递给root\nsolver。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-005.jpg?raw=true width=720>\n</div>\n<p>在P2PSync中主要的函数就InternalThreadEntry、on_start和on_gradients_ready。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/parallel.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> P2PSync&lt;Dtype&gt;::<span class=\"built_in\">InternalThreadEntry</span>() &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"> solver_-&gt;<span class=\"built_in\">Step</span>(solver_-&gt;<span class=\"built_in\">param</span>().<span class=\"built_in\">max_iter</span>() - initial_iter_);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>InternalThreadEntry是一个线程函数，Solver调用Step进行训练，在Step中每次前向计算前都会回调on_start获取最新模型，而在后向计算结束后又会回调on_gradients_ready传递梯度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Solver&lt;Dtype&gt;::<span class=\"built_in\">Step</span>(<span class=\"type\">int</span> iters) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (iter_ &lt; stop_iter) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; callbacks_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\"> callbacks_[i]-&gt;<span class=\"built_in\">on_start</span>(); <span class=\"comment\">// 回调P2PSync中的on_start，从主P2PSync获取新模型</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> Dtype loss = <span class=\"built_in\">Forward_backward</span>();</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; callbacks_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\"> callbacks_[i]-&gt;<span class=\"built_in\">on_gradients_ready</span>(); <span class=\"comment\">// 回调P2PSync中的on_gradients_ready，依次聚合从P2PSync和自身的梯度，并将梯度发送给主P2PSync</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!<span class=\"built_in\">param</span>().<span class=\"built_in\">disabled_update</span>()) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">ApplyUpdate</span>(); <span class=\"comment\">// 这里只有root solver才会进行参数更新</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> P2PSync&lt;Dtype&gt;::<span class=\"built_in\">on_start</span>() &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CPU_ONLY</span></span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"comment\">// Wait for update from parent</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (parent_) &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 除了root solver，其他worker solver都有对应的parent</span></span><br><span class=\"line\"><span class=\"comment\">      程序执行到这里时会阻塞，当主P2PSync将自身入队后就会通知从P2PSync，pop就能返回</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">   P2PSync&lt;Dtype&gt; *parent = queue_.<span class=\"built_in\">pop</span>(); <span class=\"comment\">// 等待主P2PSync入队</span></span><br><span class=\"line\">   <span class=\"built_in\">CHECK</span>(parent == parent_);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">// Update children</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = children_.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">   Dtype* src = data_;</span><br><span class=\"line\">   Dtype* dst = children_[i]-&gt;data_;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"comment\">// 主P2PSync将模型直接拷贝给从P2PSync</span></span><br><span class=\"line\">   <span class=\"built_in\">CUDA_CHECK</span>(<span class=\"built_in\">cudaMemcpyAsync</span>(dst, src, size_ * <span class=\"built_in\">sizeof</span>(Dtype),</span><br><span class=\"line\">   cudaMemcpyDeviceToDevice, cudaStreamDefault));</span><br><span class=\"line\">   <span class=\"built_in\">CUDA_CHECK</span>(<span class=\"built_in\">cudaStreamSynchronize</span>(cudaStreamDefault));</span><br><span class=\"line\">   <span class=\"comment\">// 主P2PSync将自身入队，并通知从P2PSync</span></span><br><span class=\"line\">   children_[i]-&gt;queue_.<span class=\"built_in\">push</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> P2PSync&lt;Dtype&gt;::<span class=\"built_in\">on_gradients_ready</span>() &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CPU_ONLY</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// Sum children gradients as they appear in the queue</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; children_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">    P2PSync&lt;Dtype&gt; *child = queue_.<span class=\"built_in\">pop</span>(); <span class=\"comment\">// 等待从P2PSync入队</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于parent_grads_是在主P2PSync设备上开辟的一块缓冲区，因此child-&gt;parent_grads_其实就是当前设备上的缓冲区</span></span><br><span class=\"line\">    Dtype* src = child-&gt;parent_grads_; <span class=\"comment\">// 获取从P2PSync的梯度</span></span><br><span class=\"line\">    Dtype* dst = diff_;</span><br><span class=\"line\">    <span class=\"comment\">// 合并从P2PSync的梯度</span></span><br><span class=\"line\">    <span class=\"built_in\">caffe_gpu_add</span>(size_, src, dst, dst);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// Send gradients to parent</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent_) &#123;</span><br><span class=\"line\">    Dtype* src = diff_;</span><br><span class=\"line\">    Dtype* dst = parent_grads_; </span><br><span class=\"line\">    <span class=\"comment\">// 从P2PSync将梯度复制到主P2PSync的缓冲区</span></span><br><span class=\"line\">    <span class=\"built_in\">CUDA_CHECK</span>(<span class=\"built_in\">cudaMemcpyAsync</span>(dst, src, size_ * <span class=\"built_in\">sizeof</span>(Dtype),  <span class=\"comment\">//</span></span><br><span class=\"line\">        cudaMemcpyDeviceToDevice, cudaStreamDefault));</span><br><span class=\"line\">    <span class=\"built_in\">CUDA_CHECK</span>(<span class=\"built_in\">cudaStreamSynchronize</span>(cudaStreamDefault));</span><br><span class=\"line\">    <span class=\"comment\">// 自身入队，通知主P2PSync</span></span><br><span class=\"line\">    parent_-&gt;queue_.<span class=\"built_in\">push</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Loss functions divide gradients by the batch size, so to compensate</span></span><br><span class=\"line\">    <span class=\"comment\">// for split batch, the root solver divides by number of solvers.</span></span><br><span class=\"line\">    <span class=\"built_in\">caffe_gpu_scal</span>(size_, <span class=\"built_in\">Dtype</span>(<span class=\"number\">1.0</span> / Caffe::<span class=\"built_in\">solver_count</span>()), diff_);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>##intel caffe多机并行策略\n单机多卡的训练方式已经足够解决目前大部分模型训练的需求了，但随着数据量越来越大、模型越来越复杂，分布式异构计算成为行业通行的解决方案。BVLC\ncaffe是不支持分布式训练的，intel有两个部门将caffe进行了再次开发以支持分布式和最新的Intel\nMKL-DNN，分别为intel caffe和caffe multinode。目前BML API已经支持intel\ncaffe的模型训练、评估和预测了。</p>\n<p>intel caffe采用的是数据并行的方式，但不同于目前主流的centralized\nparameter server通信模型，intel\ncaffe借鉴了单机多卡的策略，采用的是一种all-reduce的binary\ntree模型，也就是将节点按照二叉树组织起来，每个父节点负责1-2个子节点和自己父节点的通信，相比一个中心的PS需要同时与其他多个节点通信的方式，这种binary\ntree方式将一部分PS的计算平均到了每个节点上，而且相同level的父节点之间可以并行，增加了梯度合并的并行度。</p>\n<p>[待图]</p>\n<p>为了更好地掩盖通信开销，子节点不需要等到整个模型的梯度都计算完才发送，而是每个layer计算完梯度后就会立即发送给父节点，父节点收到所有子节点的梯度后将本层的梯度合并后也可以立即发送给上一层的父节点。每个layer的参数会按照buffer的大小分成多个part，每个part都会异步地进行发送，当进行下一次迭代时，除了根节点的所有节点都会被阻塞，等待根节点将最终的梯度进行合并，并更新模型后发送给子节点。</p>\n<p>除了分层通信外，intel\ncaffe也支持梯度量化压缩，可以将全精浮点数编码成指定字节数的数值，减少节点间通信量。</p>\n<p>intel\ncaffe为了支持多种协议的通信，使用了boost的asio::io_service接口，底层实现支持MPI、TCP和UDP，不过目前只实现了MPI接口。</p>\n<p>训练时交叉验证是在单节点(准确来说是根节点)上进行的，但每个节点上都需要存在验证集文件，这是因为即使不进行test，其他节点也会初始化test网络。</p>\n<p>##实战</p>\n<p>##参考 贾扬清自述http://www.yangfenzi.com/keji/59535.html<br />\ncaffe官网http://caffe.berkeleyvision.org<br />\nhttp://ucb-icsi-vision-group.github.io/caffe-paper/caffe.pdf<br />\nhttps://www.zhihu.com/question/27982282<br />\nhttp://blog.csdn.net/myarrow/article/details/52064608</p>\n","site":{"data":{}},"excerpt":"<p>#caffe学习总结</p>\n<p>##caffe的由来 caffe是贾扬清在UC\nBerkeley攻读计算机科学博士学位时开发的一套深度学习框架，由于高效、易读和模块化的设计，开源后经过nvidia的帮助优化和社区不断的完善，如今成为视觉领域主流的框架之一。</p>","more":"<ul>\n<li><p>贾扬清其人<br />\n清华大学的本硕，UC Berkeley的计算机科学博士，师承Prof. Trevor\nDarrell，期间在新加坡国立大学、微软亚洲研究院、NEC美国实验室和google研究院实习和工作。博士毕业后一直在google\nbrain担任研究科学家，致力于机器视觉、深度学习和tensorflow相关工作。2016年2月加入facebook，主导facebook大多数AI应用的通用、大规模机器学习平台（目前以caffe2为基础的caffe2go已经开源）。</p></li>\n<li><p>为什么要开发caffe<br />\n贾最早开发的是另一款软件Decaf，主要功能是基于cuda-convnet进行CNN训练。2013年贾扬清读博期间跟心理学老师合作研究使用概率框架来表达人的行为，\"但是因为图像上提取的特征比较弱，所以可以外推的结果比较有限\"，而2012年Alex\nKrizhevsky提出的AlexNet在ImageNet比赛中大获成功，贾因此也希望将CNN应用到他们的心理学研究上，于是就开始写了Decaf，通过Decaf验证了\"深度学习特征的优异的可移植性\"，因此就开始开发一套通用的深度学习框架，即后来的caffe。</p></li>\n</ul>\n<p>##caffe与其他一些主流框架的比较\ncaffe同期也存在其他一些开源框架，比如cuda-convnet、theano、torch等，并且后来又陆续开源了neon、mxnet、tensorflow、CNTK以及paddled等等。现在对于研究者，如何选择一个框架也成了一个麻烦的问题了。下图是2014年贾扬清在caffe论文中对当时的一些框架做的一个比较：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-001.png?raw=true width=800>\n</div>\n<p>下面是近年主流框架的一个简单比较：</p>\n<ul>\n<li>特性</li>\n</ul>\n<table style=\"width:100%;\">\n<colgroup>\n<col style=\"width: 18%\" />\n<col style=\"width: 21%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 10%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th style=\"text-align: center;\">主语言</th>\n<th style=\"text-align: center;\">从语言</th>\n<th style=\"text-align: center;\">硬件</th>\n<th style=\"text-align: center;\">分布式</th>\n<th style=\"text-align: center;\">命令式</th>\n<th style=\"text-align: center;\">声明式</th>\n<th style=\"text-align: center;\">自动梯度</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>caffe</td>\n<td style=\"text-align: center;\">C++</td>\n<td style=\"text-align: center;\">Python/Matlab</td>\n<td style=\"text-align: center;\">CPU/GPU</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✖</td>\n</tr>\n<tr class=\"even\">\n<td>mxnet</td>\n<td style=\"text-align: center;\">C++</td>\n<td style=\"text-align: center;\">Python/R/Julia/Scala</td>\n<td style=\"text-align: center;\">CPU/GPU/Mobile</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n</tr>\n<tr class=\"odd\">\n<td>tensorflow</td>\n<td style=\"text-align: center;\">C++</td>\n<td style=\"text-align: center;\">Python</td>\n<td style=\"text-align: center;\">CPU/GPU/Mobile</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n</tr>\n<tr class=\"even\">\n<td>Torch</td>\n<td style=\"text-align: center;\">Lua</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">CPU/GPU/FPGA</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✔</td>\n</tr>\n<tr class=\"odd\">\n<td>theano</td>\n<td style=\"text-align: center;\">Python</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">CPU/GPU</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✖</td>\n<td style=\"text-align: center;\">✔</td>\n<td style=\"text-align: center;\">✔</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>效率\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-002.png?raw=true width=420>\n</div></li>\n</ul>\n<p>##caffe代码组织结构\ncaffe代码结构是非常清晰的，主要包含以下文件和目录：</p>\n<ul>\n<li>Makefile和Makefile.config\ncaffe支持cmake和make两种编译方式，不过大部分人只需要用make编译就可以了。Makefile.config可以对一些编译选项进行配置，比如USE_MPI、CPU_ONLY、DEBUG等等。</li>\n<li>include\n在caffe中除了proto文件生成的头文件外，所有的c++头文件都放在include目录中。</li>\n<li>src\nsrc与include的目录结构基本上相同，include目录中的文件基本上都能在src目录中找到对应的实现文件。</li>\n<li>tools\ntools目录下是caffe提供给用户直接使用的接口，比如caffe.cpp用于模型训练、评估以及统计耗时，另外也提供一些数据集转换、计算均值等工具</li>\n<li>examples\n提供一些训练相关的脚本和网络配置，比如数据预处理脚本、不同的网络配置文件以及训练脚本</li>\n<li>models\n提供一些模型的网络配置文件，以及训练好的模型，用户可以直接用训练好的模型进行fine-tune或者分类</li>\n<li>matlab/python 提供matlab和python的接口</li>\n</ul>\n<p>##caffe网络的组织方式\n从LeNet开始，CNN就开始有了一个标准的分层结构——堆叠卷积层，卷积层可能后接一些normalization和pooling层，网络最后接一个或多个全连接层。由于梯度下降算法非常适合逐层计算，因此当时很多的通用框架都将网络（Net）抽象为多个数据处理层（Layer）组成的有向图，并支持灵活地定义网络结构。caffe将神经网络的训练问题分解为四个方面：数据、计算、流动控制以及问题求解，分别对应caffe中的Blob、Layer、Net和Solver。网络中流动的数据以及参数都用Blob来表示，Layer负责前向输出和后向梯度的计算，Net负责控制Layer计算的顺序，Solver是一个求解器的角色，根据Net的梯度对网络参数进行更新。</p>\n<p><img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-003.png?raw=true width=800></p>\n<p>[待补充]</p>\n<p>##caffe中的Blob及同步策略\nBlob是caffe中存储数据的基本结构，可以简单理解为一个4维的数组，数据组织格式为（N,C,H,W）。在caffe中上下层流动的数据和每层的权重参数都是用Blob来保存的，为了便于使用，Blob具有一些特性：</p>\n<ul>\n<li>Blob的内存是懒分配的（lazily\nallocate），只有在真正使用的时候才会分配内存</li>\n<li>Blob会在CPU和GPU上各自分配一块相同大小的内存，便于在CPU和GPU之间进行切换</li>\n<li>用户不需要关心CPU和GPU数据的同步，Blob会根据需要自动同步</li>\n</ul>\n<p>下面是Blob的成员变量，data_是Blob存储的数据，diff_保存的是数据的梯度，shape_data_和shape_保存的都是当前数组的形状，count_是当前数据的大小，capacity_是申请的内存的大小，避免每次Reshape都要释放并重新申请内存。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/caffe/blob.hpp</span></span><br><span class=\"line\">shared_ptr&lt;SyncedMemory&gt; data_;</span><br><span class=\"line\">shared_ptr&lt;SyncedMemory&gt; diff_;</span><br><span class=\"line\">shared_ptr&lt;SyncedMemory&gt; shape_data_;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; shape_;</span><br><span class=\"line\"><span class=\"type\">int</span> count_;</span><br><span class=\"line\"><span class=\"type\">int</span> capacity_;</span><br></pre></td></tr></table></figure>\n<p>下面主要说一下Blob的自动同步策略。首先看一下SyncedMemory的成员变量：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/caffe/syncedmem.hpp</span></span><br><span class=\"line\"><span class=\"type\">void</span>* cpu_ptr_; <span class=\"comment\">// CPU内存数据</span></span><br><span class=\"line\"><span class=\"type\">void</span>* gpu_ptr_; <span class=\"comment\">// GPU显存数据</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> size_;   <span class=\"comment\">// 数据大小</span></span><br><span class=\"line\">SyncedHead head_;  <span class=\"comment\">// 同步标志</span></span><br><span class=\"line\"><span class=\"type\">bool</span> own_cpu_data_; </span><br><span class=\"line\"><span class=\"type\">bool</span> cpu_malloc_use_cuda_;</span><br><span class=\"line\"><span class=\"type\">bool</span> own_gpu_data_;</span><br><span class=\"line\"><span class=\"type\">int</span> gpu_device_; <span class=\"comment\">// GPU设备号</span></span><br></pre></td></tr></table></figure>\n<p>head_的取值范围为UNINITIALIZED, HEAD_AT_CPU, HEAD_AT_GPU,\nSYNCED。初始化时head_值为UNINITIALIZED，当调用Blob的取值函数时都会调用一次SyncedMemory的to_cpu或者to_gpu进行数据的同步，同步策略为：<br />\n1、取cpu数据时，会调用to_cpu函数，如果heda_为HEAD_AT_GPU，则需要将GPU的数据同步至CPU，否则不需要同步<br />\n2、取gpu数据时，会调用to_gpu函数，如果heda_为HEAD_AT_CPU，则需要将CPU的数据同步至GPU，否则不需要同步</p>\n<p>head_标志的赋值：<br />\n1、每次调用SyncedMemory的mutable_cpu_data时，head_都会被置为HEAD_AT_CPU<br />\n2、每次调用SyncedMemory的mutable_gpu_data时，head_都会被置为HEAD_AT_GPU<br />\n3、每次同步之后heda_会被置为SYNCED。</p>\n<p>因此Blob通过判断每次修改的位置来自行决定是否需要对不同设备间的两份数据进行同步，使用时就像只有一份数据一样，非常方便。</p>\n<p>##caffe中的Layer\nlayer是caffe模型的主要组成部分和基本的计算单元，与很多框架中的operator对应，一个典型的layer在forward时从下层连接获取输入，经过计算后输出到上层，backward时又从上层连接获取误差，计算本层梯度和误差后，将误差传递到下层连接。因此基类Layer实现了三个基本函数setup、forward和backward。</p>\n<ul>\n<li>setup：根据下层连接和配置参数完成本层参数的初始化，以及输出blobs的初始化</li>\n<li>forward：前向计算过程，并计算本层的loss</li>\n<li>backward：后向计算过程，并将本层误差传递到下层</li>\n</ul>\n<p>forward和backward里面都会对CPU和GPU进行分支，如果是CPU模式，则真正参与计算的是forward_cpu和backward_cpu，如果是GPU模式，则参与计算的是forward_gpu和backward_gpu，并且在基类中forward_gpu和backward_gpu分别调用的是forward_cpu和backward_cpu，当然用户在定义新的layer时可以自行实现forward_gpu和backward_gpu。</p>\n<p>基类Layer的成员变量：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/caffe/layer.hpp</span></span><br><span class=\"line\"><span class=\"comment\">/** The protobuf that stores the layer parameters */</span></span><br><span class=\"line\">LayerParameter layer_param_;</span><br><span class=\"line\"><span class=\"comment\">/** The phase: TRAIN or TEST */</span></span><br><span class=\"line\">Phase phase_;</span><br><span class=\"line\"><span class=\"comment\">/** The vector that stores the learnable parameters as a set of blobs. */</span></span><br><span class=\"line\">vector&lt;shared_ptr&lt;Blob&lt;Dtype&gt; &gt; &gt; blobs_;</span><br><span class=\"line\"><span class=\"comment\">/** Vector indicating whether to compute the diff of each param blob. */</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">bool</span>&gt; param_propagate_down_;</span><br><span class=\"line\"><span class=\"comment\">/** The vector that indicates whether each top blob has a non-zero weight in</span></span><br><span class=\"line\"><span class=\"comment\"> *  the objective function. */</span></span><br><span class=\"line\">vector&lt;Dtype&gt; loss_;</span><br></pre></td></tr></table></figure>\n<p>layer_param_是从protobuf文件中反序列化得到的，存放的是layer的配置参数\nphase_指示是训练还是测试 blobs_是本层的参数，比如权重和偏置\nparam_propagate_down_为每一个参数设定是否需要计算梯度\nloss_是本层的损失值，loss层每个输出blob都有一个损失值，非loss层损失为0</p>\n<p>由基类Layer直接或间接派生出各种layer，比如卷积(convolution)、全连接(fully\nconnected或者inner\nproduct)、dropout、pooling、relu、softmaxWithLoss等等，每一个派生layer都会强制实现forward_cpu和backward_cpu。早期的caffe将layer分成5类，</p>\n<ul>\n<li>dataLayer类： 各类数据读取的接口</li>\n<li>neuronLayer类： 各种激活函数、dropout</li>\n<li>visionLayer类： 卷积层、采样层等2D图像相关的运算</li>\n<li>commonLayer类：全连接层和其他运算</li>\n<li>lossLayer类：实现各种代价函数</li>\n</ul>\n<p>不过目前最新版本的caffe已经取消了visionLayer和commonLayer的分类。此外由于caffe使用了cuDNN运算加速库，因此部分layer有caffe和cuDNN两种实现，使用时可以通过protobuf文件配置需要使用的engine。</p>\n<p>为了保持框架的可扩展性，大多数框架在layer或者operator的实现中使用了工厂模式，使用统一的工厂类来对不同的layer或operator进行实例化。下面是caffe使用工厂模式的代码实现，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include/caffe/layer_factory.hpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LayerRegistry</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*Creator)(<span class=\"type\">const</span> LayerParameter&amp;);</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> std::map&lt;string, Creator&gt; CreatorRegistry;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> CreatorRegistry&amp; <span class=\"title\">Registry</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> CreatorRegistry* g_registry_ = <span class=\"keyword\">new</span> <span class=\"built_in\">CreatorRegistry</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *g_registry_;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Adds a creator.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">AddCreator</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; type, Creator creator)</span> </span>&#123;</span><br><span class=\"line\">    CreatorRegistry&amp; registry = <span class=\"built_in\">Registry</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_EQ</span>(registry.<span class=\"built_in\">count</span>(type), <span class=\"number\">0</span>)</span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot;Layer type &quot;</span> &lt;&lt; type &lt;&lt; <span class=\"string\">&quot; already registered.&quot;</span>;</span><br><span class=\"line\">    registry[type] = creator;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LayerRegisterer</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">LayerRegisterer</span>(<span class=\"type\">const</span> string&amp; type,</span><br><span class=\"line\">                  shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*creator)(<span class=\"type\">const</span> LayerParameter&amp;)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// LOG(INFO) &lt;&lt; &quot;Registering layer type: &quot; &lt;&lt; type;</span></span><br><span class=\"line\">    LayerRegistry&lt;Dtype&gt;::<span class=\"built_in\">AddCreator</span>(type, creator);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REGISTER_LAYER_CREATOR(type, creator)                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">  static LayerRegisterer<span class=\"string\">&lt;float&gt;</span> g_creator_f_##type(#type, creator<span class=\"string\">&lt;float&gt;</span>);     \\</span></span><br><span class=\"line\"><span class=\"meta\">  static LayerRegisterer<span class=\"string\">&lt;double&gt;</span> g_creator_d_##type(#type, creator<span class=\"string\">&lt;double&gt;</span>)    \\</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/layer_factory.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\">shared_ptr&lt;Layer&lt;Dtype&gt; &gt; <span class=\"built_in\">GetSigmoidLayer</span>(<span class=\"type\">const</span> LayerParameter&amp; param) &#123;</span><br><span class=\"line\">  SigmoidParameter_Engine engine = param.<span class=\"built_in\">sigmoid_param</span>().<span class=\"built_in\">engine</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (engine == SigmoidParameter_Engine_DEFAULT) &#123;</span><br><span class=\"line\">    engine = SigmoidParameter_Engine_CAFFE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> USE_CUDNN</span></span><br><span class=\"line\">    engine = SigmoidParameter_Engine_CUDNN;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (engine == SigmoidParameter_Engine_CAFFE) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shared_ptr&lt;Layer&lt;Dtype&gt; &gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">SigmoidLayer</span>&lt;Dtype&gt;(param));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> USE_CUDNN</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (engine == SigmoidParameter_Engine_CUDNN) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shared_ptr&lt;Layer&lt;Dtype&gt; &gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">CuDNNSigmoidLayer</span>&lt;Dtype&gt;(param));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">LOG</span>(FATAL) &lt;&lt; <span class=\"string\">&quot;Layer &quot;</span> &lt;&lt; param.<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot; has unknown engine.&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">REGISTER_LAYER_CREATOR</span>(Sigmoid, GetSigmoidLayer);</span><br></pre></td></tr></table></figure>\n<p>##caffe中的Net\nNet是由Layer组成的有向图，表示整个神经网络的拓扑结构，与很多框架中的graph对应，一般用一个protobuf文件来定义。而且Layer作为有向图中的一个组件，是无法感知自己的上层和下层连接的，需要Net将数据feed给Layer，这样数据在有向图中才能真正流动起来。因此Net至少需要提供构建一个有向图和feed数据流两种功能。</p>\n<ul>\n<li>构建一个有向图：void Init(const NetParameter&amp; in_param)</li>\n<li>feed数据流： const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp;\nForward(Dtype* loss)和void Backward()</li>\n</ul>\n<p>在构建有向图时，caffe首先会对不符合规则的layer进行过滤，比如对于test\nnet，则会把只用于train的layer过滤掉。对于有向图中可能存在分支的情况，caffe会自动插入split层，将原输入blob复制多份，分别输入不同的分支，比如：LeNet网络中的数据层的label需要输入到accuracy层和loss层，那么需要在数据层再插入一层，如下图所示。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-004.jpg?raw=true width=600>\n</div>\n<p>Net会根据网络结构逐层创建layer，并指定输入输出blobs，以及是否需要backward。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/net.cpp:Init</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> layer_id = <span class=\"number\">0</span>; layer_id &lt; param.<span class=\"built_in\">layer_size</span>(); ++layer_id) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    layers_.<span class=\"built_in\">push_back</span>(LayerRegistry&lt;Dtype&gt;::<span class=\"built_in\">CreateLayer</span>(layer_param));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> bottom_id = <span class=\"number\">0</span>; bottom_id &lt; layer_param.<span class=\"built_in\">bottom_size</span>(); ++bottom_id) &#123;</span><br><span class=\"line\">      <span class=\"type\">const</span> <span class=\"type\">int</span> blob_id = <span class=\"built_in\">AppendBottom</span>(param, layer_id, bottom_id,</span><br><span class=\"line\">                                       &amp;available_blobs, &amp;blob_name_to_idx);</span><br><span class=\"line\">      <span class=\"comment\">// If a blob needs backward, this layer should provide it.</span></span><br><span class=\"line\">      need_backward |= blob_need_backward_[blob_id];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> num_top = layer_param.<span class=\"built_in\">top_size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> top_id = <span class=\"number\">0</span>; top_id &lt; num_top; ++top_id) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">AppendTop</span>(param, layer_id, top_id, &amp;available_blobs, &amp;blob_name_to_idx);</span><br><span class=\"line\">      <span class=\"comment\">// Collect Input layer tops as Net inputs.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (layer_param.<span class=\"built_in\">type</span>() == <span class=\"string\">&quot;Input&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">int</span> blob_id = blobs_.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        net_input_blob_indices_.<span class=\"built_in\">push_back</span>(blob_id);</span><br><span class=\"line\">        net_input_blobs_.<span class=\"built_in\">push_back</span>(blobs_[blob_id].<span class=\"built_in\">get</span>());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    layers_[layer_id]-&gt;<span class=\"built_in\">SetUp</span>(bottom_vecs_[layer_id], top_vecs_[layer_id]);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在训练时，train net会首先初始化，test\nnet之后初始化，每次test时会调用ShareTrainedLayersWith共享train\nnet的参数，这样做可以节省显存并且避免不必要的数据拷贝。</p>\n<p>需要注意的是，在protobuf文件中声明网络结构时，必须依照从下到上的顺序一层一层定义网络参数，而且test\nnet和train\nnet对应层的name最好一致(虽然不一致可能不会导致程序报错），因为test\nnet与train\nnet是根据匹配name进行参数共享的，如果name不一致则会导致无法进行参数共享，增加显存消耗的同时还会导致test结果不正确。</p>\n<p>当有向图构建完成后，我们只需要调用Forward和Backward，数据就能流经整个网络，得到每层的输出、loss和每个参数的梯度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/net.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\">Dtype Net&lt;Dtype&gt;::<span class=\"built_in\">ForwardFromTo</span>(<span class=\"type\">int</span> start, <span class=\"type\">int</span> end) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">CHECK_GE</span>(start, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">CHECK_LT</span>(end, layers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">  Dtype loss = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// LOG(ERROR) &lt;&lt; &quot;Forwarding &quot; &lt;&lt; layer_names_[i];</span></span><br><span class=\"line\">    Dtype layer_loss = layers_[i]-&gt;<span class=\"built_in\">Forward</span>(bottom_vecs_[i], top_vecs_[i]);</span><br><span class=\"line\">    loss += layer_loss;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (debug_info_) &#123; <span class=\"built_in\">ForwardDebugInfo</span>(i); &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> loss;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Net&lt;Dtype&gt;::<span class=\"built_in\">BackwardFromTo</span>(<span class=\"type\">int</span> start, <span class=\"type\">int</span> end) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">CHECK_GE</span>(end, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">CHECK_LT</span>(start, layers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = start; i &gt;= end; --i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (layer_need_backward_[i]) &#123;</span><br><span class=\"line\">      layers_[i]-&gt;<span class=\"built_in\">Backward</span>(</span><br><span class=\"line\">          top_vecs_[i], bottom_need_backward_[i], bottom_vecs_[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (debug_info_) &#123; <span class=\"built_in\">BackwardDebugInfo</span>(i); &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##caffe中的Solver\n前面讲到Net通过调用Forward和Backward可以得到每个参数的梯度，而Solver的主要作用就是根据这些梯度进行网络参数的更新。由于caffe将Net作为Solver的底层实现，因此Solver也就成了控制整个训练过程的中枢。Solver提供三个主要函数：Init、Solve、ApplyUpdate。</p>\n<ul>\n<li>Init：创建训练网络和测试网络，初始化一些参数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Solver&lt;Dtype&gt;::<span class=\"built_in\">Init</span>(<span class=\"type\">const</span> SolverParameter&amp; param) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// Scaffolding code</span></span><br><span class=\"line\">  <span class=\"built_in\">InitTrainNet</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Caffe::<span class=\"built_in\">root_solver</span>()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">InitTestNets</span>();</span><br><span class=\"line\">    <span class=\"built_in\">LOG</span>(INFO) &lt;&lt; <span class=\"string\">&quot;Solver scaffolding done.&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  iter_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">  current_step_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Solve：调用Step进行迭代训练，每次迭代后都会调用ApplyUpdate进行参数的更新</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\">Dtype Solver&lt;Dtype&gt;::<span class=\"built_in\">ForwardBackward</span>() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// accumulate the loss and gradient</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; param_.<span class=\"built_in\">iter_size</span>(); ++i) &#123;</span><br><span class=\"line\">    loss += net_-&gt;<span class=\"built_in\">ForwardBackward</span>();\\</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> loss / param_.<span class=\"built_in\">iter_size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Solver&lt;Dtype&gt;::<span class=\"built_in\">Step</span>(<span class=\"type\">int</span> iters) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (iter_ &lt; stop_iter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (param_.<span class=\"built_in\">test_interval</span>() &amp;&amp; iter_ % param_.<span class=\"built_in\">test_interval</span>() == <span class=\"number\">0</span></span><br><span class=\"line\">        &amp;&amp; (iter_ &gt; <span class=\"number\">0</span> || param_.<span class=\"built_in\">test_initialization</span>())</span><br><span class=\"line\">        &amp;&amp; Caffe::<span class=\"built_in\">root_solver</span>()) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">TestAll</span>(); <span class=\"comment\">// 进行测试</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; callbacks_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">      callbacks_[i]-&gt;<span class=\"built_in\">on_start</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Dtype loss = <span class=\"built_in\">ForwardBackward</span>();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">UpdateSmoothedLoss</span>(loss, start_iter, average_loss);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; callbacks_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">      callbacks_[i]-&gt;<span class=\"built_in\">on_gradients_ready</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">param</span>().<span class=\"built_in\">disabled_update</span>()) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">ApplyUpdate</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++iter_;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Solver&lt;Dtype&gt;::<span class=\"built_in\">Solve</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* resume_file) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"built_in\">Step</span>(param_.<span class=\"built_in\">max_iter</span>() - iter_);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ApplyUpdate：调用对应的solver进行参数更新，下面是sgd\nsolver的ApplyUpdate函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solvers/sgd_solver.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> SGDSolver&lt;Dtype&gt;::<span class=\"built_in\">ApplyUpdate</span>() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Dtype rate = <span class=\"built_in\">GetLearningRate</span>(); <span class=\"comment\">//获取当前迭代的学习率</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"built_in\">ClipGradients</span>(); <span class=\"comment\">// 进行梯度规整</span></span><br><span class=\"line\">  <span class=\"comment\">// learnable_params存放的是网络中所有需要学习的参数blobs</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> param_id = <span class=\"number\">0</span>; param_id &lt; <span class=\"keyword\">this</span>-&gt;net_-&gt;<span class=\"built_in\">learnable_params</span>().<span class=\"built_in\">size</span>();</span><br><span class=\"line\">       ++param_id) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">ApplyUpdate</span>(param_id); <span class=\"comment\">// 逐个更新参数</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于梯度下降算法发展出了非常多的优化算法，目前caffe提供了六种优化算法来求解最优参数，在solver配置文件中，通过设置type类型来选择。</p>\n<ul>\n<li>Stochastic Gradient Descent (type: \"SGD\"),</li>\n<li>AdaDelta (type: \"AdaDelta\"),</li>\n<li>Adaptive Gradient (type: \"AdaGrad\"),</li>\n<li>Adam (type: \"Adam\"),</li>\n<li>Nesterov’s Accelerated Gradient (type: \"Nesterov\")</li>\n<li>RMSprop (type: \"RMSProp\")</li>\n</ul>\n<p>##caffe断点保存和恢复\n由于训练过程往往非常耗时，为了能够在突发情况后快速恢复训练，caffe提供了断点保存和恢复的功能，在solver的配置文件中可以配置保存的频率及保存时文件名的前缀，一个比较完整的solver配置文件如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// solver.prototxt</span></span><br><span class=\"line\">net: <span class=\"string\">&quot;./train_val.prototxt&quot;</span>  <span class=\"comment\">// 定义net的protobuf文件</span></span><br><span class=\"line\">test_iter: <span class=\"number\">100</span>   <span class=\"comment\">// 测试的迭代次数，这个需要根据测试数据的大小和测试时的batch size计算得到，test_iter = test_dataset_size / test_batch_size</span></span><br><span class=\"line\">test_interval: <span class=\"number\">1000</span>  <span class=\"comment\">// 设置test的频率，每训练1000次迭代就测试一次</span></span><br><span class=\"line\">base_lr: <span class=\"number\">0.01</span>  <span class=\"comment\">// 设置学习率</span></span><br><span class=\"line\">lr_policy: <span class=\"string\">&quot;step&quot;</span>  <span class=\"comment\">// 设置学习率衰减策略</span></span><br><span class=\"line\">gamma: <span class=\"number\">0.1</span>  <span class=\"comment\">// step衰减因子，</span></span><br><span class=\"line\">stepsize: <span class=\"number\">10000</span> <span class=\"comment\">// 衰减的频率，每训练10000次迭代衰减一次，衰减后的学习率=当前学习率*gamma</span></span><br><span class=\"line\">display: <span class=\"number\">500</span>  <span class=\"comment\">// 训练log打印频率</span></span><br><span class=\"line\">max_iter: <span class=\"number\">45000</span>  <span class=\"comment\">// 设置最大训练多少次迭代</span></span><br><span class=\"line\">type: <span class=\"string\">&quot;SGD&quot;</span>  <span class=\"comment\">// 设置solver类型 </span></span><br><span class=\"line\">momentum: <span class=\"number\">0.9</span>  <span class=\"comment\">// 设置SGD中的动量项</span></span><br><span class=\"line\">weight_decay: <span class=\"number\">0.0005</span>  <span class=\"comment\">// 设置正则系数</span></span><br><span class=\"line\">snapshot: <span class=\"number\">1000</span>  <span class=\"comment\">// 设置模型保存频率</span></span><br><span class=\"line\">snapshot_prefix: <span class=\"string\">&quot;../output/caffe_alexnet_train&quot;</span>  <span class=\"comment\">// 设置模型保存时文件名前缀</span></span><br><span class=\"line\">solver_mode: CPU  <span class=\"comment\">// 设置训练模式，CPU还是GPU</span></span><br></pre></td></tr></table></figure>\n<p>当然还有一些其他的参数，比如正则化类型和模型保存文件格式等，都会使用在proto文件中定义的默认值，具体查看src/caffe/proto/caffe.proto文件中的SolverParameter。</p>\n<p>为了实现断点保存和恢复，caffe在Solver中加入了Snapshot和Restore，分别进行模型保存和模型恢复，相应地，在Net中也加入了ToProto/ToHDF5和CopyTrainedLayersFromBinaryProto/CopyTrainedLayersFromHDF5。Solver调用Step进行训练的时候，每次参数更新结束都会判断是否需要保存模型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp:Step</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((param_.<span class=\"built_in\">snapshot</span>()</span><br><span class=\"line\">     &amp;&amp; iter_ % param_.<span class=\"built_in\">snapshot</span>() == <span class=\"number\">0</span></span><br><span class=\"line\">     &amp;&amp; Caffe::<span class=\"built_in\">root_solver</span>()) ||</span><br><span class=\"line\">     (request == SolverAction::SNAPSHOT)) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Snapshot</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solver中Snapshot对模型参数和训练状态进行保存，模型参数提供两种保存格式——binary\nprotobuf和hdf5。如果是protobuf格式，则会调用Net的ToProto，否则调用ToHDF5。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/net.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Net&lt;Dtype&gt;::<span class=\"built_in\">ToProto</span>(NetParameter* param, <span class=\"type\">bool</span> write_diff) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">  param-&gt;<span class=\"built_in\">Clear</span>();</span><br><span class=\"line\">  param-&gt;<span class=\"built_in\">set_name</span>(name_);</span><br><span class=\"line\">  <span class=\"comment\">// Add bottom and top</span></span><br><span class=\"line\">  <span class=\"built_in\">DLOG</span>(INFO) &lt;&lt; <span class=\"string\">&quot;Serializing &quot;</span> &lt;&lt; layers_.<span class=\"built_in\">size</span>() &lt;&lt; <span class=\"string\">&quot; layers&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; layers_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">    LayerParameter* layer_param = param-&gt;<span class=\"built_in\">add_layer</span>();</span><br><span class=\"line\">    layers_[i]-&gt;<span class=\"built_in\">ToProto</span>(layer_param, write_diff);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solver在开始训练时会尝试调用Restore进行断点恢复，根据文件名后缀判断文件格式，并选择RestoreSolverStateFromHDF5还是RestoreSolverStateFromBinaryProto。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp:Solve</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (resume_file) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">LOG</span>(INFO) &lt;&lt; <span class=\"string\">&quot;Restoring previous solver status from &quot;</span> &lt;&lt; resume_file;</span><br><span class=\"line\">  <span class=\"built_in\">Restore</span>(resume_file);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##in-place计算\n为了节约显存，caffe支持原址计算，就是输入与输出都是同一个blob。如果前一层的输出和本层的输入都与后向计算时无关，而且本层的输入和输出blob大小相同，就可以使用in-place计算，比如卷积层后面的Sigmoid、Relu等都可以用同址计算，而BatchNorm层也支持in-place计算，是因为BatchNorm在实现时会将输入数据进行备份。使用同址计算只要在protobuf文件中指定该层的top和bottom是同名的就可以了，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layer &#123;</span><br><span class=\"line\">        bottom: <span class=\"string\">&quot;conv1&quot;</span></span><br><span class=\"line\">        top: <span class=\"string\">&quot;conv1&quot;</span></span><br><span class=\"line\">        name: <span class=\"string\">&quot;conv1_relu&quot;</span></span><br><span class=\"line\">        type: <span class=\"string\">&quot;ReLU&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##参数初始化方法\n由于神经网络的目标函数往往是非凸的，参数初始化会对最终的收敛结果造成非常大的影响。为了满足不同的参数初始化需求，caffe提供了多种初始化方法，并且在net的配置文件中可以为每个参数选择一个初始化方法。比如下面的weight_filler和bias_filler：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layer &#123;</span><br><span class=\"line\">        bottom: <span class=\"string\">&quot;data&quot;</span></span><br><span class=\"line\">        top: <span class=\"string\">&quot;conv1&quot;</span></span><br><span class=\"line\">        name: <span class=\"string\">&quot;conv1&quot;</span></span><br><span class=\"line\">        type: <span class=\"string\">&quot;Convolution&quot;</span></span><br><span class=\"line\">        convolution_param &#123;</span><br><span class=\"line\">                num_output: <span class=\"number\">64</span></span><br><span class=\"line\">                kernel_size: <span class=\"number\">7</span></span><br><span class=\"line\">                pad: <span class=\"number\">3</span></span><br><span class=\"line\">                stride: <span class=\"number\">2</span></span><br><span class=\"line\">                weight_filler &#123;</span><br><span class=\"line\">                  type: <span class=\"string\">&quot;xavier&quot;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                bias_filler &#123;</span><br><span class=\"line\">                  type: <span class=\"string\">&quot;constant&quot;</span></span><br><span class=\"line\">                  value: <span class=\"number\">0.2</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在include/caffe/filler.hpp中caffe提供如下的初始化方法：</p>\n<ul>\n<li>constant：常量初始化，参数所有的值都被初始化为相同的值</li>\n<li>uniform：均匀初始化，参数的值按照指定区间均匀分布随机初始化</li>\n<li>gaussian：高斯初始化，参数的值按照指定均值和方差的正态分布随机初始化</li>\n<li>positive unitball</li>\n<li>xavier：本质上也是一种指定区间均匀分布的随机初始化方式，只是区间是通过参数大小计算得到</li>\n<li>msra：与xavier类似，不过使用的是指定均值和方差的正态分布随机初始化方式</li>\n<li>bilinear</li>\n</ul>\n<p>##多卡并行策略\n为了提高效率，caffe支持单机多GPU并行训练，目前采用的是数据并行方式，暂不支持模型并行，为此caffe增加了一个P2PSync类，下面主要介绍一下P2PSync如何实现多卡并行的。</p>\n<p>P2PSync封装了一个Solver负责训练，每张GPU都会对应一个P2PSync，并且P2PSync之间具有主从关系，它们之间构成一个二叉树的结构。在前向计算时，主P2PSync需要将模型分发给从P2PSync，而在后向传导时，从P2PSync就需要把梯度传给主P2PSync，主P2PSync会在聚合从P2PSync的梯度后传给更上一层的主P2PSync。在二叉树结构中，根节点P2PSync的Solver被叫做root\nsolver，其他solver叫做worker solver，只有root\nsolver才能进行参数更新，worker solver只是将梯度聚合并传递给root\nsolver。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/caffe框架学习/caffe-005.jpg?raw=true width=720>\n</div>\n<p>在P2PSync中主要的函数就InternalThreadEntry、on_start和on_gradients_ready。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/parallel.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> P2PSync&lt;Dtype&gt;::<span class=\"built_in\">InternalThreadEntry</span>() &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"> solver_-&gt;<span class=\"built_in\">Step</span>(solver_-&gt;<span class=\"built_in\">param</span>().<span class=\"built_in\">max_iter</span>() - initial_iter_);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>InternalThreadEntry是一个线程函数，Solver调用Step进行训练，在Step中每次前向计算前都会回调on_start获取最新模型，而在后向计算结束后又会回调on_gradients_ready传递梯度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/caffe/solver.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> Solver&lt;Dtype&gt;::<span class=\"built_in\">Step</span>(<span class=\"type\">int</span> iters) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (iter_ &lt; stop_iter) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; callbacks_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\"> callbacks_[i]-&gt;<span class=\"built_in\">on_start</span>(); <span class=\"comment\">// 回调P2PSync中的on_start，从主P2PSync获取新模型</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> Dtype loss = <span class=\"built_in\">Forward_backward</span>();</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; callbacks_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\"> callbacks_[i]-&gt;<span class=\"built_in\">on_gradients_ready</span>(); <span class=\"comment\">// 回调P2PSync中的on_gradients_ready，依次聚合从P2PSync和自身的梯度，并将梯度发送给主P2PSync</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!<span class=\"built_in\">param</span>().<span class=\"built_in\">disabled_update</span>()) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">ApplyUpdate</span>(); <span class=\"comment\">// 这里只有root solver才会进行参数更新</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> P2PSync&lt;Dtype&gt;::<span class=\"built_in\">on_start</span>() &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CPU_ONLY</span></span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"comment\">// Wait for update from parent</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (parent_) &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 除了root solver，其他worker solver都有对应的parent</span></span><br><span class=\"line\"><span class=\"comment\">      程序执行到这里时会阻塞，当主P2PSync将自身入队后就会通知从P2PSync，pop就能返回</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">   P2PSync&lt;Dtype&gt; *parent = queue_.<span class=\"built_in\">pop</span>(); <span class=\"comment\">// 等待主P2PSync入队</span></span><br><span class=\"line\">   <span class=\"built_in\">CHECK</span>(parent == parent_);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">// Update children</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = children_.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">   Dtype* src = data_;</span><br><span class=\"line\">   Dtype* dst = children_[i]-&gt;data_;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"comment\">// 主P2PSync将模型直接拷贝给从P2PSync</span></span><br><span class=\"line\">   <span class=\"built_in\">CUDA_CHECK</span>(<span class=\"built_in\">cudaMemcpyAsync</span>(dst, src, size_ * <span class=\"built_in\">sizeof</span>(Dtype),</span><br><span class=\"line\">   cudaMemcpyDeviceToDevice, cudaStreamDefault));</span><br><span class=\"line\">   <span class=\"built_in\">CUDA_CHECK</span>(<span class=\"built_in\">cudaStreamSynchronize</span>(cudaStreamDefault));</span><br><span class=\"line\">   <span class=\"comment\">// 主P2PSync将自身入队，并通知从P2PSync</span></span><br><span class=\"line\">   children_[i]-&gt;queue_.<span class=\"built_in\">push</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Dtype&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> P2PSync&lt;Dtype&gt;::<span class=\"built_in\">on_gradients_ready</span>() &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CPU_ONLY</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// Sum children gradients as they appear in the queue</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; children_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">    P2PSync&lt;Dtype&gt; *child = queue_.<span class=\"built_in\">pop</span>(); <span class=\"comment\">// 等待从P2PSync入队</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于parent_grads_是在主P2PSync设备上开辟的一块缓冲区，因此child-&gt;parent_grads_其实就是当前设备上的缓冲区</span></span><br><span class=\"line\">    Dtype* src = child-&gt;parent_grads_; <span class=\"comment\">// 获取从P2PSync的梯度</span></span><br><span class=\"line\">    Dtype* dst = diff_;</span><br><span class=\"line\">    <span class=\"comment\">// 合并从P2PSync的梯度</span></span><br><span class=\"line\">    <span class=\"built_in\">caffe_gpu_add</span>(size_, src, dst, dst);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// Send gradients to parent</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent_) &#123;</span><br><span class=\"line\">    Dtype* src = diff_;</span><br><span class=\"line\">    Dtype* dst = parent_grads_; </span><br><span class=\"line\">    <span class=\"comment\">// 从P2PSync将梯度复制到主P2PSync的缓冲区</span></span><br><span class=\"line\">    <span class=\"built_in\">CUDA_CHECK</span>(<span class=\"built_in\">cudaMemcpyAsync</span>(dst, src, size_ * <span class=\"built_in\">sizeof</span>(Dtype),  <span class=\"comment\">//</span></span><br><span class=\"line\">        cudaMemcpyDeviceToDevice, cudaStreamDefault));</span><br><span class=\"line\">    <span class=\"built_in\">CUDA_CHECK</span>(<span class=\"built_in\">cudaStreamSynchronize</span>(cudaStreamDefault));</span><br><span class=\"line\">    <span class=\"comment\">// 自身入队，通知主P2PSync</span></span><br><span class=\"line\">    parent_-&gt;queue_.<span class=\"built_in\">push</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Loss functions divide gradients by the batch size, so to compensate</span></span><br><span class=\"line\">    <span class=\"comment\">// for split batch, the root solver divides by number of solvers.</span></span><br><span class=\"line\">    <span class=\"built_in\">caffe_gpu_scal</span>(size_, <span class=\"built_in\">Dtype</span>(<span class=\"number\">1.0</span> / Caffe::<span class=\"built_in\">solver_count</span>()), diff_);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>##intel caffe多机并行策略\n单机多卡的训练方式已经足够解决目前大部分模型训练的需求了，但随着数据量越来越大、模型越来越复杂，分布式异构计算成为行业通行的解决方案。BVLC\ncaffe是不支持分布式训练的，intel有两个部门将caffe进行了再次开发以支持分布式和最新的Intel\nMKL-DNN，分别为intel caffe和caffe multinode。目前BML API已经支持intel\ncaffe的模型训练、评估和预测了。</p>\n<p>intel caffe采用的是数据并行的方式，但不同于目前主流的centralized\nparameter server通信模型，intel\ncaffe借鉴了单机多卡的策略，采用的是一种all-reduce的binary\ntree模型，也就是将节点按照二叉树组织起来，每个父节点负责1-2个子节点和自己父节点的通信，相比一个中心的PS需要同时与其他多个节点通信的方式，这种binary\ntree方式将一部分PS的计算平均到了每个节点上，而且相同level的父节点之间可以并行，增加了梯度合并的并行度。</p>\n<p>[待图]</p>\n<p>为了更好地掩盖通信开销，子节点不需要等到整个模型的梯度都计算完才发送，而是每个layer计算完梯度后就会立即发送给父节点，父节点收到所有子节点的梯度后将本层的梯度合并后也可以立即发送给上一层的父节点。每个layer的参数会按照buffer的大小分成多个part，每个part都会异步地进行发送，当进行下一次迭代时，除了根节点的所有节点都会被阻塞，等待根节点将最终的梯度进行合并，并更新模型后发送给子节点。</p>\n<p>除了分层通信外，intel\ncaffe也支持梯度量化压缩，可以将全精浮点数编码成指定字节数的数值，减少节点间通信量。</p>\n<p>intel\ncaffe为了支持多种协议的通信，使用了boost的asio::io_service接口，底层实现支持MPI、TCP和UDP，不过目前只实现了MPI接口。</p>\n<p>训练时交叉验证是在单节点(准确来说是根节点)上进行的，但每个节点上都需要存在验证集文件，这是因为即使不进行test，其他节点也会初始化test网络。</p>\n<p>##实战</p>\n<p>##参考 贾扬清自述http://www.yangfenzi.com/keji/59535.html<br />\ncaffe官网http://caffe.berkeleyvision.org<br />\nhttp://ucb-icsi-vision-group.github.io/caffe-paper/caffe.pdf<br />\nhttps://www.zhihu.com/question/27982282<br />\nhttp://blog.csdn.net/myarrow/article/details/52064608</p>"},{"title":"C++调用python","date":"2017-07-03T04:31:08.000Z","_content":"\n\n由于需要在组内新开发的一套机器学习框架上开发一个强化学习的demo，但目前开源的一些游戏环境都只提供了python接口，比如Gym。如果要使用Gym去做在线训练的话，就需要在C++代码中调用Python接口，因此找了些例子学习了一下如何使用Python C API。当然Python C API不是唯一的方式，也可以使用boost的Python模块，有时间再研究。\n\n<!-- more -->\n\n## hello python\n\n```c++\n#include <stdio.h>\n#include <iostream>\n#include \"python/Python.h\"\n\nint main() {\n    Py_Initialize();\n    std::cout << \"hello c++!\" << std::endl;\n    PyRun_SimpleString(\"print 'hello python!'\");\n    Py_Finalize();\n    return 0;\n}\n```\n\n编译：\n\n```txt\ng++ test.cpp -o test -lpython\n```\n\n执行：./test\n\n```txt\nhello c++!\nhello python!\n```\n\n\n\n## 调用python脚本中的函数\n\n```python\n# test_add.py\ndef add(a, b):\n    return a+b\n```\n\n```c++\n#include <stdio.h>\n#include <iostream>\n#include \"python/Python.h\"\n\nint main(int argc, char* argv[]) {\n    if (argc < 3) {\n        std::cerr << \"Usage: ./exe integer1 integer2\" << std::endl;\n        return 1;\n    }\n    std::cerr << \"hello c++!\" << std::endl;\n\n    Py_Initialize();\n    PyRun_SimpleString(\"import sys\");\n    PyRun_SimpleString(\"sys.path.append('./')\");\n\n    PyRun_SimpleString(\"print 'hello python!'\");\n    PyObject* moduleName = PyString_FromString(\"test_add\");\n    PyObject* pModule = PyImport_Import(moduleName);\n    if (!pModule) {\n        std::cerr << \"[ERROR] Python get module failed.\" << std::endl;\n        return 1;\n    }\n    PyObject* pv = PyObject_GetAttrString(pModule, \"add\");\n    if (!pv || !PyCallable_Check(pv)) {\n        std::cerr << \"[ERROR] Can't find function (add)\" << std::endl;\n        return 1;\n    }\n\n    PyObject* args = PyTuple_New(2);\n    PyObject* arg1 = PyInt_FromLong(atoi(argv[1]));\n    PyObject* arg2 = PyInt_FromLong(atoi(argv[2]));\n    PyTuple_SetItem(args, 0, arg1);\n    PyTuple_SetItem(args, 1, arg2);\n\n    PyObject* pRet = PyObject_CallObject(pv, args);\n    if (!pRet) {\n        std::cerr << \"[ERROR] Call funftion (add) failed\" << std::endl;\n        return 1;\n    }\n    long result = PyInt_AsLong(pRet);\n    std::cout << \"result: \" << result << std::endl;\n\n    Py_Finalize();\n    return 0;\n}\n```\n\n编译：\n\n```txt\ng++ test.cpp -o test -lpython\n```\n\n执行：./test 3 4\n\n```txt\nhello c++!\nhello python!\nresult: 7\n```\n\n\n\n## Q学习的一个例子\n\n```python\n# tree.py\n\"\"\"\nauthor: Houjiang Chen\n\"\"\"\nimport random\n\nclass q_learning:\n    def __init__(self, states, actions):\n        self.states = states\n        self.actions = actions\n        self.eps = 0.1\n        self.alpha = 0.1\n        self.q_table = [[0 for j in range(actions)] for i in range(states)]\n\n    def get_action(self, current_state):\n        max_action = self.q_table[current_state].index(max(self.q_table[current_state]))\n        if random.uniform(0, 1) > self.eps:\n            return max_action\n        else:\n            rest = [i for i in range(len(self.q_table[current_state])) if i != max_action]\n            index = random.randint(0, len(rest) - 1)\n            return rest[index]\n\n    def update(self, current_state, action, next_state, reward, final):\n        if not final:\n            reward = reward + max(self.q_table[next_state])\n        self.q_table[current_state][action] += self.alpha * (reward - self.q_table[current_state][action])\n\n\nclass environment:\n    def __init__(self):\n        self.level = 2\n        self.actions = 2\n        self.states = self.actions ** (self.level + 1) - 1\n        self.final_states = self.actions ** self.level\n        self.reward = {0 : [10, -10], 1 : [50, 100], 2 : [100, 150]}\n\n    def next(self, current_state, action):\n        \"\"\"action: 0 or 1\n           return: next_state reward, is_final\n        \"\"\"\n        next = 2 * current_state + (action + 1)\n        if next >= self.states - self.final_states:\n            return None, self.reward[current_state][action], True\n        else:\n            return next, self.reward[current_state][action], False\n\n    def reset(self):\n        return random.randint(0, self.states - self.final_states - 1)\n\n\ndef main():\n    env = environment()\n    agent = q_learning(env.states, env.actions)\n\n    episode = 0\n    while episode < 10000:\n        episode += 1\n        print \"episode: %d\" % episode\n        current_state = env.reset()\n        while True:\n            action = agent.get_action(current_state)\n            next_state, reward, final = env.next(current_state, action)\n            agent.update(current_state, action, next_state, reward, final)\n            if final:\n                break\n            current_state = next_state\n\n    print agent.q_table\n\nif __name__ == '__main__':\n    main()\n```\n\n\n\n```c++\n#include <stdio.h>\n#include <iostream>\n#include \"python2.7/Python.h\"\n\nPyObject* New_PyInstance(PyObject* cls, PyObject* args) {\n    PyObject* pInstance = PyInstance_New(cls, args, NULL);\n    if (!pInstance) {\n        std::cerr << \"new instance failed\" << std::endl;\n        exit(1);\n    }\n    return pInstance;\n}\n\nint main(int argc, char* argv[]) {\n    Py_Initialize();\n    PyRun_SimpleString(\"import sys\");\n    PyRun_SimpleString(\"sys.path.append('./')\");\n\n    PyObject* moduleName = PyString_FromString(\"tree\");\n    PyObject* pModule = PyImport_Import(moduleName);\n    if (!pModule) {\n        std::cerr << \"[ERROR] Python get module failed.\" << std::endl;\n        return 1;\n    }\n    PyObject* pEnv = PyObject_GetAttrString(pModule, \"environment\");\n    if (!pEnv) {\n        std::cerr << \"[ERROR] Can't find class (environment)\" << std::endl;\n        return 1;\n    }\n\n    PyObject* pEnvObject = New_PyInstance(pEnv, NULL);\n    PyObject* pEnvLevel = PyObject_GetAttrString(pEnvObject, \"level\");\n    if (!pEnvLevel) {\n        std::cerr << \"[ERROR] Env has no attr level\" << std::endl;\n        return 1;\n    }\n    PyObject* pEnvActions = PyObject_GetAttrString(pEnvObject, \"actions\");\n    PyObject* pEnvStates = PyObject_GetAttrString(pEnvObject, \"states\");\n    PyObject* pEnvFinalState = PyObject_GetAttrString(pEnvObject, \"final_states\");\n\n    int level = PyInt_AsLong(pEnvLevel);\n    int actions = PyInt_AsLong(pEnvActions);\n    int states = PyInt_AsLong(pEnvStates);\n    int final_state = PyInt_AsLong(pEnvFinalState);\n\n    std::cout << \"env level: \" << level << std::endl;\n    std::cout << \"env actions: \" << actions << std::endl;\n    std::cout << \"env states: \" << states << std::endl;\n    std::cout << \"env final_state: \" << final_state << std::endl;\n\n    PyObject* pLearn = PyObject_GetAttrString(pModule, \"q_learning\");\n    PyObject* pLearnArgs = Py_BuildValue(\"ii\", states, actions);\n    PyObject* pLearnObject = New_PyInstance(pLearn, pLearnArgs);\n    PyObject* pLearnStates = PyObject_GetAttrString(pLearnObject, \"states\");\n    PyObject* pLearnActions = PyObject_GetAttrString(pLearnObject, \"actions\");\n    PyObject* pLearnEps = PyObject_GetAttrString(pLearnObject, \"eps\");\n\n    int learn_states = PyInt_AsLong(pLearnStates);\n    int learn_actions = PyInt_AsLong(pLearnActions);\n    float learn_eps = PyFloat_AsDouble(pLearnEps);\n\n    std::cout << \"learn_states: \" << learn_states << std::endl;\n    std::cout << \"learn_actions: \" << learn_actions << std::endl;\n    std::cout << \"learn_eps: \" << learn_eps << std::endl;\n\n    PyObject* pEnvResetFunc = PyObject_GetAttrString(pEnvObject, \"reset\");\n    PyObject* pEnvNextFunc = PyObject_GetAttrString(pEnvObject, \"next\");\n    PyObject* pLearnGetActionFunc = PyObject_GetAttrString(pLearnObject, \"get_action\");\n    PyObject* pLearnUpdateFunc = PyObject_GetAttrString(pLearnObject, \"update\");\n    if (!pEnvNextFunc) {\n        std::cerr << \"[ERROR] env has no function named next\" << std::endl;\n        return 1;\n    }\n\n    std::cout << std::endl;\n    uint64_t episode = 0;\n    for (episode = 0; episode < 10000; ++episode) {\n        if (episode % 100 == 0)\n            std::cout << \"episode: \" << episode << std::endl;\n        PyObject* current_state = PyEval_CallObject(pEnvResetFunc, NULL);\n        while (true) {\n            PyObject* args1 = PyTuple_New(1);\n            PyObject* args2 = PyTuple_New(2);\n            PyTuple_SetItem(args1, 0, current_state);\n            PyObject* action = PyEval_CallObject(pLearnGetActionFunc, args1);\n            PyTuple_SetItem(args2, 0, current_state);\n            PyTuple_SetItem(args2, 1, action);\n            PyObject* ret = PyEval_CallObject(pEnvNextFunc, args2);\n            PyObject* next_state = PyTuple_GetItem(ret, 0);\n            PyObject* final = PyTuple_GetItem(ret ,2);\n            PyObject* args3 = PyTuple_New(5);\n            PyTuple_SetItem(args3, 0, current_state);\n            PyTuple_SetItem(args3, 1, action);\n            PyTuple_SetItem(args3, 2, next_state);\n            PyTuple_SetItem(args3, 3, PyTuple_GetItem(ret, 1));\n            PyTuple_SetItem(args3, 4, final);\n\n            PyEval_CallObject(pLearnUpdateFunc, args3);\n            if (PyObject_IsTrue(final)) {\n                break;\n            }\n            current_state = next_state;\n            if (args3)\n                Py_DECREF(args3);\n        }\n    }\n    PyObject* pLearnQTable = PyObject_GetAttrString(pLearnObject, \"q_table\");\n    for (int i = 0; i < PyList_Size(pLearnQTable); ++i) {\n        std::cout << \"state \" << i << std::endl;\n        PyObject* term = PyList_GetItem(pLearnQTable, i);\n        if (PyList_Check(term)) {\n            for (int j = 0; j < PyList_Size(term); ++j) {\n                std::cout << \"    direct: \" << j << \", \" << \"Qvalue: \"\n                          << PyFloat_AsDouble(PyList_GetItem(term, j)) << std::endl;\n            }\n        }\n    }\n    Py_Finalize();\n    return 0;\n}\n```\n\n编译：\n\n```txt\ng++ test.cpp -o test -I../python2.7.12/include -L../python2.7.12/lib -lpython2.7\n```\n\n执行：./test\n\n```txt\nenv level: 2\nenv actions: 2\nenv states: 7\nenv final_state: 4\nlearn_states: 7\nlearn_actions: 2\nlearn_eps: 0.1\n\nepisode: 0\nepisode: 100\nepisode: 200\nepisode: 300\nepisode: 400\nepisode: 500\nepisode: 600\nepisode: 700\nepisode: 800\nepisode: 900\nepisode: 1000\nepisode: 1100\nepisode: 1200\nepisode: 1300\nepisode: 1400\nepisode: 1500\nepisode: 1600\nepisode: 1700\nepisode: 1800\nepisode: 1900\nepisode: 2000\nepisode: 2100\nepisode: 2200\nepisode: 2300\nepisode: 2400\nepisode: 2500\nepisode: 2600\nepisode: 2700\nepisode: 2800\nepisode: 2900\nepisode: 3000\nepisode: 3100\nepisode: 3200\nepisode: 3300\nepisode: 3400\nepisode: 3500\nepisode: 3600\nepisode: 3700\nepisode: 3800\nepisode: 3900\nepisode: 4000\nepisode: 4100\nepisode: 4200\nepisode: 4300\nepisode: 4400\nepisode: 4500\nepisode: 4600\nepisode: 4700\nepisode: 4800\nepisode: 4900\nepisode: 5000\nepisode: 5100\nepisode: 5200\nepisode: 5300\nepisode: 5400\nepisode: 5500\nepisode: 5600\nepisode: 5700\nepisode: 5800\nepisode: 5900\nepisode: 6000\nepisode: 6100\nepisode: 6200\nepisode: 6300\nepisode: 6400\nepisode: 6500\nepisode: 6600\nepisode: 6700\nepisode: 6800\nepisode: 6900\nepisode: 7000\nepisode: 7100\nepisode: 7200\nepisode: 7300\nepisode: 7400\nepisode: 7500\nepisode: 7600\nepisode: 7700\nepisode: 7800\nepisode: 7900\nepisode: 8000\nepisode: 8100\nepisode: 8200\nepisode: 8300\nepisode: 8400\nepisode: 8500\nepisode: 8600\nepisode: 8700\nepisode: 8800\nepisode: 8900\nepisode: 9000\nepisode: 9100\nepisode: 9200\nepisode: 9300\nepisode: 9400\nepisode: 9500\nepisode: 9600\nepisode: 9700\nepisode: 9800\nepisode: 9900\nstate 0\n    direct: 0, Qvalue: 110\n    direct: 1, Qvalue: 140\nstate 1\n    direct: 0, Qvalue: 50\n    direct: 1, Qvalue: 100\nstate 2\n    direct: 0, Qvalue: 100\n    direct: 1, Qvalue: 150\nstate 3\n    direct: 0, Qvalue: 0\n    direct: 1, Qvalue: 0\nstate 4\n    direct: 0, Qvalue: 0\n    direct: 1, Qvalue: 0\nstate 5\n    direct: 0, Qvalue: 0\n    direct: 1, Qvalue: 0\nstate 6\n    direct: 0, Qvalue: 0\n    direct: 1, Qvalue: 0\n```\n\n\n\n## 参考资料\n\nPython/C API Reference Manual:  https://docs.python.org/2/c-api/index.html\n","source":"_posts/C++调用Python接口.md","raw":"---\ntitle: C++调用python\ndate: 2017-07-3 12:31:08\ncategory: code\ntags: [c++, python, embedding]\n---\n\n\n由于需要在组内新开发的一套机器学习框架上开发一个强化学习的demo，但目前开源的一些游戏环境都只提供了python接口，比如Gym。如果要使用Gym去做在线训练的话，就需要在C++代码中调用Python接口，因此找了些例子学习了一下如何使用Python C API。当然Python C API不是唯一的方式，也可以使用boost的Python模块，有时间再研究。\n\n<!-- more -->\n\n## hello python\n\n```c++\n#include <stdio.h>\n#include <iostream>\n#include \"python/Python.h\"\n\nint main() {\n    Py_Initialize();\n    std::cout << \"hello c++!\" << std::endl;\n    PyRun_SimpleString(\"print 'hello python!'\");\n    Py_Finalize();\n    return 0;\n}\n```\n\n编译：\n\n```txt\ng++ test.cpp -o test -lpython\n```\n\n执行：./test\n\n```txt\nhello c++!\nhello python!\n```\n\n\n\n## 调用python脚本中的函数\n\n```python\n# test_add.py\ndef add(a, b):\n    return a+b\n```\n\n```c++\n#include <stdio.h>\n#include <iostream>\n#include \"python/Python.h\"\n\nint main(int argc, char* argv[]) {\n    if (argc < 3) {\n        std::cerr << \"Usage: ./exe integer1 integer2\" << std::endl;\n        return 1;\n    }\n    std::cerr << \"hello c++!\" << std::endl;\n\n    Py_Initialize();\n    PyRun_SimpleString(\"import sys\");\n    PyRun_SimpleString(\"sys.path.append('./')\");\n\n    PyRun_SimpleString(\"print 'hello python!'\");\n    PyObject* moduleName = PyString_FromString(\"test_add\");\n    PyObject* pModule = PyImport_Import(moduleName);\n    if (!pModule) {\n        std::cerr << \"[ERROR] Python get module failed.\" << std::endl;\n        return 1;\n    }\n    PyObject* pv = PyObject_GetAttrString(pModule, \"add\");\n    if (!pv || !PyCallable_Check(pv)) {\n        std::cerr << \"[ERROR] Can't find function (add)\" << std::endl;\n        return 1;\n    }\n\n    PyObject* args = PyTuple_New(2);\n    PyObject* arg1 = PyInt_FromLong(atoi(argv[1]));\n    PyObject* arg2 = PyInt_FromLong(atoi(argv[2]));\n    PyTuple_SetItem(args, 0, arg1);\n    PyTuple_SetItem(args, 1, arg2);\n\n    PyObject* pRet = PyObject_CallObject(pv, args);\n    if (!pRet) {\n        std::cerr << \"[ERROR] Call funftion (add) failed\" << std::endl;\n        return 1;\n    }\n    long result = PyInt_AsLong(pRet);\n    std::cout << \"result: \" << result << std::endl;\n\n    Py_Finalize();\n    return 0;\n}\n```\n\n编译：\n\n```txt\ng++ test.cpp -o test -lpython\n```\n\n执行：./test 3 4\n\n```txt\nhello c++!\nhello python!\nresult: 7\n```\n\n\n\n## Q学习的一个例子\n\n```python\n# tree.py\n\"\"\"\nauthor: Houjiang Chen\n\"\"\"\nimport random\n\nclass q_learning:\n    def __init__(self, states, actions):\n        self.states = states\n        self.actions = actions\n        self.eps = 0.1\n        self.alpha = 0.1\n        self.q_table = [[0 for j in range(actions)] for i in range(states)]\n\n    def get_action(self, current_state):\n        max_action = self.q_table[current_state].index(max(self.q_table[current_state]))\n        if random.uniform(0, 1) > self.eps:\n            return max_action\n        else:\n            rest = [i for i in range(len(self.q_table[current_state])) if i != max_action]\n            index = random.randint(0, len(rest) - 1)\n            return rest[index]\n\n    def update(self, current_state, action, next_state, reward, final):\n        if not final:\n            reward = reward + max(self.q_table[next_state])\n        self.q_table[current_state][action] += self.alpha * (reward - self.q_table[current_state][action])\n\n\nclass environment:\n    def __init__(self):\n        self.level = 2\n        self.actions = 2\n        self.states = self.actions ** (self.level + 1) - 1\n        self.final_states = self.actions ** self.level\n        self.reward = {0 : [10, -10], 1 : [50, 100], 2 : [100, 150]}\n\n    def next(self, current_state, action):\n        \"\"\"action: 0 or 1\n           return: next_state reward, is_final\n        \"\"\"\n        next = 2 * current_state + (action + 1)\n        if next >= self.states - self.final_states:\n            return None, self.reward[current_state][action], True\n        else:\n            return next, self.reward[current_state][action], False\n\n    def reset(self):\n        return random.randint(0, self.states - self.final_states - 1)\n\n\ndef main():\n    env = environment()\n    agent = q_learning(env.states, env.actions)\n\n    episode = 0\n    while episode < 10000:\n        episode += 1\n        print \"episode: %d\" % episode\n        current_state = env.reset()\n        while True:\n            action = agent.get_action(current_state)\n            next_state, reward, final = env.next(current_state, action)\n            agent.update(current_state, action, next_state, reward, final)\n            if final:\n                break\n            current_state = next_state\n\n    print agent.q_table\n\nif __name__ == '__main__':\n    main()\n```\n\n\n\n```c++\n#include <stdio.h>\n#include <iostream>\n#include \"python2.7/Python.h\"\n\nPyObject* New_PyInstance(PyObject* cls, PyObject* args) {\n    PyObject* pInstance = PyInstance_New(cls, args, NULL);\n    if (!pInstance) {\n        std::cerr << \"new instance failed\" << std::endl;\n        exit(1);\n    }\n    return pInstance;\n}\n\nint main(int argc, char* argv[]) {\n    Py_Initialize();\n    PyRun_SimpleString(\"import sys\");\n    PyRun_SimpleString(\"sys.path.append('./')\");\n\n    PyObject* moduleName = PyString_FromString(\"tree\");\n    PyObject* pModule = PyImport_Import(moduleName);\n    if (!pModule) {\n        std::cerr << \"[ERROR] Python get module failed.\" << std::endl;\n        return 1;\n    }\n    PyObject* pEnv = PyObject_GetAttrString(pModule, \"environment\");\n    if (!pEnv) {\n        std::cerr << \"[ERROR] Can't find class (environment)\" << std::endl;\n        return 1;\n    }\n\n    PyObject* pEnvObject = New_PyInstance(pEnv, NULL);\n    PyObject* pEnvLevel = PyObject_GetAttrString(pEnvObject, \"level\");\n    if (!pEnvLevel) {\n        std::cerr << \"[ERROR] Env has no attr level\" << std::endl;\n        return 1;\n    }\n    PyObject* pEnvActions = PyObject_GetAttrString(pEnvObject, \"actions\");\n    PyObject* pEnvStates = PyObject_GetAttrString(pEnvObject, \"states\");\n    PyObject* pEnvFinalState = PyObject_GetAttrString(pEnvObject, \"final_states\");\n\n    int level = PyInt_AsLong(pEnvLevel);\n    int actions = PyInt_AsLong(pEnvActions);\n    int states = PyInt_AsLong(pEnvStates);\n    int final_state = PyInt_AsLong(pEnvFinalState);\n\n    std::cout << \"env level: \" << level << std::endl;\n    std::cout << \"env actions: \" << actions << std::endl;\n    std::cout << \"env states: \" << states << std::endl;\n    std::cout << \"env final_state: \" << final_state << std::endl;\n\n    PyObject* pLearn = PyObject_GetAttrString(pModule, \"q_learning\");\n    PyObject* pLearnArgs = Py_BuildValue(\"ii\", states, actions);\n    PyObject* pLearnObject = New_PyInstance(pLearn, pLearnArgs);\n    PyObject* pLearnStates = PyObject_GetAttrString(pLearnObject, \"states\");\n    PyObject* pLearnActions = PyObject_GetAttrString(pLearnObject, \"actions\");\n    PyObject* pLearnEps = PyObject_GetAttrString(pLearnObject, \"eps\");\n\n    int learn_states = PyInt_AsLong(pLearnStates);\n    int learn_actions = PyInt_AsLong(pLearnActions);\n    float learn_eps = PyFloat_AsDouble(pLearnEps);\n\n    std::cout << \"learn_states: \" << learn_states << std::endl;\n    std::cout << \"learn_actions: \" << learn_actions << std::endl;\n    std::cout << \"learn_eps: \" << learn_eps << std::endl;\n\n    PyObject* pEnvResetFunc = PyObject_GetAttrString(pEnvObject, \"reset\");\n    PyObject* pEnvNextFunc = PyObject_GetAttrString(pEnvObject, \"next\");\n    PyObject* pLearnGetActionFunc = PyObject_GetAttrString(pLearnObject, \"get_action\");\n    PyObject* pLearnUpdateFunc = PyObject_GetAttrString(pLearnObject, \"update\");\n    if (!pEnvNextFunc) {\n        std::cerr << \"[ERROR] env has no function named next\" << std::endl;\n        return 1;\n    }\n\n    std::cout << std::endl;\n    uint64_t episode = 0;\n    for (episode = 0; episode < 10000; ++episode) {\n        if (episode % 100 == 0)\n            std::cout << \"episode: \" << episode << std::endl;\n        PyObject* current_state = PyEval_CallObject(pEnvResetFunc, NULL);\n        while (true) {\n            PyObject* args1 = PyTuple_New(1);\n            PyObject* args2 = PyTuple_New(2);\n            PyTuple_SetItem(args1, 0, current_state);\n            PyObject* action = PyEval_CallObject(pLearnGetActionFunc, args1);\n            PyTuple_SetItem(args2, 0, current_state);\n            PyTuple_SetItem(args2, 1, action);\n            PyObject* ret = PyEval_CallObject(pEnvNextFunc, args2);\n            PyObject* next_state = PyTuple_GetItem(ret, 0);\n            PyObject* final = PyTuple_GetItem(ret ,2);\n            PyObject* args3 = PyTuple_New(5);\n            PyTuple_SetItem(args3, 0, current_state);\n            PyTuple_SetItem(args3, 1, action);\n            PyTuple_SetItem(args3, 2, next_state);\n            PyTuple_SetItem(args3, 3, PyTuple_GetItem(ret, 1));\n            PyTuple_SetItem(args3, 4, final);\n\n            PyEval_CallObject(pLearnUpdateFunc, args3);\n            if (PyObject_IsTrue(final)) {\n                break;\n            }\n            current_state = next_state;\n            if (args3)\n                Py_DECREF(args3);\n        }\n    }\n    PyObject* pLearnQTable = PyObject_GetAttrString(pLearnObject, \"q_table\");\n    for (int i = 0; i < PyList_Size(pLearnQTable); ++i) {\n        std::cout << \"state \" << i << std::endl;\n        PyObject* term = PyList_GetItem(pLearnQTable, i);\n        if (PyList_Check(term)) {\n            for (int j = 0; j < PyList_Size(term); ++j) {\n                std::cout << \"    direct: \" << j << \", \" << \"Qvalue: \"\n                          << PyFloat_AsDouble(PyList_GetItem(term, j)) << std::endl;\n            }\n        }\n    }\n    Py_Finalize();\n    return 0;\n}\n```\n\n编译：\n\n```txt\ng++ test.cpp -o test -I../python2.7.12/include -L../python2.7.12/lib -lpython2.7\n```\n\n执行：./test\n\n```txt\nenv level: 2\nenv actions: 2\nenv states: 7\nenv final_state: 4\nlearn_states: 7\nlearn_actions: 2\nlearn_eps: 0.1\n\nepisode: 0\nepisode: 100\nepisode: 200\nepisode: 300\nepisode: 400\nepisode: 500\nepisode: 600\nepisode: 700\nepisode: 800\nepisode: 900\nepisode: 1000\nepisode: 1100\nepisode: 1200\nepisode: 1300\nepisode: 1400\nepisode: 1500\nepisode: 1600\nepisode: 1700\nepisode: 1800\nepisode: 1900\nepisode: 2000\nepisode: 2100\nepisode: 2200\nepisode: 2300\nepisode: 2400\nepisode: 2500\nepisode: 2600\nepisode: 2700\nepisode: 2800\nepisode: 2900\nepisode: 3000\nepisode: 3100\nepisode: 3200\nepisode: 3300\nepisode: 3400\nepisode: 3500\nepisode: 3600\nepisode: 3700\nepisode: 3800\nepisode: 3900\nepisode: 4000\nepisode: 4100\nepisode: 4200\nepisode: 4300\nepisode: 4400\nepisode: 4500\nepisode: 4600\nepisode: 4700\nepisode: 4800\nepisode: 4900\nepisode: 5000\nepisode: 5100\nepisode: 5200\nepisode: 5300\nepisode: 5400\nepisode: 5500\nepisode: 5600\nepisode: 5700\nepisode: 5800\nepisode: 5900\nepisode: 6000\nepisode: 6100\nepisode: 6200\nepisode: 6300\nepisode: 6400\nepisode: 6500\nepisode: 6600\nepisode: 6700\nepisode: 6800\nepisode: 6900\nepisode: 7000\nepisode: 7100\nepisode: 7200\nepisode: 7300\nepisode: 7400\nepisode: 7500\nepisode: 7600\nepisode: 7700\nepisode: 7800\nepisode: 7900\nepisode: 8000\nepisode: 8100\nepisode: 8200\nepisode: 8300\nepisode: 8400\nepisode: 8500\nepisode: 8600\nepisode: 8700\nepisode: 8800\nepisode: 8900\nepisode: 9000\nepisode: 9100\nepisode: 9200\nepisode: 9300\nepisode: 9400\nepisode: 9500\nepisode: 9600\nepisode: 9700\nepisode: 9800\nepisode: 9900\nstate 0\n    direct: 0, Qvalue: 110\n    direct: 1, Qvalue: 140\nstate 1\n    direct: 0, Qvalue: 50\n    direct: 1, Qvalue: 100\nstate 2\n    direct: 0, Qvalue: 100\n    direct: 1, Qvalue: 150\nstate 3\n    direct: 0, Qvalue: 0\n    direct: 1, Qvalue: 0\nstate 4\n    direct: 0, Qvalue: 0\n    direct: 1, Qvalue: 0\nstate 5\n    direct: 0, Qvalue: 0\n    direct: 1, Qvalue: 0\nstate 6\n    direct: 0, Qvalue: 0\n    direct: 1, Qvalue: 0\n```\n\n\n\n## 参考资料\n\nPython/C API Reference Manual:  https://docs.python.org/2/c-api/index.html\n","slug":"C++调用Python接口","published":1,"updated":"2023-01-03T13:52:31.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgavfto000ahbeq6hqteqcv","content":"<p>由于需要在组内新开发的一套机器学习框架上开发一个强化学习的demo，但目前开源的一些游戏环境都只提供了python接口，比如Gym。如果要使用Gym去做在线训练的话，就需要在C++代码中调用Python接口，因此找了些例子学习了一下如何使用Python\nC API。当然Python C\nAPI不是唯一的方式，也可以使用boost的Python模块，有时间再研究。</p>\n<span id=\"more\"></span>\n<h2 id=\"hello-python\">hello python</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;python/Python.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Py_Initialize</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;hello c++!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;print &#x27;hello python!&#x27;&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Py_Finalize</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ test.cpp -o test -lpython</span><br></pre></td></tr></table></figure>\n<p>执行：./test</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello c++!</span><br><span class=\"line\">hello python!</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用python脚本中的函数\">调用python脚本中的函数</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># test_add.py</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;python/Python.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Usage: ./exe integer1 integer2&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cerr &lt;&lt; <span class=\"string\">&quot;hello c++!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Py_Initialize</span>();</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;import sys&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;sys.path.append(&#x27;./&#x27;)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;print &#x27;hello python!&#x27;&quot;</span>);</span><br><span class=\"line\">    PyObject* moduleName = <span class=\"built_in\">PyString_FromString</span>(<span class=\"string\">&quot;test_add&quot;</span>);</span><br><span class=\"line\">    PyObject* pModule = <span class=\"built_in\">PyImport_Import</span>(moduleName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pModule) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Python get module failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PyObject* pv = <span class=\"built_in\">PyObject_GetAttrString</span>(pModule, <span class=\"string\">&quot;add&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pv || !<span class=\"built_in\">PyCallable_Check</span>(pv)) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Can&#x27;t find function (add)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* args = <span class=\"built_in\">PyTuple_New</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    PyObject* arg1 = <span class=\"built_in\">PyInt_FromLong</span>(<span class=\"built_in\">atoi</span>(argv[<span class=\"number\">1</span>]));</span><br><span class=\"line\">    PyObject* arg2 = <span class=\"built_in\">PyInt_FromLong</span>(<span class=\"built_in\">atoi</span>(argv[<span class=\"number\">2</span>]));</span><br><span class=\"line\">    <span class=\"built_in\">PyTuple_SetItem</span>(args, <span class=\"number\">0</span>, arg1);</span><br><span class=\"line\">    <span class=\"built_in\">PyTuple_SetItem</span>(args, <span class=\"number\">1</span>, arg2);</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* pRet = <span class=\"built_in\">PyObject_CallObject</span>(pv, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pRet) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Call funftion (add) failed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">long</span> result = <span class=\"built_in\">PyInt_AsLong</span>(pRet);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Py_Finalize</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ test.cpp -o test -lpython</span><br></pre></td></tr></table></figure>\n<p>执行：./test 3 4</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello c++!</span><br><span class=\"line\">hello python!</span><br><span class=\"line\">result: 7</span><br></pre></td></tr></table></figure>\n<h2 id=\"q学习的一个例子\">Q学习的一个例子</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># tree.py</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">author: Houjiang Chen</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">q_learning</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, states, actions</span>):</span><br><span class=\"line\">        self.states = states</span><br><span class=\"line\">        self.actions = actions</span><br><span class=\"line\">        self.eps = <span class=\"number\">0.1</span></span><br><span class=\"line\">        self.alpha = <span class=\"number\">0.1</span></span><br><span class=\"line\">        self.q_table = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(actions)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(states)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_action</span>(<span class=\"params\">self, current_state</span>):</span><br><span class=\"line\">        max_action = self.q_table[current_state].index(<span class=\"built_in\">max</span>(self.q_table[current_state]))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random.uniform(<span class=\"number\">0</span>, <span class=\"number\">1</span>) &gt; self.eps:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> max_action</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            rest = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(self.q_table[current_state])) <span class=\"keyword\">if</span> i != max_action]</span><br><span class=\"line\">            index = random.randint(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(rest) - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rest[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">update</span>(<span class=\"params\">self, current_state, action, next_state, reward, final</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> final:</span><br><span class=\"line\">            reward = reward + <span class=\"built_in\">max</span>(self.q_table[next_state])</span><br><span class=\"line\">        self.q_table[current_state][action] += self.alpha * (reward - self.q_table[current_state][action])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">environment</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.level = <span class=\"number\">2</span></span><br><span class=\"line\">        self.actions = <span class=\"number\">2</span></span><br><span class=\"line\">        self.states = self.actions ** (self.level + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        self.final_states = self.actions ** self.level</span><br><span class=\"line\">        self.reward = &#123;<span class=\"number\">0</span> : [<span class=\"number\">10</span>, -<span class=\"number\">10</span>], <span class=\"number\">1</span> : [<span class=\"number\">50</span>, <span class=\"number\">100</span>], <span class=\"number\">2</span> : [<span class=\"number\">100</span>, <span class=\"number\">150</span>]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next</span>(<span class=\"params\">self, current_state, action</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;action: 0 or 1</span></span><br><span class=\"line\"><span class=\"string\">           return: next_state reward, is_final</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">next</span> = <span class=\"number\">2</span> * current_state + (action + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">next</span> &gt;= self.states - self.final_states:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span>, self.reward[current_state][action], <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>, self.reward[current_state][action], <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">reset</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.randint(<span class=\"number\">0</span>, self.states - self.final_states - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    env = environment()</span><br><span class=\"line\">    agent = q_learning(env.states, env.actions)</span><br><span class=\"line\"></span><br><span class=\"line\">    episode = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> episode &lt; <span class=\"number\">10000</span>:</span><br><span class=\"line\">        episode += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&quot;episode: %d&quot;</span> % episode</span><br><span class=\"line\">        current_state = env.reset()</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            action = agent.get_action(current_state)</span><br><span class=\"line\">            next_state, reward, final = env.<span class=\"built_in\">next</span>(current_state, action)</span><br><span class=\"line\">            agent.update(current_state, action, next_state, reward, final)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> final:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            current_state = next_state</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span> agent.q_table</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;python2.7/Python.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">PyObject* <span class=\"title\">New_PyInstance</span><span class=\"params\">(PyObject* cls, PyObject* args)</span> </span>&#123;</span><br><span class=\"line\">    PyObject* pInstance = <span class=\"built_in\">PyInstance_New</span>(cls, args, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pInstance) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;new instance failed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pInstance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Py_Initialize</span>();</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;import sys&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;sys.path.append(&#x27;./&#x27;)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* moduleName = <span class=\"built_in\">PyString_FromString</span>(<span class=\"string\">&quot;tree&quot;</span>);</span><br><span class=\"line\">    PyObject* pModule = <span class=\"built_in\">PyImport_Import</span>(moduleName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pModule) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Python get module failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PyObject* pEnv = <span class=\"built_in\">PyObject_GetAttrString</span>(pModule, <span class=\"string\">&quot;environment&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pEnv) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Can&#x27;t find class (environment)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* pEnvObject = <span class=\"built_in\">New_PyInstance</span>(pEnv, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    PyObject* pEnvLevel = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;level&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pEnvLevel) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Env has no attr level&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PyObject* pEnvActions = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;actions&quot;</span>);</span><br><span class=\"line\">    PyObject* pEnvStates = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;states&quot;</span>);</span><br><span class=\"line\">    PyObject* pEnvFinalState = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;final_states&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> level = <span class=\"built_in\">PyInt_AsLong</span>(pEnvLevel);</span><br><span class=\"line\">    <span class=\"type\">int</span> actions = <span class=\"built_in\">PyInt_AsLong</span>(pEnvActions);</span><br><span class=\"line\">    <span class=\"type\">int</span> states = <span class=\"built_in\">PyInt_AsLong</span>(pEnvStates);</span><br><span class=\"line\">    <span class=\"type\">int</span> final_state = <span class=\"built_in\">PyInt_AsLong</span>(pEnvFinalState);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;env level: &quot;</span> &lt;&lt; level &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;env actions: &quot;</span> &lt;&lt; actions &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;env states: &quot;</span> &lt;&lt; states &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;env final_state: &quot;</span> &lt;&lt; final_state &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* pLearn = <span class=\"built_in\">PyObject_GetAttrString</span>(pModule, <span class=\"string\">&quot;q_learning&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnArgs = <span class=\"built_in\">Py_BuildValue</span>(<span class=\"string\">&quot;ii&quot;</span>, states, actions);</span><br><span class=\"line\">    PyObject* pLearnObject = <span class=\"built_in\">New_PyInstance</span>(pLearn, pLearnArgs);</span><br><span class=\"line\">    PyObject* pLearnStates = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;states&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnActions = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;actions&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnEps = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;eps&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> learn_states = <span class=\"built_in\">PyInt_AsLong</span>(pLearnStates);</span><br><span class=\"line\">    <span class=\"type\">int</span> learn_actions = <span class=\"built_in\">PyInt_AsLong</span>(pLearnActions);</span><br><span class=\"line\">    <span class=\"type\">float</span> learn_eps = <span class=\"built_in\">PyFloat_AsDouble</span>(pLearnEps);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;learn_states: &quot;</span> &lt;&lt; learn_states &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;learn_actions: &quot;</span> &lt;&lt; learn_actions &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;learn_eps: &quot;</span> &lt;&lt; learn_eps &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* pEnvResetFunc = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;reset&quot;</span>);</span><br><span class=\"line\">    PyObject* pEnvNextFunc = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;next&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnGetActionFunc = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;get_action&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnUpdateFunc = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;update&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pEnvNextFunc) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] env has no function named next&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> episode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (episode = <span class=\"number\">0</span>; episode &lt; <span class=\"number\">10000</span>; ++episode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (episode % <span class=\"number\">100</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;episode: &quot;</span> &lt;&lt; episode &lt;&lt; std::endl;</span><br><span class=\"line\">        PyObject* current_state = <span class=\"built_in\">PyEval_CallObject</span>(pEnvResetFunc, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            PyObject* args1 = <span class=\"built_in\">PyTuple_New</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">            PyObject* args2 = <span class=\"built_in\">PyTuple_New</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args1, <span class=\"number\">0</span>, current_state);</span><br><span class=\"line\">            PyObject* action = <span class=\"built_in\">PyEval_CallObject</span>(pLearnGetActionFunc, args1);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args2, <span class=\"number\">0</span>, current_state);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args2, <span class=\"number\">1</span>, action);</span><br><span class=\"line\">            PyObject* ret = <span class=\"built_in\">PyEval_CallObject</span>(pEnvNextFunc, args2);</span><br><span class=\"line\">            PyObject* next_state = <span class=\"built_in\">PyTuple_GetItem</span>(ret, <span class=\"number\">0</span>);</span><br><span class=\"line\">            PyObject* <span class=\"keyword\">final</span> = <span class=\"built_in\">PyTuple_GetItem</span>(ret ,<span class=\"number\">2</span>);</span><br><span class=\"line\">            PyObject* args3 = <span class=\"built_in\">PyTuple_New</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">0</span>, current_state);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">1</span>, action);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">2</span>, next_state);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">3</span>, <span class=\"built_in\">PyTuple_GetItem</span>(ret, <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">4</span>, <span class=\"keyword\">final</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">PyEval_CallObject</span>(pLearnUpdateFunc, args3);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">PyObject_IsTrue</span>(<span class=\"keyword\">final</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            current_state = next_state;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (args3)</span><br><span class=\"line\">                <span class=\"built_in\">Py_DECREF</span>(args3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PyObject* pLearnQTable = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;q_table&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">PyList_Size</span>(pLearnQTable); ++i) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;state &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class=\"line\">        PyObject* term = <span class=\"built_in\">PyList_GetItem</span>(pLearnQTable, i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">PyList_Check</span>(term)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">PyList_Size</span>(term); ++j) &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; <span class=\"string\">&quot;    direct: &quot;</span> &lt;&lt; j &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; <span class=\"string\">&quot;Qvalue: &quot;</span></span><br><span class=\"line\">                          &lt;&lt; <span class=\"built_in\">PyFloat_AsDouble</span>(<span class=\"built_in\">PyList_GetItem</span>(term, j)) &lt;&lt; std::endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Py_Finalize</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ test.cpp -o test -I../python2.7.12/include -L../python2.7.12/lib -lpython2.7</span><br></pre></td></tr></table></figure>\n<p>执行：./test</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env level: 2</span><br><span class=\"line\">env actions: 2</span><br><span class=\"line\">env states: 7</span><br><span class=\"line\">env final_state: 4</span><br><span class=\"line\">learn_states: 7</span><br><span class=\"line\">learn_actions: 2</span><br><span class=\"line\">learn_eps: 0.1</span><br><span class=\"line\"></span><br><span class=\"line\">episode: 0</span><br><span class=\"line\">episode: 100</span><br><span class=\"line\">episode: 200</span><br><span class=\"line\">episode: 300</span><br><span class=\"line\">episode: 400</span><br><span class=\"line\">episode: 500</span><br><span class=\"line\">episode: 600</span><br><span class=\"line\">episode: 700</span><br><span class=\"line\">episode: 800</span><br><span class=\"line\">episode: 900</span><br><span class=\"line\">episode: 1000</span><br><span class=\"line\">episode: 1100</span><br><span class=\"line\">episode: 1200</span><br><span class=\"line\">episode: 1300</span><br><span class=\"line\">episode: 1400</span><br><span class=\"line\">episode: 1500</span><br><span class=\"line\">episode: 1600</span><br><span class=\"line\">episode: 1700</span><br><span class=\"line\">episode: 1800</span><br><span class=\"line\">episode: 1900</span><br><span class=\"line\">episode: 2000</span><br><span class=\"line\">episode: 2100</span><br><span class=\"line\">episode: 2200</span><br><span class=\"line\">episode: 2300</span><br><span class=\"line\">episode: 2400</span><br><span class=\"line\">episode: 2500</span><br><span class=\"line\">episode: 2600</span><br><span class=\"line\">episode: 2700</span><br><span class=\"line\">episode: 2800</span><br><span class=\"line\">episode: 2900</span><br><span class=\"line\">episode: 3000</span><br><span class=\"line\">episode: 3100</span><br><span class=\"line\">episode: 3200</span><br><span class=\"line\">episode: 3300</span><br><span class=\"line\">episode: 3400</span><br><span class=\"line\">episode: 3500</span><br><span class=\"line\">episode: 3600</span><br><span class=\"line\">episode: 3700</span><br><span class=\"line\">episode: 3800</span><br><span class=\"line\">episode: 3900</span><br><span class=\"line\">episode: 4000</span><br><span class=\"line\">episode: 4100</span><br><span class=\"line\">episode: 4200</span><br><span class=\"line\">episode: 4300</span><br><span class=\"line\">episode: 4400</span><br><span class=\"line\">episode: 4500</span><br><span class=\"line\">episode: 4600</span><br><span class=\"line\">episode: 4700</span><br><span class=\"line\">episode: 4800</span><br><span class=\"line\">episode: 4900</span><br><span class=\"line\">episode: 5000</span><br><span class=\"line\">episode: 5100</span><br><span class=\"line\">episode: 5200</span><br><span class=\"line\">episode: 5300</span><br><span class=\"line\">episode: 5400</span><br><span class=\"line\">episode: 5500</span><br><span class=\"line\">episode: 5600</span><br><span class=\"line\">episode: 5700</span><br><span class=\"line\">episode: 5800</span><br><span class=\"line\">episode: 5900</span><br><span class=\"line\">episode: 6000</span><br><span class=\"line\">episode: 6100</span><br><span class=\"line\">episode: 6200</span><br><span class=\"line\">episode: 6300</span><br><span class=\"line\">episode: 6400</span><br><span class=\"line\">episode: 6500</span><br><span class=\"line\">episode: 6600</span><br><span class=\"line\">episode: 6700</span><br><span class=\"line\">episode: 6800</span><br><span class=\"line\">episode: 6900</span><br><span class=\"line\">episode: 7000</span><br><span class=\"line\">episode: 7100</span><br><span class=\"line\">episode: 7200</span><br><span class=\"line\">episode: 7300</span><br><span class=\"line\">episode: 7400</span><br><span class=\"line\">episode: 7500</span><br><span class=\"line\">episode: 7600</span><br><span class=\"line\">episode: 7700</span><br><span class=\"line\">episode: 7800</span><br><span class=\"line\">episode: 7900</span><br><span class=\"line\">episode: 8000</span><br><span class=\"line\">episode: 8100</span><br><span class=\"line\">episode: 8200</span><br><span class=\"line\">episode: 8300</span><br><span class=\"line\">episode: 8400</span><br><span class=\"line\">episode: 8500</span><br><span class=\"line\">episode: 8600</span><br><span class=\"line\">episode: 8700</span><br><span class=\"line\">episode: 8800</span><br><span class=\"line\">episode: 8900</span><br><span class=\"line\">episode: 9000</span><br><span class=\"line\">episode: 9100</span><br><span class=\"line\">episode: 9200</span><br><span class=\"line\">episode: 9300</span><br><span class=\"line\">episode: 9400</span><br><span class=\"line\">episode: 9500</span><br><span class=\"line\">episode: 9600</span><br><span class=\"line\">episode: 9700</span><br><span class=\"line\">episode: 9800</span><br><span class=\"line\">episode: 9900</span><br><span class=\"line\">state 0</span><br><span class=\"line\">    direct: 0, Qvalue: 110</span><br><span class=\"line\">    direct: 1, Qvalue: 140</span><br><span class=\"line\">state 1</span><br><span class=\"line\">    direct: 0, Qvalue: 50</span><br><span class=\"line\">    direct: 1, Qvalue: 100</span><br><span class=\"line\">state 2</span><br><span class=\"line\">    direct: 0, Qvalue: 100</span><br><span class=\"line\">    direct: 1, Qvalue: 150</span><br><span class=\"line\">state 3</span><br><span class=\"line\">    direct: 0, Qvalue: 0</span><br><span class=\"line\">    direct: 1, Qvalue: 0</span><br><span class=\"line\">state 4</span><br><span class=\"line\">    direct: 0, Qvalue: 0</span><br><span class=\"line\">    direct: 1, Qvalue: 0</span><br><span class=\"line\">state 5</span><br><span class=\"line\">    direct: 0, Qvalue: 0</span><br><span class=\"line\">    direct: 1, Qvalue: 0</span><br><span class=\"line\">state 6</span><br><span class=\"line\">    direct: 0, Qvalue: 0</span><br><span class=\"line\">    direct: 1, Qvalue: 0</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>Python/C API Reference Manual:\nhttps://docs.python.org/2/c-api/index.html</p>\n","site":{"data":{}},"excerpt":"<p>由于需要在组内新开发的一套机器学习框架上开发一个强化学习的demo，但目前开源的一些游戏环境都只提供了python接口，比如Gym。如果要使用Gym去做在线训练的话，就需要在C++代码中调用Python接口，因此找了些例子学习了一下如何使用Python\nC API。当然Python C\nAPI不是唯一的方式，也可以使用boost的Python模块，有时间再研究。</p>","more":"<h2 id=\"hello-python\">hello python</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;python/Python.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Py_Initialize</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;hello c++!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;print &#x27;hello python!&#x27;&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Py_Finalize</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ test.cpp -o test -lpython</span><br></pre></td></tr></table></figure>\n<p>执行：./test</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello c++!</span><br><span class=\"line\">hello python!</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用python脚本中的函数\">调用python脚本中的函数</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># test_add.py</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;python/Python.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Usage: ./exe integer1 integer2&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cerr &lt;&lt; <span class=\"string\">&quot;hello c++!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Py_Initialize</span>();</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;import sys&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;sys.path.append(&#x27;./&#x27;)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;print &#x27;hello python!&#x27;&quot;</span>);</span><br><span class=\"line\">    PyObject* moduleName = <span class=\"built_in\">PyString_FromString</span>(<span class=\"string\">&quot;test_add&quot;</span>);</span><br><span class=\"line\">    PyObject* pModule = <span class=\"built_in\">PyImport_Import</span>(moduleName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pModule) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Python get module failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PyObject* pv = <span class=\"built_in\">PyObject_GetAttrString</span>(pModule, <span class=\"string\">&quot;add&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pv || !<span class=\"built_in\">PyCallable_Check</span>(pv)) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Can&#x27;t find function (add)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* args = <span class=\"built_in\">PyTuple_New</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    PyObject* arg1 = <span class=\"built_in\">PyInt_FromLong</span>(<span class=\"built_in\">atoi</span>(argv[<span class=\"number\">1</span>]));</span><br><span class=\"line\">    PyObject* arg2 = <span class=\"built_in\">PyInt_FromLong</span>(<span class=\"built_in\">atoi</span>(argv[<span class=\"number\">2</span>]));</span><br><span class=\"line\">    <span class=\"built_in\">PyTuple_SetItem</span>(args, <span class=\"number\">0</span>, arg1);</span><br><span class=\"line\">    <span class=\"built_in\">PyTuple_SetItem</span>(args, <span class=\"number\">1</span>, arg2);</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* pRet = <span class=\"built_in\">PyObject_CallObject</span>(pv, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pRet) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Call funftion (add) failed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">long</span> result = <span class=\"built_in\">PyInt_AsLong</span>(pRet);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Py_Finalize</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ test.cpp -o test -lpython</span><br></pre></td></tr></table></figure>\n<p>执行：./test 3 4</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello c++!</span><br><span class=\"line\">hello python!</span><br><span class=\"line\">result: 7</span><br></pre></td></tr></table></figure>\n<h2 id=\"q学习的一个例子\">Q学习的一个例子</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># tree.py</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">author: Houjiang Chen</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">q_learning</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, states, actions</span>):</span><br><span class=\"line\">        self.states = states</span><br><span class=\"line\">        self.actions = actions</span><br><span class=\"line\">        self.eps = <span class=\"number\">0.1</span></span><br><span class=\"line\">        self.alpha = <span class=\"number\">0.1</span></span><br><span class=\"line\">        self.q_table = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(actions)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(states)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_action</span>(<span class=\"params\">self, current_state</span>):</span><br><span class=\"line\">        max_action = self.q_table[current_state].index(<span class=\"built_in\">max</span>(self.q_table[current_state]))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random.uniform(<span class=\"number\">0</span>, <span class=\"number\">1</span>) &gt; self.eps:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> max_action</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            rest = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(self.q_table[current_state])) <span class=\"keyword\">if</span> i != max_action]</span><br><span class=\"line\">            index = random.randint(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(rest) - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rest[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">update</span>(<span class=\"params\">self, current_state, action, next_state, reward, final</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> final:</span><br><span class=\"line\">            reward = reward + <span class=\"built_in\">max</span>(self.q_table[next_state])</span><br><span class=\"line\">        self.q_table[current_state][action] += self.alpha * (reward - self.q_table[current_state][action])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">environment</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.level = <span class=\"number\">2</span></span><br><span class=\"line\">        self.actions = <span class=\"number\">2</span></span><br><span class=\"line\">        self.states = self.actions ** (self.level + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        self.final_states = self.actions ** self.level</span><br><span class=\"line\">        self.reward = &#123;<span class=\"number\">0</span> : [<span class=\"number\">10</span>, -<span class=\"number\">10</span>], <span class=\"number\">1</span> : [<span class=\"number\">50</span>, <span class=\"number\">100</span>], <span class=\"number\">2</span> : [<span class=\"number\">100</span>, <span class=\"number\">150</span>]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next</span>(<span class=\"params\">self, current_state, action</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;action: 0 or 1</span></span><br><span class=\"line\"><span class=\"string\">           return: next_state reward, is_final</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">next</span> = <span class=\"number\">2</span> * current_state + (action + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">next</span> &gt;= self.states - self.final_states:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span>, self.reward[current_state][action], <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>, self.reward[current_state][action], <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">reset</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.randint(<span class=\"number\">0</span>, self.states - self.final_states - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    env = environment()</span><br><span class=\"line\">    agent = q_learning(env.states, env.actions)</span><br><span class=\"line\"></span><br><span class=\"line\">    episode = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> episode &lt; <span class=\"number\">10000</span>:</span><br><span class=\"line\">        episode += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&quot;episode: %d&quot;</span> % episode</span><br><span class=\"line\">        current_state = env.reset()</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            action = agent.get_action(current_state)</span><br><span class=\"line\">            next_state, reward, final = env.<span class=\"built_in\">next</span>(current_state, action)</span><br><span class=\"line\">            agent.update(current_state, action, next_state, reward, final)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> final:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            current_state = next_state</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span> agent.q_table</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;python2.7/Python.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">PyObject* <span class=\"title\">New_PyInstance</span><span class=\"params\">(PyObject* cls, PyObject* args)</span> </span>&#123;</span><br><span class=\"line\">    PyObject* pInstance = <span class=\"built_in\">PyInstance_New</span>(cls, args, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pInstance) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;new instance failed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pInstance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Py_Initialize</span>();</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;import sys&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">PyRun_SimpleString</span>(<span class=\"string\">&quot;sys.path.append(&#x27;./&#x27;)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* moduleName = <span class=\"built_in\">PyString_FromString</span>(<span class=\"string\">&quot;tree&quot;</span>);</span><br><span class=\"line\">    PyObject* pModule = <span class=\"built_in\">PyImport_Import</span>(moduleName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pModule) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Python get module failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PyObject* pEnv = <span class=\"built_in\">PyObject_GetAttrString</span>(pModule, <span class=\"string\">&quot;environment&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pEnv) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Can&#x27;t find class (environment)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* pEnvObject = <span class=\"built_in\">New_PyInstance</span>(pEnv, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    PyObject* pEnvLevel = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;level&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pEnvLevel) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] Env has no attr level&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PyObject* pEnvActions = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;actions&quot;</span>);</span><br><span class=\"line\">    PyObject* pEnvStates = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;states&quot;</span>);</span><br><span class=\"line\">    PyObject* pEnvFinalState = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;final_states&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> level = <span class=\"built_in\">PyInt_AsLong</span>(pEnvLevel);</span><br><span class=\"line\">    <span class=\"type\">int</span> actions = <span class=\"built_in\">PyInt_AsLong</span>(pEnvActions);</span><br><span class=\"line\">    <span class=\"type\">int</span> states = <span class=\"built_in\">PyInt_AsLong</span>(pEnvStates);</span><br><span class=\"line\">    <span class=\"type\">int</span> final_state = <span class=\"built_in\">PyInt_AsLong</span>(pEnvFinalState);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;env level: &quot;</span> &lt;&lt; level &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;env actions: &quot;</span> &lt;&lt; actions &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;env states: &quot;</span> &lt;&lt; states &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;env final_state: &quot;</span> &lt;&lt; final_state &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* pLearn = <span class=\"built_in\">PyObject_GetAttrString</span>(pModule, <span class=\"string\">&quot;q_learning&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnArgs = <span class=\"built_in\">Py_BuildValue</span>(<span class=\"string\">&quot;ii&quot;</span>, states, actions);</span><br><span class=\"line\">    PyObject* pLearnObject = <span class=\"built_in\">New_PyInstance</span>(pLearn, pLearnArgs);</span><br><span class=\"line\">    PyObject* pLearnStates = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;states&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnActions = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;actions&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnEps = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;eps&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> learn_states = <span class=\"built_in\">PyInt_AsLong</span>(pLearnStates);</span><br><span class=\"line\">    <span class=\"type\">int</span> learn_actions = <span class=\"built_in\">PyInt_AsLong</span>(pLearnActions);</span><br><span class=\"line\">    <span class=\"type\">float</span> learn_eps = <span class=\"built_in\">PyFloat_AsDouble</span>(pLearnEps);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;learn_states: &quot;</span> &lt;&lt; learn_states &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;learn_actions: &quot;</span> &lt;&lt; learn_actions &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;learn_eps: &quot;</span> &lt;&lt; learn_eps &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    PyObject* pEnvResetFunc = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;reset&quot;</span>);</span><br><span class=\"line\">    PyObject* pEnvNextFunc = <span class=\"built_in\">PyObject_GetAttrString</span>(pEnvObject, <span class=\"string\">&quot;next&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnGetActionFunc = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;get_action&quot;</span>);</span><br><span class=\"line\">    PyObject* pLearnUpdateFunc = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;update&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pEnvNextFunc) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;[ERROR] env has no function named next&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> episode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (episode = <span class=\"number\">0</span>; episode &lt; <span class=\"number\">10000</span>; ++episode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (episode % <span class=\"number\">100</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;episode: &quot;</span> &lt;&lt; episode &lt;&lt; std::endl;</span><br><span class=\"line\">        PyObject* current_state = <span class=\"built_in\">PyEval_CallObject</span>(pEnvResetFunc, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            PyObject* args1 = <span class=\"built_in\">PyTuple_New</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">            PyObject* args2 = <span class=\"built_in\">PyTuple_New</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args1, <span class=\"number\">0</span>, current_state);</span><br><span class=\"line\">            PyObject* action = <span class=\"built_in\">PyEval_CallObject</span>(pLearnGetActionFunc, args1);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args2, <span class=\"number\">0</span>, current_state);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args2, <span class=\"number\">1</span>, action);</span><br><span class=\"line\">            PyObject* ret = <span class=\"built_in\">PyEval_CallObject</span>(pEnvNextFunc, args2);</span><br><span class=\"line\">            PyObject* next_state = <span class=\"built_in\">PyTuple_GetItem</span>(ret, <span class=\"number\">0</span>);</span><br><span class=\"line\">            PyObject* <span class=\"keyword\">final</span> = <span class=\"built_in\">PyTuple_GetItem</span>(ret ,<span class=\"number\">2</span>);</span><br><span class=\"line\">            PyObject* args3 = <span class=\"built_in\">PyTuple_New</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">0</span>, current_state);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">1</span>, action);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">2</span>, next_state);</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">3</span>, <span class=\"built_in\">PyTuple_GetItem</span>(ret, <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"built_in\">PyTuple_SetItem</span>(args3, <span class=\"number\">4</span>, <span class=\"keyword\">final</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">PyEval_CallObject</span>(pLearnUpdateFunc, args3);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">PyObject_IsTrue</span>(<span class=\"keyword\">final</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            current_state = next_state;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (args3)</span><br><span class=\"line\">                <span class=\"built_in\">Py_DECREF</span>(args3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PyObject* pLearnQTable = <span class=\"built_in\">PyObject_GetAttrString</span>(pLearnObject, <span class=\"string\">&quot;q_table&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">PyList_Size</span>(pLearnQTable); ++i) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;state &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class=\"line\">        PyObject* term = <span class=\"built_in\">PyList_GetItem</span>(pLearnQTable, i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">PyList_Check</span>(term)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">PyList_Size</span>(term); ++j) &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; <span class=\"string\">&quot;    direct: &quot;</span> &lt;&lt; j &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; <span class=\"string\">&quot;Qvalue: &quot;</span></span><br><span class=\"line\">                          &lt;&lt; <span class=\"built_in\">PyFloat_AsDouble</span>(<span class=\"built_in\">PyList_GetItem</span>(term, j)) &lt;&lt; std::endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Py_Finalize</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ test.cpp -o test -I../python2.7.12/include -L../python2.7.12/lib -lpython2.7</span><br></pre></td></tr></table></figure>\n<p>执行：./test</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env level: 2</span><br><span class=\"line\">env actions: 2</span><br><span class=\"line\">env states: 7</span><br><span class=\"line\">env final_state: 4</span><br><span class=\"line\">learn_states: 7</span><br><span class=\"line\">learn_actions: 2</span><br><span class=\"line\">learn_eps: 0.1</span><br><span class=\"line\"></span><br><span class=\"line\">episode: 0</span><br><span class=\"line\">episode: 100</span><br><span class=\"line\">episode: 200</span><br><span class=\"line\">episode: 300</span><br><span class=\"line\">episode: 400</span><br><span class=\"line\">episode: 500</span><br><span class=\"line\">episode: 600</span><br><span class=\"line\">episode: 700</span><br><span class=\"line\">episode: 800</span><br><span class=\"line\">episode: 900</span><br><span class=\"line\">episode: 1000</span><br><span class=\"line\">episode: 1100</span><br><span class=\"line\">episode: 1200</span><br><span class=\"line\">episode: 1300</span><br><span class=\"line\">episode: 1400</span><br><span class=\"line\">episode: 1500</span><br><span class=\"line\">episode: 1600</span><br><span class=\"line\">episode: 1700</span><br><span class=\"line\">episode: 1800</span><br><span class=\"line\">episode: 1900</span><br><span class=\"line\">episode: 2000</span><br><span class=\"line\">episode: 2100</span><br><span class=\"line\">episode: 2200</span><br><span class=\"line\">episode: 2300</span><br><span class=\"line\">episode: 2400</span><br><span class=\"line\">episode: 2500</span><br><span class=\"line\">episode: 2600</span><br><span class=\"line\">episode: 2700</span><br><span class=\"line\">episode: 2800</span><br><span class=\"line\">episode: 2900</span><br><span class=\"line\">episode: 3000</span><br><span class=\"line\">episode: 3100</span><br><span class=\"line\">episode: 3200</span><br><span class=\"line\">episode: 3300</span><br><span class=\"line\">episode: 3400</span><br><span class=\"line\">episode: 3500</span><br><span class=\"line\">episode: 3600</span><br><span class=\"line\">episode: 3700</span><br><span class=\"line\">episode: 3800</span><br><span class=\"line\">episode: 3900</span><br><span class=\"line\">episode: 4000</span><br><span class=\"line\">episode: 4100</span><br><span class=\"line\">episode: 4200</span><br><span class=\"line\">episode: 4300</span><br><span class=\"line\">episode: 4400</span><br><span class=\"line\">episode: 4500</span><br><span class=\"line\">episode: 4600</span><br><span class=\"line\">episode: 4700</span><br><span class=\"line\">episode: 4800</span><br><span class=\"line\">episode: 4900</span><br><span class=\"line\">episode: 5000</span><br><span class=\"line\">episode: 5100</span><br><span class=\"line\">episode: 5200</span><br><span class=\"line\">episode: 5300</span><br><span class=\"line\">episode: 5400</span><br><span class=\"line\">episode: 5500</span><br><span class=\"line\">episode: 5600</span><br><span class=\"line\">episode: 5700</span><br><span class=\"line\">episode: 5800</span><br><span class=\"line\">episode: 5900</span><br><span class=\"line\">episode: 6000</span><br><span class=\"line\">episode: 6100</span><br><span class=\"line\">episode: 6200</span><br><span class=\"line\">episode: 6300</span><br><span class=\"line\">episode: 6400</span><br><span class=\"line\">episode: 6500</span><br><span class=\"line\">episode: 6600</span><br><span class=\"line\">episode: 6700</span><br><span class=\"line\">episode: 6800</span><br><span class=\"line\">episode: 6900</span><br><span class=\"line\">episode: 7000</span><br><span class=\"line\">episode: 7100</span><br><span class=\"line\">episode: 7200</span><br><span class=\"line\">episode: 7300</span><br><span class=\"line\">episode: 7400</span><br><span class=\"line\">episode: 7500</span><br><span class=\"line\">episode: 7600</span><br><span class=\"line\">episode: 7700</span><br><span class=\"line\">episode: 7800</span><br><span class=\"line\">episode: 7900</span><br><span class=\"line\">episode: 8000</span><br><span class=\"line\">episode: 8100</span><br><span class=\"line\">episode: 8200</span><br><span class=\"line\">episode: 8300</span><br><span class=\"line\">episode: 8400</span><br><span class=\"line\">episode: 8500</span><br><span class=\"line\">episode: 8600</span><br><span class=\"line\">episode: 8700</span><br><span class=\"line\">episode: 8800</span><br><span class=\"line\">episode: 8900</span><br><span class=\"line\">episode: 9000</span><br><span class=\"line\">episode: 9100</span><br><span class=\"line\">episode: 9200</span><br><span class=\"line\">episode: 9300</span><br><span class=\"line\">episode: 9400</span><br><span class=\"line\">episode: 9500</span><br><span class=\"line\">episode: 9600</span><br><span class=\"line\">episode: 9700</span><br><span class=\"line\">episode: 9800</span><br><span class=\"line\">episode: 9900</span><br><span class=\"line\">state 0</span><br><span class=\"line\">    direct: 0, Qvalue: 110</span><br><span class=\"line\">    direct: 1, Qvalue: 140</span><br><span class=\"line\">state 1</span><br><span class=\"line\">    direct: 0, Qvalue: 50</span><br><span class=\"line\">    direct: 1, Qvalue: 100</span><br><span class=\"line\">state 2</span><br><span class=\"line\">    direct: 0, Qvalue: 100</span><br><span class=\"line\">    direct: 1, Qvalue: 150</span><br><span class=\"line\">state 3</span><br><span class=\"line\">    direct: 0, Qvalue: 0</span><br><span class=\"line\">    direct: 1, Qvalue: 0</span><br><span class=\"line\">state 4</span><br><span class=\"line\">    direct: 0, Qvalue: 0</span><br><span class=\"line\">    direct: 1, Qvalue: 0</span><br><span class=\"line\">state 5</span><br><span class=\"line\">    direct: 0, Qvalue: 0</span><br><span class=\"line\">    direct: 1, Qvalue: 0</span><br><span class=\"line\">state 6</span><br><span class=\"line\">    direct: 0, Qvalue: 0</span><br><span class=\"line\">    direct: 1, Qvalue: 0</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>Python/C API Reference Manual:\nhttps://docs.python.org/2/c-api/index.html</p>"},{"title":"值函数的贝尔曼公式推导","date":"2017-04-10T04:31:08.000Z","_content":"\n下面的推导过程中第2步和第5步两次用到重期望公式: $\\bf{EX}=\\bf{E\\left(E\\left[X\\mid Y\\right]\\right)}$。\n\n<!-- more -->\n\n$$\\begin{split}\n\\upsilon_{\\pi}(s)&={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left({\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t\\right]\\right) \\\\\n&={\\bf{E_{\\pi}}}\\left[\\sum_a\\pi(a|s)G_t\\mid S_t=s,A_t=a\\right] \\\\\n&=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a\\right] \\\\\n&=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left({\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a,S_{t+1}\\right]\\right) \\\\\n&=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left[\\sum_{s^{'}}p(s^{'}\\mid s,a)G_t\\mid S_t=s,A_t=a,S_{t+1}=s^{'}\\right] \\\\\n&=\\sum_a\\pi(a|s)\\sum_{s^{'}}p(s^{'}\\mid s,a){\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a,S_{t+1}=s^{'}\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid s,a){\\bf E}_{\\pi}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}=a,S_{t+1}=s^{'}}\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma{\\bf E}_{\\pi}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t+1}=s^{'}}\\right]\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]\n\\end{split}$$\n","source":"_posts/值函数的贝尔曼公式推导.md","raw":"---\ntitle: 值函数的贝尔曼公式推导\ndate: 2017-04-10 12:31:08\ncategory: reinforcement learning\ntags: [reinforcement learning, machine learning，贝尔曼公式推导]\n---\n\n下面的推导过程中第2步和第5步两次用到重期望公式: $\\bf{EX}=\\bf{E\\left(E\\left[X\\mid Y\\right]\\right)}$。\n\n<!-- more -->\n\n$$\\begin{split}\n\\upsilon_{\\pi}(s)&={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left({\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t\\right]\\right) \\\\\n&={\\bf{E_{\\pi}}}\\left[\\sum_a\\pi(a|s)G_t\\mid S_t=s,A_t=a\\right] \\\\\n&=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a\\right] \\\\\n&=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left({\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a,S_{t+1}\\right]\\right) \\\\\n&=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left[\\sum_{s^{'}}p(s^{'}\\mid s,a)G_t\\mid S_t=s,A_t=a,S_{t+1}=s^{'}\\right] \\\\\n&=\\sum_a\\pi(a|s)\\sum_{s^{'}}p(s^{'}\\mid s,a){\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a,S_{t+1}=s^{'}\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid s,a){\\bf E}_{\\pi}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}=a,S_{t+1}=s^{'}}\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma{\\bf E}_{\\pi}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t+1}=s^{'}}\\right]\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]\n\\end{split}$$\n","slug":"值函数的贝尔曼公式推导","published":1,"updated":"2023-01-03T13:55:05.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgavftq000dhbeqdnb8d1ka","content":"<p>下面的推导过程中第2步和第5步两次用到重期望公式: <span\nclass=\"math inline\">\\(\\bf{EX}=\\bf{E\\left(E\\left[X\\mid\nY\\right]\\right)}\\)</span>。</p>\n<span id=\"more\"></span>\n<p><span class=\"math display\">\\[\\begin{split}\n\\upsilon_{\\pi}(s)&amp;={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right] \\\\\n&amp;={\\bf{E_{\\pi}}}\\left({\\bf{E_{\\pi}}}\\left[G_t\\mid\nS_t=s,A_t\\right]\\right) \\\\\n&amp;={\\bf{E_{\\pi}}}\\left[\\sum_a\\pi(a|s)G_t\\mid S_t=s,A_t=a\\right] \\\\\n&amp;=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a\\right] \\\\\n&amp;=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left({\\bf{E_{\\pi}}}\\left[G_t\\mid\nS_t=s,A_t=a,S_{t+1}\\right]\\right) \\\\\n&amp;=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left[\\sum_{s^{&#39;}}p(s^{&#39;}\\mid\ns,a)G_t\\mid S_t=s,A_t=a,S_{t+1}=s^{&#39;}\\right] \\\\\n&amp;=\\sum_a\\pi(a|s)\\sum_{s^{&#39;}}p(s^{&#39;}\\mid\ns,a){\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a,S_{t+1}=s^{&#39;}\\right] \\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid s,a){\\bf\nE}_{\\pi}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}=a,S_{t+1}=s^{&#39;}}\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma{\\bf\nE}_{\\pi}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t+1}=s^{&#39;}}\\right]\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\n\\end{split}\\]</span></p>\n","site":{"data":{}},"excerpt":"<p>下面的推导过程中第2步和第5步两次用到重期望公式: <span\nclass=\"math inline\">\\(\\bf{EX}=\\bf{E\\left(E\\left[X\\mid\nY\\right]\\right)}\\)</span>。</p>","more":"<p><span class=\"math display\">\\[\\begin{split}\n\\upsilon_{\\pi}(s)&amp;={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right] \\\\\n&amp;={\\bf{E_{\\pi}}}\\left({\\bf{E_{\\pi}}}\\left[G_t\\mid\nS_t=s,A_t\\right]\\right) \\\\\n&amp;={\\bf{E_{\\pi}}}\\left[\\sum_a\\pi(a|s)G_t\\mid S_t=s,A_t=a\\right] \\\\\n&amp;=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a\\right] \\\\\n&amp;=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left({\\bf{E_{\\pi}}}\\left[G_t\\mid\nS_t=s,A_t=a,S_{t+1}\\right]\\right) \\\\\n&amp;=\\sum_a\\pi(a|s){\\bf{E_{\\pi}}}\\left[\\sum_{s^{&#39;}}p(s^{&#39;}\\mid\ns,a)G_t\\mid S_t=s,A_t=a,S_{t+1}=s^{&#39;}\\right] \\\\\n&amp;=\\sum_a\\pi(a|s)\\sum_{s^{&#39;}}p(s^{&#39;}\\mid\ns,a){\\bf{E_{\\pi}}}\\left[G_t\\mid S_t=s,A_t=a,S_{t+1}=s^{&#39;}\\right] \\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid s,a){\\bf\nE}_{\\pi}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}=a,S_{t+1}=s^{&#39;}}\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma{\\bf\nE}_{\\pi}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t+1}=s^{&#39;}}\\right]\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\n\\end{split}\\]</span></p>"},{"title":"NEURAL MACHINE TRANSLATION论文学习串讲","date":"2017-12-01T04:24:08.000Z","_content":"\n## seq2seq\n\n主要学习的是论文Neural machine translation by jointly learning to align and translate (Dzmitry Bahdanau、Yoshua Bengio等，2016.05)和Neural machine translation (Minh-ThangLuong，2016.12)。\n\n神经机器翻译的目的是将一门语言的文本序列翻译成另一门语言的文本序列，因此机器翻译的训练语料一般是源语言和目标语言组成的一对文本，也叫做平行语料(parallel corpus)。我们通常将输入和输出都是序列的模型叫做seq2seq，seq2seq不仅应用在机器翻译领域，也用于当前热门的自动问答系统以及文本摘要的自动生成等领域。\n\n<!-- more -->\n\n## Encoder-Decoder\n\n2014年Dzmitry Bahdanau、Yoshua Bengio等人在论文Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation中首次提出将RNN Encoder-Decoder结构来计算双语短语对的条件概率，用于改进统计机器翻译的效果。Encoder-Decoder是由encoder和decoder两部分组成，encoder将输入序列编码成定长的语义向量，decoder将语义向量进行解码得到目标序列。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/12c7a5370bc9da07193c0bd43c5b27cd.png?raw=true\" width=500 align=center>\n\n在NMT中Encoder-Decoder试图直接对并行语料的条件概率$P(Y|X)$进行建模，encoder输入的是一组向量序列$X=(x_{1},…,x_{T_{x}})$，$x_i$为词$i$的one-hot编码向量，并将序列$X$编码成语义向量$c$，decoder输入语义向量$c$，并逐个生成序列$Y=(y_{1},…,y_{T_{y}})$，其中$y_{i}$的生成与之前已经生成的词序列$y_{1},…,y_{i-1}$有关。\n\n$$\\log p(Y|X)=\\sum_{t=1}^{T_{y}}\\log p(y_{t}|y_{<t}, c)$$\n\n对于不定长度序列的编码和解码，我们很自然会想到RNN，实际上RNN Encoder–Decoder就是正反两组RNN拼接在一起组成的编码解码网络。经典的RNN Encoder–Decoder示意图如下：\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/ab3551f2c0f12a3bc50283e49e09e52c.png?raw=true\" width=400 align=center />\n\n我们可以用下面公式描述编码过程：\n$$h_{t}=f(x_{t},h_{t-1})$$\n$$c=q({h_{1},…,h_{T_{x}}})$$\n\n函数$f$一般用一个RNN结构来表示，可以是LSTM、GRU等，$h_{t}$表示encoder RNN在第t时刻的cell隐状态，向量c的计算与encoder RNN所有时刻的cell隐状态相关，函数$q$可以表示所有隐状态的加权和，但由于RNN的特殊性，我们这里只使用最后一个时刻的隐状态作为向量$c$，即$c=h_{T_{x}}$。\n\n对于解码过程，生成$y_{t}$时的条件概率可以改写成\n\n$$p(y_{t}|y_{<t},c)=g(y_{t-1},s_{t},c)$$\n$$s_{t}=f(s_{t-1},y_{t-1},c)$$\n\n其中，$g$是非线性函数，可以是单层的softmax，也可以是一个多层结构的神经网络，$y_{t-1}$表示上一时刻的输出，$f$同样是一个RNN结构，$s_{t}$表示decoder RNN cell的隐状态。\n\n\n\n## Attention\n\n在Encoder-Decoder中每个目标词生成时使用的都是同一个向量$c$，虽然理论上来讲向量$c$可以表示输入序列的语义信息，比如一些关键词、句子结构和语法信息等，但也存在注意力分散的问题。在机器翻译中，一般翻译出来的词与源序列的词是有对齐关系的，也就是说目标词的生成与源序列中的部分关键词关系更大，而其他词对当前目标词的生成影响就很小。在Encoder-Decoder中不论生成哪个目标词，使用的语义向量都是$c$，而语义向量$c$是由句子$X$的每个单词经过Encoder编码而成的，也就意味着句子$X$中的关键词对生成任意目标词的影响力是相同的。\n\n<img src=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/pictures/v2-db380a8bf032afa9533d358389de99d6_hd.jpg?raw=true\" width=500>\n\n\n\n第一篇论文在Encoder-Decoder的基础上引入注意力机制，来解决上述注意力分散的问题。在论文中提出，每个目标词生成时使用的语义向量是不同的，也就是说Encoder-Decoder将会学会在生成目标词时给每个源语词分配权重，这个权重表示该源语词对当前目标词的重要程度。增加了attention机制的Encoder-Decoder框架如下图：\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/e9ba93ee15054825cb2c66a7180ef022.png?raw=true\" width=400 align=center>\n\n在基于attention的模型中，每个目标词生成时的条件概率可以写成：\n$$p(y_{i}|y_{<t},X)=g(y_{i-1},s_{i},c_{i})$$\n$$s_{i}=f(s_{i-1},y_{i-1},c_{i})$$\n\n在RNN中每个时刻的隐状态$h_{i}$可以表示第$i$个源语词及其周围部分词的信息，因此与之前的Encoder-Decoder框架不同，语义向量$c_{i}$不再是encoder RNN最后一个时刻的隐状态，而是与encoder RNN所有时刻的隐状态（$h_{1},...,h_{T_{x}}$）相关的一个向量。\n\n$$c_{i}=\\sum_{j=1}^{T_{x}}\\alpha_{ij}h_{j}$$\n$\\alpha_{ij}$可以认为是目标词$i$与源语词$j$的对齐权重，因此可以使用源语词$i$的隐状态$h_{i}$和目标词前一时刻的隐状态$s_{i-1}$来计算。\n$$\\alpha_{ij}=\\frac{\\exp(e_{ij})}{\\sum_{k=1}^{T_{x}}\\exp(e_{ik})}$$\n其中\n$$e_{ij}=a(s_{i-1},h_{j})$$\n$a$是一个对齐模型，在Bahdanau的论文中将其定义成一个前馈神经网络，与Encoder-Decoder一起参与训练。计算公式如下：\n$$a(s_{i-1},h_{j})=v_{a}^\\mathsf{T}\\cdot tanh(W_{a}s_{i-1}+U_{a}h_{j}) $$\n$v_{a}$、$W_{a}$和$U_{a}$都是对齐模型的参数。在第二篇ThangLuong的论文中提出下面三种计算方式，本质上也是大同小异。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/667d0e7417d384138f961490ff0745c3.png?raw=true\" width=400 align=center>\n\n下图是Bahdanau在论文中给出的一个模拟图，图中模拟的是在给定源语序列（$X_{1},X_{2},...,X_{T}$）的情况下生成第$t$个目标词$y_{t}$的过程。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/970f70807791925f3f8f54266e0a8435.png?raw=true\" width=300 align=center>\n\n\n\n## Encoder\n\n在Bahdanau的论文中Encoder和Decoder使用的都是GRU（Gated Recurrent Unit），GRU与LSTM一样都是RNN众多变体中比较常见的一种，也可以使用其他变体RNN，比如在ThangLuong的论文中主要用的就是LSTM。\n\n我们知道传统的RNN理论上可以记忆无限长的序列，但由于递归权重对每个时刻的输入都是一样的，这就导致一个二选一的问题：(1) 模型发散，无法收敛（2）梯度消失，无法产生长时记忆。GRU和LSTM一样，都是通过引入门（gate）的机制来解决传统RNN梯度消失的问题，gate打开和关闭是由当前时刻的输入和前一时刻的隐层状态控制的，也就是说每个时刻gate的状态都是不同的，一些需要长时间记忆的信息会通过gate一直传递下去，从而学习到长距离依赖。\n\n传统RNN的隐层计算公式：$h_{t}=g(W^{hh}h_{t-1}+W^{hx}x_{t})$，$W^{hh}$是递归权重，$W^{hx}$是隐层的权重。实际上，LSTM和GRU都可以认为是对$h_{t}$计算方式的改进。\n\n下面是GRU结构的示意图，输入为$h_{t-1}$和$x_{t}$，输出为$h_{t}$。在GRU中存在两个gate，一个是reset gate，一个是update gate，分别对应下图中的$r_{t}$和$z_{t}$，$\\widetilde h_{t}$表示候选隐层状态，候选隐层状态与上一时刻的隐层状态$h_{t-1}$一起更新当前时刻的隐层状态$h_{t}$。\n\n<img src=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/pictures/rnn-gru-unit.png?raw=true\" width=400 align=center>\n\nGRU的计算过程：   \n1、首先计算重置门$r_{t}$和更新门$z_{t}$，其中$\\sigma$表示sigmoid函数\n$$r_{t}=\\sigma(W^{r}x_{t}+U^{r}h_{t-1})$$\n$$z_{t}=\\sigma(W^{z}x_{t}+U^{z}h_{t-1})$$\n2、计算候选隐层状态$\\widetilde h_{t}$，其中$r_{t}$用来控制历史记忆的传递，如果$r_{t}=0$，那么$\\widetilde h_{t}$只与当前输入$x_{t}$有关，历史记忆被重置。\n$$\\widetilde h_{t}=tanh(Wx_{t}+U[r_{t}\\odot h_{t-1}])$$\n实际上仅仅增加一个reset gate就已经可以解决长时依赖的问题，因为如果有需要$r_{t}$可以总等于1，那么历史记忆就会一直传递下去。但这会带来一个问题，$h_{t-1}$会累加到当前时刻的隐层状态上产生新的记忆，不断累加的记忆会导致$\\widetilde h_{t}$达到饱和，最终导致模型无法收敛。为了解决这个问题，GRU可以选择对当前输入产生的新记忆进行遗忘，只传递之前的历史记忆，也就是说我们允许GRU舍弃一些对后续无关的输入信息，保证记忆都是有效信息。GRU是通过下面的更新操作来实现这个过程的，\n$$h_{t}=z_{t}\\odot h_{t-1}+(1-z_{t})\\odot \\widetilde h_{t}$$\n$z_{i}$反映了相对历史记忆当前输入信息的重要程度，$z_{i}$越小表明当前输入信息越重要。\n\n实际上在Bahdanau的论文中使用的是双向RNN（BiRNN），BiRNN在前向RNN的基础上增加了一个反向RNN，使得RNN可以同时看到历史和未来的信息，最终前向RNN的隐层状态和反向RNN的隐层状态拼接后输出。\n\n$$h_{i}=\\left [ \\begin{align} & \\vec{h_{i}} \\\\ & \\stackrel{\\leftarrow}{h_{i}} \\end{align}\\right ]$$\n\n\n\n## Decoder\n\n在Bahdanau的论文中decoder采用是一个前向的GRU，但与encoder GRU不同的是decoder GRU需要额外输入语义向量$c_{i}$。decoder GRU隐层状态$s_{i}$的计算如下：\n$$s_{i}=(1-z_{i})\\odot s_{i-1}+z_{i}\\odot \\widetilde s_{i}$$\n其中，   \n$$\\widetilde s_{i}=tanh(Wy_{i-1}+U[r_{i}\\odot s_{i-1}]+Cc_{i})$$\n$$r_{i}=\\sigma(W_{r}y_{i-1}+U_{r}s_{i-1}+C_{r}c_{i})$$\n$$z_{i}=\\sigma(W_{z}y_{i-1}+U_{z}s_{i-1}+C_{z}c_{i})$$\nencoder GRU的隐层状态会被传递到decoder GRU用于生成第一个目标词，所以decoder GRU的隐层状态的初始值不是0，而是将encoder中反向GRU第一个时刻的隐层状态直接复制给decoder GRU，即$s_{0}=tanh(W_{s}\\stackrel{\\leftarrow}{h_{1}})$。\n\n\n\n## beam search\n","source":"_posts/seq2seq串讲.md","raw":"---\n\ntitle: NEURAL MACHINE TRANSLATION论文学习串讲\n\ndate: 2017-12-01 12:24:08\n\ncategory: neural machine translation\n\ntags: [seq2seq, machine translation, Encoder-Decoder, Attention]\n\n---\n\n## seq2seq\n\n主要学习的是论文Neural machine translation by jointly learning to align and translate (Dzmitry Bahdanau、Yoshua Bengio等，2016.05)和Neural machine translation (Minh-ThangLuong，2016.12)。\n\n神经机器翻译的目的是将一门语言的文本序列翻译成另一门语言的文本序列，因此机器翻译的训练语料一般是源语言和目标语言组成的一对文本，也叫做平行语料(parallel corpus)。我们通常将输入和输出都是序列的模型叫做seq2seq，seq2seq不仅应用在机器翻译领域，也用于当前热门的自动问答系统以及文本摘要的自动生成等领域。\n\n<!-- more -->\n\n## Encoder-Decoder\n\n2014年Dzmitry Bahdanau、Yoshua Bengio等人在论文Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation中首次提出将RNN Encoder-Decoder结构来计算双语短语对的条件概率，用于改进统计机器翻译的效果。Encoder-Decoder是由encoder和decoder两部分组成，encoder将输入序列编码成定长的语义向量，decoder将语义向量进行解码得到目标序列。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/12c7a5370bc9da07193c0bd43c5b27cd.png?raw=true\" width=500 align=center>\n\n在NMT中Encoder-Decoder试图直接对并行语料的条件概率$P(Y|X)$进行建模，encoder输入的是一组向量序列$X=(x_{1},…,x_{T_{x}})$，$x_i$为词$i$的one-hot编码向量，并将序列$X$编码成语义向量$c$，decoder输入语义向量$c$，并逐个生成序列$Y=(y_{1},…,y_{T_{y}})$，其中$y_{i}$的生成与之前已经生成的词序列$y_{1},…,y_{i-1}$有关。\n\n$$\\log p(Y|X)=\\sum_{t=1}^{T_{y}}\\log p(y_{t}|y_{<t}, c)$$\n\n对于不定长度序列的编码和解码，我们很自然会想到RNN，实际上RNN Encoder–Decoder就是正反两组RNN拼接在一起组成的编码解码网络。经典的RNN Encoder–Decoder示意图如下：\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/ab3551f2c0f12a3bc50283e49e09e52c.png?raw=true\" width=400 align=center />\n\n我们可以用下面公式描述编码过程：\n$$h_{t}=f(x_{t},h_{t-1})$$\n$$c=q({h_{1},…,h_{T_{x}}})$$\n\n函数$f$一般用一个RNN结构来表示，可以是LSTM、GRU等，$h_{t}$表示encoder RNN在第t时刻的cell隐状态，向量c的计算与encoder RNN所有时刻的cell隐状态相关，函数$q$可以表示所有隐状态的加权和，但由于RNN的特殊性，我们这里只使用最后一个时刻的隐状态作为向量$c$，即$c=h_{T_{x}}$。\n\n对于解码过程，生成$y_{t}$时的条件概率可以改写成\n\n$$p(y_{t}|y_{<t},c)=g(y_{t-1},s_{t},c)$$\n$$s_{t}=f(s_{t-1},y_{t-1},c)$$\n\n其中，$g$是非线性函数，可以是单层的softmax，也可以是一个多层结构的神经网络，$y_{t-1}$表示上一时刻的输出，$f$同样是一个RNN结构，$s_{t}$表示decoder RNN cell的隐状态。\n\n\n\n## Attention\n\n在Encoder-Decoder中每个目标词生成时使用的都是同一个向量$c$，虽然理论上来讲向量$c$可以表示输入序列的语义信息，比如一些关键词、句子结构和语法信息等，但也存在注意力分散的问题。在机器翻译中，一般翻译出来的词与源序列的词是有对齐关系的，也就是说目标词的生成与源序列中的部分关键词关系更大，而其他词对当前目标词的生成影响就很小。在Encoder-Decoder中不论生成哪个目标词，使用的语义向量都是$c$，而语义向量$c$是由句子$X$的每个单词经过Encoder编码而成的，也就意味着句子$X$中的关键词对生成任意目标词的影响力是相同的。\n\n<img src=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/pictures/v2-db380a8bf032afa9533d358389de99d6_hd.jpg?raw=true\" width=500>\n\n\n\n第一篇论文在Encoder-Decoder的基础上引入注意力机制，来解决上述注意力分散的问题。在论文中提出，每个目标词生成时使用的语义向量是不同的，也就是说Encoder-Decoder将会学会在生成目标词时给每个源语词分配权重，这个权重表示该源语词对当前目标词的重要程度。增加了attention机制的Encoder-Decoder框架如下图：\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/e9ba93ee15054825cb2c66a7180ef022.png?raw=true\" width=400 align=center>\n\n在基于attention的模型中，每个目标词生成时的条件概率可以写成：\n$$p(y_{i}|y_{<t},X)=g(y_{i-1},s_{i},c_{i})$$\n$$s_{i}=f(s_{i-1},y_{i-1},c_{i})$$\n\n在RNN中每个时刻的隐状态$h_{i}$可以表示第$i$个源语词及其周围部分词的信息，因此与之前的Encoder-Decoder框架不同，语义向量$c_{i}$不再是encoder RNN最后一个时刻的隐状态，而是与encoder RNN所有时刻的隐状态（$h_{1},...,h_{T_{x}}$）相关的一个向量。\n\n$$c_{i}=\\sum_{j=1}^{T_{x}}\\alpha_{ij}h_{j}$$\n$\\alpha_{ij}$可以认为是目标词$i$与源语词$j$的对齐权重，因此可以使用源语词$i$的隐状态$h_{i}$和目标词前一时刻的隐状态$s_{i-1}$来计算。\n$$\\alpha_{ij}=\\frac{\\exp(e_{ij})}{\\sum_{k=1}^{T_{x}}\\exp(e_{ik})}$$\n其中\n$$e_{ij}=a(s_{i-1},h_{j})$$\n$a$是一个对齐模型，在Bahdanau的论文中将其定义成一个前馈神经网络，与Encoder-Decoder一起参与训练。计算公式如下：\n$$a(s_{i-1},h_{j})=v_{a}^\\mathsf{T}\\cdot tanh(W_{a}s_{i-1}+U_{a}h_{j}) $$\n$v_{a}$、$W_{a}$和$U_{a}$都是对齐模型的参数。在第二篇ThangLuong的论文中提出下面三种计算方式，本质上也是大同小异。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/667d0e7417d384138f961490ff0745c3.png?raw=true\" width=400 align=center>\n\n下图是Bahdanau在论文中给出的一个模拟图，图中模拟的是在给定源语序列（$X_{1},X_{2},...,X_{T}$）的情况下生成第$t$个目标词$y_{t}$的过程。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/970f70807791925f3f8f54266e0a8435.png?raw=true\" width=300 align=center>\n\n\n\n## Encoder\n\n在Bahdanau的论文中Encoder和Decoder使用的都是GRU（Gated Recurrent Unit），GRU与LSTM一样都是RNN众多变体中比较常见的一种，也可以使用其他变体RNN，比如在ThangLuong的论文中主要用的就是LSTM。\n\n我们知道传统的RNN理论上可以记忆无限长的序列，但由于递归权重对每个时刻的输入都是一样的，这就导致一个二选一的问题：(1) 模型发散，无法收敛（2）梯度消失，无法产生长时记忆。GRU和LSTM一样，都是通过引入门（gate）的机制来解决传统RNN梯度消失的问题，gate打开和关闭是由当前时刻的输入和前一时刻的隐层状态控制的，也就是说每个时刻gate的状态都是不同的，一些需要长时间记忆的信息会通过gate一直传递下去，从而学习到长距离依赖。\n\n传统RNN的隐层计算公式：$h_{t}=g(W^{hh}h_{t-1}+W^{hx}x_{t})$，$W^{hh}$是递归权重，$W^{hx}$是隐层的权重。实际上，LSTM和GRU都可以认为是对$h_{t}$计算方式的改进。\n\n下面是GRU结构的示意图，输入为$h_{t-1}$和$x_{t}$，输出为$h_{t}$。在GRU中存在两个gate，一个是reset gate，一个是update gate，分别对应下图中的$r_{t}$和$z_{t}$，$\\widetilde h_{t}$表示候选隐层状态，候选隐层状态与上一时刻的隐层状态$h_{t-1}$一起更新当前时刻的隐层状态$h_{t}$。\n\n<img src=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/pictures/rnn-gru-unit.png?raw=true\" width=400 align=center>\n\nGRU的计算过程：   \n1、首先计算重置门$r_{t}$和更新门$z_{t}$，其中$\\sigma$表示sigmoid函数\n$$r_{t}=\\sigma(W^{r}x_{t}+U^{r}h_{t-1})$$\n$$z_{t}=\\sigma(W^{z}x_{t}+U^{z}h_{t-1})$$\n2、计算候选隐层状态$\\widetilde h_{t}$，其中$r_{t}$用来控制历史记忆的传递，如果$r_{t}=0$，那么$\\widetilde h_{t}$只与当前输入$x_{t}$有关，历史记忆被重置。\n$$\\widetilde h_{t}=tanh(Wx_{t}+U[r_{t}\\odot h_{t-1}])$$\n实际上仅仅增加一个reset gate就已经可以解决长时依赖的问题，因为如果有需要$r_{t}$可以总等于1，那么历史记忆就会一直传递下去。但这会带来一个问题，$h_{t-1}$会累加到当前时刻的隐层状态上产生新的记忆，不断累加的记忆会导致$\\widetilde h_{t}$达到饱和，最终导致模型无法收敛。为了解决这个问题，GRU可以选择对当前输入产生的新记忆进行遗忘，只传递之前的历史记忆，也就是说我们允许GRU舍弃一些对后续无关的输入信息，保证记忆都是有效信息。GRU是通过下面的更新操作来实现这个过程的，\n$$h_{t}=z_{t}\\odot h_{t-1}+(1-z_{t})\\odot \\widetilde h_{t}$$\n$z_{i}$反映了相对历史记忆当前输入信息的重要程度，$z_{i}$越小表明当前输入信息越重要。\n\n实际上在Bahdanau的论文中使用的是双向RNN（BiRNN），BiRNN在前向RNN的基础上增加了一个反向RNN，使得RNN可以同时看到历史和未来的信息，最终前向RNN的隐层状态和反向RNN的隐层状态拼接后输出。\n\n$$h_{i}=\\left [ \\begin{align} & \\vec{h_{i}} \\\\ & \\stackrel{\\leftarrow}{h_{i}} \\end{align}\\right ]$$\n\n\n\n## Decoder\n\n在Bahdanau的论文中decoder采用是一个前向的GRU，但与encoder GRU不同的是decoder GRU需要额外输入语义向量$c_{i}$。decoder GRU隐层状态$s_{i}$的计算如下：\n$$s_{i}=(1-z_{i})\\odot s_{i-1}+z_{i}\\odot \\widetilde s_{i}$$\n其中，   \n$$\\widetilde s_{i}=tanh(Wy_{i-1}+U[r_{i}\\odot s_{i-1}]+Cc_{i})$$\n$$r_{i}=\\sigma(W_{r}y_{i-1}+U_{r}s_{i-1}+C_{r}c_{i})$$\n$$z_{i}=\\sigma(W_{z}y_{i-1}+U_{z}s_{i-1}+C_{z}c_{i})$$\nencoder GRU的隐层状态会被传递到decoder GRU用于生成第一个目标词，所以decoder GRU的隐层状态的初始值不是0，而是将encoder中反向GRU第一个时刻的隐层状态直接复制给decoder GRU，即$s_{0}=tanh(W_{s}\\stackrel{\\leftarrow}{h_{1}})$。\n\n\n\n## beam search\n","slug":"seq2seq串讲","published":1,"updated":"2023-01-03T13:53:27.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgavftr000ehbeq2z92hvfe","content":"<h2 id=\"seq2seq\">seq2seq</h2>\n<p>主要学习的是论文Neural machine translation by jointly learning to\nalign and translate (Dzmitry Bahdanau、Yoshua Bengio等，2016.05)和Neural\nmachine translation (Minh-ThangLuong，2016.12)。</p>\n<p>神经机器翻译的目的是将一门语言的文本序列翻译成另一门语言的文本序列，因此机器翻译的训练语料一般是源语言和目标语言组成的一对文本，也叫做平行语料(parallel\ncorpus)。我们通常将输入和输出都是序列的模型叫做seq2seq，seq2seq不仅应用在机器翻译领域，也用于当前热门的自动问答系统以及文本摘要的自动生成等领域。</p>\n<span id=\"more\"></span>\n<h2 id=\"encoder-decoder\">Encoder-Decoder</h2>\n<p>2014年Dzmitry Bahdanau、Yoshua Bengio等人在论文Learning Phrase\nRepresentations using RNN Encoder–Decoder for Statistical Machine\nTranslation中首次提出将RNN\nEncoder-Decoder结构来计算双语短语对的条件概率，用于改进统计机器翻译的效果。Encoder-Decoder是由encoder和decoder两部分组成，encoder将输入序列编码成定长的语义向量，decoder将语义向量进行解码得到目标序列。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/12c7a5370bc9da07193c0bd43c5b27cd.png?raw=true\" width=500 align=center></p>\n<p>在NMT中Encoder-Decoder试图直接对并行语料的条件概率<span\nclass=\"math inline\">\\(P(Y|X)\\)</span>进行建模，encoder输入的是一组向量序列<span\nclass=\"math inline\">\\(X=(x_{1},…,x_{T_{x}})\\)</span>，<span\nclass=\"math inline\">\\(x_i\\)</span>为词<span\nclass=\"math inline\">\\(i\\)</span>的one-hot编码向量，并将序列<span\nclass=\"math inline\">\\(X\\)</span>编码成语义向量<span\nclass=\"math inline\">\\(c\\)</span>，decoder输入语义向量<span\nclass=\"math inline\">\\(c\\)</span>，并逐个生成序列<span\nclass=\"math inline\">\\(Y=(y_{1},…,y_{T_{y}})\\)</span>，其中<span\nclass=\"math inline\">\\(y_{i}\\)</span>的生成与之前已经生成的词序列<span\nclass=\"math inline\">\\(y_{1},…,y_{i-1}\\)</span>有关。</p>\n<p><span class=\"math display\">\\[\\log p(Y|X)=\\sum_{t=1}^{T_{y}}\\log\np(y_{t}|y_{&lt;t}, c)\\]</span></p>\n<p>对于不定长度序列的编码和解码，我们很自然会想到RNN，实际上RNN\nEncoder–Decoder就是正反两组RNN拼接在一起组成的编码解码网络。经典的RNN\nEncoder–Decoder示意图如下：</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/ab3551f2c0f12a3bc50283e49e09e52c.png?raw=true\" width=400 align=center /></p>\n<p>我们可以用下面公式描述编码过程： <span\nclass=\"math display\">\\[h_{t}=f(x_{t},h_{t-1})\\]</span> <span\nclass=\"math display\">\\[c=q({h_{1},…,h_{T_{x}}})\\]</span></p>\n<p>函数<span\nclass=\"math inline\">\\(f\\)</span>一般用一个RNN结构来表示，可以是LSTM、GRU等，<span\nclass=\"math inline\">\\(h_{t}\\)</span>表示encoder\nRNN在第t时刻的cell隐状态，向量c的计算与encoder\nRNN所有时刻的cell隐状态相关，函数<span\nclass=\"math inline\">\\(q\\)</span>可以表示所有隐状态的加权和，但由于RNN的特殊性，我们这里只使用最后一个时刻的隐状态作为向量<span\nclass=\"math inline\">\\(c\\)</span>，即<span\nclass=\"math inline\">\\(c=h_{T_{x}}\\)</span>。</p>\n<p>对于解码过程，生成<span\nclass=\"math inline\">\\(y_{t}\\)</span>时的条件概率可以改写成</p>\n<p><span\nclass=\"math display\">\\[p(y_{t}|y_{&lt;t},c)=g(y_{t-1},s_{t},c)\\]</span>\n<span class=\"math display\">\\[s_{t}=f(s_{t-1},y_{t-1},c)\\]</span></p>\n<p>其中，<span\nclass=\"math inline\">\\(g\\)</span>是非线性函数，可以是单层的softmax，也可以是一个多层结构的神经网络，<span\nclass=\"math inline\">\\(y_{t-1}\\)</span>表示上一时刻的输出，<span\nclass=\"math inline\">\\(f\\)</span>同样是一个RNN结构，<span\nclass=\"math inline\">\\(s_{t}\\)</span>表示decoder RNN cell的隐状态。</p>\n<h2 id=\"attention\">Attention</h2>\n<p>在Encoder-Decoder中每个目标词生成时使用的都是同一个向量<span\nclass=\"math inline\">\\(c\\)</span>，虽然理论上来讲向量<span\nclass=\"math inline\">\\(c\\)</span>可以表示输入序列的语义信息，比如一些关键词、句子结构和语法信息等，但也存在注意力分散的问题。在机器翻译中，一般翻译出来的词与源序列的词是有对齐关系的，也就是说目标词的生成与源序列中的部分关键词关系更大，而其他词对当前目标词的生成影响就很小。在Encoder-Decoder中不论生成哪个目标词，使用的语义向量都是<span\nclass=\"math inline\">\\(c\\)</span>，而语义向量<span\nclass=\"math inline\">\\(c\\)</span>是由句子<span\nclass=\"math inline\">\\(X\\)</span>的每个单词经过Encoder编码而成的，也就意味着句子<span\nclass=\"math inline\">\\(X\\)</span>中的关键词对生成任意目标词的影响力是相同的。</p>\n<p><img src=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/pictures/v2-db380a8bf032afa9533d358389de99d6_hd.jpg?raw=true\" width=500></p>\n<p>第一篇论文在Encoder-Decoder的基础上引入注意力机制，来解决上述注意力分散的问题。在论文中提出，每个目标词生成时使用的语义向量是不同的，也就是说Encoder-Decoder将会学会在生成目标词时给每个源语词分配权重，这个权重表示该源语词对当前目标词的重要程度。增加了attention机制的Encoder-Decoder框架如下图：</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/e9ba93ee15054825cb2c66a7180ef022.png?raw=true\" width=400 align=center></p>\n<p>在基于attention的模型中，每个目标词生成时的条件概率可以写成： <span\nclass=\"math display\">\\[p(y_{i}|y_{&lt;t},X)=g(y_{i-1},s_{i},c_{i})\\]</span>\n<span class=\"math display\">\\[s_{i}=f(s_{i-1},y_{i-1},c_{i})\\]</span></p>\n<p>在RNN中每个时刻的隐状态<span\nclass=\"math inline\">\\(h_{i}\\)</span>可以表示第<span\nclass=\"math inline\">\\(i\\)</span>个源语词及其周围部分词的信息，因此与之前的Encoder-Decoder框架不同，语义向量<span\nclass=\"math inline\">\\(c_{i}\\)</span>不再是encoder\nRNN最后一个时刻的隐状态，而是与encoder RNN所有时刻的隐状态（<span\nclass=\"math inline\">\\(h_{1},...,h_{T_{x}}\\)</span>）相关的一个向量。</p>\n<p><span\nclass=\"math display\">\\[c_{i}=\\sum_{j=1}^{T_{x}}\\alpha_{ij}h_{j}\\]</span>\n<span class=\"math inline\">\\(\\alpha_{ij}\\)</span>可以认为是目标词<span\nclass=\"math inline\">\\(i\\)</span>与源语词<span\nclass=\"math inline\">\\(j\\)</span>的对齐权重，因此可以使用源语词<span\nclass=\"math inline\">\\(i\\)</span>的隐状态<span\nclass=\"math inline\">\\(h_{i}\\)</span>和目标词前一时刻的隐状态<span\nclass=\"math inline\">\\(s_{i-1}\\)</span>来计算。 <span\nclass=\"math display\">\\[\\alpha_{ij}=\\frac{\\exp(e_{ij})}{\\sum_{k=1}^{T_{x}}\\exp(e_{ik})}\\]</span>\n其中 <span class=\"math display\">\\[e_{ij}=a(s_{i-1},h_{j})\\]</span> <span\nclass=\"math inline\">\\(a\\)</span>是一个对齐模型，在Bahdanau的论文中将其定义成一个前馈神经网络，与Encoder-Decoder一起参与训练。计算公式如下：\n<span class=\"math display\">\\[a(s_{i-1},h_{j})=v_{a}^\\mathsf{T}\\cdot\ntanh(W_{a}s_{i-1}+U_{a}h_{j}) \\]</span> <span\nclass=\"math inline\">\\(v_{a}\\)</span>、<span\nclass=\"math inline\">\\(W_{a}\\)</span>和<span\nclass=\"math inline\">\\(U_{a}\\)</span>都是对齐模型的参数。在第二篇ThangLuong的论文中提出下面三种计算方式，本质上也是大同小异。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/667d0e7417d384138f961490ff0745c3.png?raw=true\" width=400 align=center></p>\n<p>下图是Bahdanau在论文中给出的一个模拟图，图中模拟的是在给定源语序列（<span\nclass=\"math inline\">\\(X_{1},X_{2},...,X_{T}\\)</span>）的情况下生成第<span\nclass=\"math inline\">\\(t\\)</span>个目标词<span\nclass=\"math inline\">\\(y_{t}\\)</span>的过程。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/970f70807791925f3f8f54266e0a8435.png?raw=true\" width=300 align=center></p>\n<h2 id=\"encoder\">Encoder</h2>\n<p>在Bahdanau的论文中Encoder和Decoder使用的都是GRU（Gated Recurrent\nUnit），GRU与LSTM一样都是RNN众多变体中比较常见的一种，也可以使用其他变体RNN，比如在ThangLuong的论文中主要用的就是LSTM。</p>\n<p>我们知道传统的RNN理论上可以记忆无限长的序列，但由于递归权重对每个时刻的输入都是一样的，这就导致一个二选一的问题：(1)\n模型发散，无法收敛（2）梯度消失，无法产生长时记忆。GRU和LSTM一样，都是通过引入门（gate）的机制来解决传统RNN梯度消失的问题，gate打开和关闭是由当前时刻的输入和前一时刻的隐层状态控制的，也就是说每个时刻gate的状态都是不同的，一些需要长时间记忆的信息会通过gate一直传递下去，从而学习到长距离依赖。</p>\n<p>传统RNN的隐层计算公式：<span\nclass=\"math inline\">\\(h_{t}=g(W^{hh}h_{t-1}+W^{hx}x_{t})\\)</span>，<span\nclass=\"math inline\">\\(W^{hh}\\)</span>是递归权重，<span\nclass=\"math inline\">\\(W^{hx}\\)</span>是隐层的权重。实际上，LSTM和GRU都可以认为是对<span\nclass=\"math inline\">\\(h_{t}\\)</span>计算方式的改进。</p>\n<p>下面是GRU结构的示意图，输入为<span\nclass=\"math inline\">\\(h_{t-1}\\)</span>和<span\nclass=\"math inline\">\\(x_{t}\\)</span>，输出为<span\nclass=\"math inline\">\\(h_{t}\\)</span>。在GRU中存在两个gate，一个是reset\ngate，一个是update gate，分别对应下图中的<span\nclass=\"math inline\">\\(r_{t}\\)</span>和<span\nclass=\"math inline\">\\(z_{t}\\)</span>，<span\nclass=\"math inline\">\\(\\widetilde\nh_{t}\\)</span>表示候选隐层状态，候选隐层状态与上一时刻的隐层状态<span\nclass=\"math inline\">\\(h_{t-1}\\)</span>一起更新当前时刻的隐层状态<span\nclass=\"math inline\">\\(h_{t}\\)</span>。</p>\n<p><img src=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/pictures/rnn-gru-unit.png?raw=true\" width=400 align=center></p>\n<p>GRU的计算过程：<br />\n1、首先计算重置门<span class=\"math inline\">\\(r_{t}\\)</span>和更新门<span\nclass=\"math inline\">\\(z_{t}\\)</span>，其中<span\nclass=\"math inline\">\\(\\sigma\\)</span>表示sigmoid函数 <span\nclass=\"math display\">\\[r_{t}=\\sigma(W^{r}x_{t}+U^{r}h_{t-1})\\]</span>\n<span\nclass=\"math display\">\\[z_{t}=\\sigma(W^{z}x_{t}+U^{z}h_{t-1})\\]</span>\n2、计算候选隐层状态<span class=\"math inline\">\\(\\widetilde\nh_{t}\\)</span>，其中<span\nclass=\"math inline\">\\(r_{t}\\)</span>用来控制历史记忆的传递，如果<span\nclass=\"math inline\">\\(r_{t}=0\\)</span>，那么<span\nclass=\"math inline\">\\(\\widetilde h_{t}\\)</span>只与当前输入<span\nclass=\"math inline\">\\(x_{t}\\)</span>有关，历史记忆被重置。 <span\nclass=\"math display\">\\[\\widetilde h_{t}=tanh(Wx_{t}+U[r_{t}\\odot\nh_{t-1}])\\]</span> 实际上仅仅增加一个reset\ngate就已经可以解决长时依赖的问题，因为如果有需要<span\nclass=\"math inline\">\\(r_{t}\\)</span>可以总等于1，那么历史记忆就会一直传递下去。但这会带来一个问题，<span\nclass=\"math inline\">\\(h_{t-1}\\)</span>会累加到当前时刻的隐层状态上产生新的记忆，不断累加的记忆会导致<span\nclass=\"math inline\">\\(\\widetilde\nh_{t}\\)</span>达到饱和，最终导致模型无法收敛。为了解决这个问题，GRU可以选择对当前输入产生的新记忆进行遗忘，只传递之前的历史记忆，也就是说我们允许GRU舍弃一些对后续无关的输入信息，保证记忆都是有效信息。GRU是通过下面的更新操作来实现这个过程的，\n<span class=\"math display\">\\[h_{t}=z_{t}\\odot h_{t-1}+(1-z_{t})\\odot\n\\widetilde h_{t}\\]</span> <span\nclass=\"math inline\">\\(z_{i}\\)</span>反映了相对历史记忆当前输入信息的重要程度，<span\nclass=\"math inline\">\\(z_{i}\\)</span>越小表明当前输入信息越重要。</p>\n<p>实际上在Bahdanau的论文中使用的是双向RNN（BiRNN），BiRNN在前向RNN的基础上增加了一个反向RNN，使得RNN可以同时看到历史和未来的信息，最终前向RNN的隐层状态和反向RNN的隐层状态拼接后输出。</p>\n<p><span class=\"math display\">\\[h_{i}=\\left [ \\begin{align} &amp;\n\\vec{h_{i}} \\\\ &amp; \\stackrel{\\leftarrow}{h_{i}} \\end{align}\\right\n]\\]</span></p>\n<h2 id=\"decoder\">Decoder</h2>\n<p>在Bahdanau的论文中decoder采用是一个前向的GRU，但与encoder\nGRU不同的是decoder GRU需要额外输入语义向量<span\nclass=\"math inline\">\\(c_{i}\\)</span>。decoder GRU隐层状态<span\nclass=\"math inline\">\\(s_{i}\\)</span>的计算如下： <span\nclass=\"math display\">\\[s_{i}=(1-z_{i})\\odot s_{i-1}+z_{i}\\odot\n\\widetilde s_{i}\\]</span> 其中，<br />\n<span class=\"math display\">\\[\\widetilde s_{i}=tanh(Wy_{i-1}+U[r_{i}\\odot\ns_{i-1}]+Cc_{i})\\]</span> <span\nclass=\"math display\">\\[r_{i}=\\sigma(W_{r}y_{i-1}+U_{r}s_{i-1}+C_{r}c_{i})\\]</span>\n<span\nclass=\"math display\">\\[z_{i}=\\sigma(W_{z}y_{i-1}+U_{z}s_{i-1}+C_{z}c_{i})\\]</span>\nencoder GRU的隐层状态会被传递到decoder\nGRU用于生成第一个目标词，所以decoder\nGRU的隐层状态的初始值不是0，而是将encoder中反向GRU第一个时刻的隐层状态直接复制给decoder\nGRU，即<span\nclass=\"math inline\">\\(s_{0}=tanh(W_{s}\\stackrel{\\leftarrow}{h_{1}})\\)</span>。</p>\n<h2 id=\"beam-search\">beam search</h2>\n","site":{"data":{}},"excerpt":"<h2 id=\"seq2seq\">seq2seq</h2>\n<p>主要学习的是论文Neural machine translation by jointly learning to\nalign and translate (Dzmitry Bahdanau、Yoshua Bengio等，2016.05)和Neural\nmachine translation (Minh-ThangLuong，2016.12)。</p>\n<p>神经机器翻译的目的是将一门语言的文本序列翻译成另一门语言的文本序列，因此机器翻译的训练语料一般是源语言和目标语言组成的一对文本，也叫做平行语料(parallel\ncorpus)。我们通常将输入和输出都是序列的模型叫做seq2seq，seq2seq不仅应用在机器翻译领域，也用于当前热门的自动问答系统以及文本摘要的自动生成等领域。</p>","more":"<h2 id=\"encoder-decoder\">Encoder-Decoder</h2>\n<p>2014年Dzmitry Bahdanau、Yoshua Bengio等人在论文Learning Phrase\nRepresentations using RNN Encoder–Decoder for Statistical Machine\nTranslation中首次提出将RNN\nEncoder-Decoder结构来计算双语短语对的条件概率，用于改进统计机器翻译的效果。Encoder-Decoder是由encoder和decoder两部分组成，encoder将输入序列编码成定长的语义向量，decoder将语义向量进行解码得到目标序列。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/12c7a5370bc9da07193c0bd43c5b27cd.png?raw=true\" width=500 align=center></p>\n<p>在NMT中Encoder-Decoder试图直接对并行语料的条件概率<span\nclass=\"math inline\">\\(P(Y|X)\\)</span>进行建模，encoder输入的是一组向量序列<span\nclass=\"math inline\">\\(X=(x_{1},…,x_{T_{x}})\\)</span>，<span\nclass=\"math inline\">\\(x_i\\)</span>为词<span\nclass=\"math inline\">\\(i\\)</span>的one-hot编码向量，并将序列<span\nclass=\"math inline\">\\(X\\)</span>编码成语义向量<span\nclass=\"math inline\">\\(c\\)</span>，decoder输入语义向量<span\nclass=\"math inline\">\\(c\\)</span>，并逐个生成序列<span\nclass=\"math inline\">\\(Y=(y_{1},…,y_{T_{y}})\\)</span>，其中<span\nclass=\"math inline\">\\(y_{i}\\)</span>的生成与之前已经生成的词序列<span\nclass=\"math inline\">\\(y_{1},…,y_{i-1}\\)</span>有关。</p>\n<p><span class=\"math display\">\\[\\log p(Y|X)=\\sum_{t=1}^{T_{y}}\\log\np(y_{t}|y_{&lt;t}, c)\\]</span></p>\n<p>对于不定长度序列的编码和解码，我们很自然会想到RNN，实际上RNN\nEncoder–Decoder就是正反两组RNN拼接在一起组成的编码解码网络。经典的RNN\nEncoder–Decoder示意图如下：</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/ab3551f2c0f12a3bc50283e49e09e52c.png?raw=true\" width=400 align=center /></p>\n<p>我们可以用下面公式描述编码过程： <span\nclass=\"math display\">\\[h_{t}=f(x_{t},h_{t-1})\\]</span> <span\nclass=\"math display\">\\[c=q({h_{1},…,h_{T_{x}}})\\]</span></p>\n<p>函数<span\nclass=\"math inline\">\\(f\\)</span>一般用一个RNN结构来表示，可以是LSTM、GRU等，<span\nclass=\"math inline\">\\(h_{t}\\)</span>表示encoder\nRNN在第t时刻的cell隐状态，向量c的计算与encoder\nRNN所有时刻的cell隐状态相关，函数<span\nclass=\"math inline\">\\(q\\)</span>可以表示所有隐状态的加权和，但由于RNN的特殊性，我们这里只使用最后一个时刻的隐状态作为向量<span\nclass=\"math inline\">\\(c\\)</span>，即<span\nclass=\"math inline\">\\(c=h_{T_{x}}\\)</span>。</p>\n<p>对于解码过程，生成<span\nclass=\"math inline\">\\(y_{t}\\)</span>时的条件概率可以改写成</p>\n<p><span\nclass=\"math display\">\\[p(y_{t}|y_{&lt;t},c)=g(y_{t-1},s_{t},c)\\]</span>\n<span class=\"math display\">\\[s_{t}=f(s_{t-1},y_{t-1},c)\\]</span></p>\n<p>其中，<span\nclass=\"math inline\">\\(g\\)</span>是非线性函数，可以是单层的softmax，也可以是一个多层结构的神经网络，<span\nclass=\"math inline\">\\(y_{t-1}\\)</span>表示上一时刻的输出，<span\nclass=\"math inline\">\\(f\\)</span>同样是一个RNN结构，<span\nclass=\"math inline\">\\(s_{t}\\)</span>表示decoder RNN cell的隐状态。</p>\n<h2 id=\"attention\">Attention</h2>\n<p>在Encoder-Decoder中每个目标词生成时使用的都是同一个向量<span\nclass=\"math inline\">\\(c\\)</span>，虽然理论上来讲向量<span\nclass=\"math inline\">\\(c\\)</span>可以表示输入序列的语义信息，比如一些关键词、句子结构和语法信息等，但也存在注意力分散的问题。在机器翻译中，一般翻译出来的词与源序列的词是有对齐关系的，也就是说目标词的生成与源序列中的部分关键词关系更大，而其他词对当前目标词的生成影响就很小。在Encoder-Decoder中不论生成哪个目标词，使用的语义向量都是<span\nclass=\"math inline\">\\(c\\)</span>，而语义向量<span\nclass=\"math inline\">\\(c\\)</span>是由句子<span\nclass=\"math inline\">\\(X\\)</span>的每个单词经过Encoder编码而成的，也就意味着句子<span\nclass=\"math inline\">\\(X\\)</span>中的关键词对生成任意目标词的影响力是相同的。</p>\n<p><img src=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/pictures/v2-db380a8bf032afa9533d358389de99d6_hd.jpg?raw=true\" width=500></p>\n<p>第一篇论文在Encoder-Decoder的基础上引入注意力机制，来解决上述注意力分散的问题。在论文中提出，每个目标词生成时使用的语义向量是不同的，也就是说Encoder-Decoder将会学会在生成目标词时给每个源语词分配权重，这个权重表示该源语词对当前目标词的重要程度。增加了attention机制的Encoder-Decoder框架如下图：</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/e9ba93ee15054825cb2c66a7180ef022.png?raw=true\" width=400 align=center></p>\n<p>在基于attention的模型中，每个目标词生成时的条件概率可以写成： <span\nclass=\"math display\">\\[p(y_{i}|y_{&lt;t},X)=g(y_{i-1},s_{i},c_{i})\\]</span>\n<span class=\"math display\">\\[s_{i}=f(s_{i-1},y_{i-1},c_{i})\\]</span></p>\n<p>在RNN中每个时刻的隐状态<span\nclass=\"math inline\">\\(h_{i}\\)</span>可以表示第<span\nclass=\"math inline\">\\(i\\)</span>个源语词及其周围部分词的信息，因此与之前的Encoder-Decoder框架不同，语义向量<span\nclass=\"math inline\">\\(c_{i}\\)</span>不再是encoder\nRNN最后一个时刻的隐状态，而是与encoder RNN所有时刻的隐状态（<span\nclass=\"math inline\">\\(h_{1},...,h_{T_{x}}\\)</span>）相关的一个向量。</p>\n<p><span\nclass=\"math display\">\\[c_{i}=\\sum_{j=1}^{T_{x}}\\alpha_{ij}h_{j}\\]</span>\n<span class=\"math inline\">\\(\\alpha_{ij}\\)</span>可以认为是目标词<span\nclass=\"math inline\">\\(i\\)</span>与源语词<span\nclass=\"math inline\">\\(j\\)</span>的对齐权重，因此可以使用源语词<span\nclass=\"math inline\">\\(i\\)</span>的隐状态<span\nclass=\"math inline\">\\(h_{i}\\)</span>和目标词前一时刻的隐状态<span\nclass=\"math inline\">\\(s_{i-1}\\)</span>来计算。 <span\nclass=\"math display\">\\[\\alpha_{ij}=\\frac{\\exp(e_{ij})}{\\sum_{k=1}^{T_{x}}\\exp(e_{ik})}\\]</span>\n其中 <span class=\"math display\">\\[e_{ij}=a(s_{i-1},h_{j})\\]</span> <span\nclass=\"math inline\">\\(a\\)</span>是一个对齐模型，在Bahdanau的论文中将其定义成一个前馈神经网络，与Encoder-Decoder一起参与训练。计算公式如下：\n<span class=\"math display\">\\[a(s_{i-1},h_{j})=v_{a}^\\mathsf{T}\\cdot\ntanh(W_{a}s_{i-1}+U_{a}h_{j}) \\]</span> <span\nclass=\"math inline\">\\(v_{a}\\)</span>、<span\nclass=\"math inline\">\\(W_{a}\\)</span>和<span\nclass=\"math inline\">\\(U_{a}\\)</span>都是对齐模型的参数。在第二篇ThangLuong的论文中提出下面三种计算方式，本质上也是大同小异。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/667d0e7417d384138f961490ff0745c3.png?raw=true\" width=400 align=center></p>\n<p>下图是Bahdanau在论文中给出的一个模拟图，图中模拟的是在给定源语序列（<span\nclass=\"math inline\">\\(X_{1},X_{2},...,X_{T}\\)</span>）的情况下生成第<span\nclass=\"math inline\">\\(t\\)</span>个目标词<span\nclass=\"math inline\">\\(y_{t}\\)</span>的过程。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/nmt/970f70807791925f3f8f54266e0a8435.png?raw=true\" width=300 align=center></p>\n<h2 id=\"encoder\">Encoder</h2>\n<p>在Bahdanau的论文中Encoder和Decoder使用的都是GRU（Gated Recurrent\nUnit），GRU与LSTM一样都是RNN众多变体中比较常见的一种，也可以使用其他变体RNN，比如在ThangLuong的论文中主要用的就是LSTM。</p>\n<p>我们知道传统的RNN理论上可以记忆无限长的序列，但由于递归权重对每个时刻的输入都是一样的，这就导致一个二选一的问题：(1)\n模型发散，无法收敛（2）梯度消失，无法产生长时记忆。GRU和LSTM一样，都是通过引入门（gate）的机制来解决传统RNN梯度消失的问题，gate打开和关闭是由当前时刻的输入和前一时刻的隐层状态控制的，也就是说每个时刻gate的状态都是不同的，一些需要长时间记忆的信息会通过gate一直传递下去，从而学习到长距离依赖。</p>\n<p>传统RNN的隐层计算公式：<span\nclass=\"math inline\">\\(h_{t}=g(W^{hh}h_{t-1}+W^{hx}x_{t})\\)</span>，<span\nclass=\"math inline\">\\(W^{hh}\\)</span>是递归权重，<span\nclass=\"math inline\">\\(W^{hx}\\)</span>是隐层的权重。实际上，LSTM和GRU都可以认为是对<span\nclass=\"math inline\">\\(h_{t}\\)</span>计算方式的改进。</p>\n<p>下面是GRU结构的示意图，输入为<span\nclass=\"math inline\">\\(h_{t-1}\\)</span>和<span\nclass=\"math inline\">\\(x_{t}\\)</span>，输出为<span\nclass=\"math inline\">\\(h_{t}\\)</span>。在GRU中存在两个gate，一个是reset\ngate，一个是update gate，分别对应下图中的<span\nclass=\"math inline\">\\(r_{t}\\)</span>和<span\nclass=\"math inline\">\\(z_{t}\\)</span>，<span\nclass=\"math inline\">\\(\\widetilde\nh_{t}\\)</span>表示候选隐层状态，候选隐层状态与上一时刻的隐层状态<span\nclass=\"math inline\">\\(h_{t-1}\\)</span>一起更新当前时刻的隐层状态<span\nclass=\"math inline\">\\(h_{t}\\)</span>。</p>\n<p><img src=\"https://coding.net/u/hjchen2/p/personal/git/raw/master/blog/pictures/rnn-gru-unit.png?raw=true\" width=400 align=center></p>\n<p>GRU的计算过程：<br />\n1、首先计算重置门<span class=\"math inline\">\\(r_{t}\\)</span>和更新门<span\nclass=\"math inline\">\\(z_{t}\\)</span>，其中<span\nclass=\"math inline\">\\(\\sigma\\)</span>表示sigmoid函数 <span\nclass=\"math display\">\\[r_{t}=\\sigma(W^{r}x_{t}+U^{r}h_{t-1})\\]</span>\n<span\nclass=\"math display\">\\[z_{t}=\\sigma(W^{z}x_{t}+U^{z}h_{t-1})\\]</span>\n2、计算候选隐层状态<span class=\"math inline\">\\(\\widetilde\nh_{t}\\)</span>，其中<span\nclass=\"math inline\">\\(r_{t}\\)</span>用来控制历史记忆的传递，如果<span\nclass=\"math inline\">\\(r_{t}=0\\)</span>，那么<span\nclass=\"math inline\">\\(\\widetilde h_{t}\\)</span>只与当前输入<span\nclass=\"math inline\">\\(x_{t}\\)</span>有关，历史记忆被重置。 <span\nclass=\"math display\">\\[\\widetilde h_{t}=tanh(Wx_{t}+U[r_{t}\\odot\nh_{t-1}])\\]</span> 实际上仅仅增加一个reset\ngate就已经可以解决长时依赖的问题，因为如果有需要<span\nclass=\"math inline\">\\(r_{t}\\)</span>可以总等于1，那么历史记忆就会一直传递下去。但这会带来一个问题，<span\nclass=\"math inline\">\\(h_{t-1}\\)</span>会累加到当前时刻的隐层状态上产生新的记忆，不断累加的记忆会导致<span\nclass=\"math inline\">\\(\\widetilde\nh_{t}\\)</span>达到饱和，最终导致模型无法收敛。为了解决这个问题，GRU可以选择对当前输入产生的新记忆进行遗忘，只传递之前的历史记忆，也就是说我们允许GRU舍弃一些对后续无关的输入信息，保证记忆都是有效信息。GRU是通过下面的更新操作来实现这个过程的，\n<span class=\"math display\">\\[h_{t}=z_{t}\\odot h_{t-1}+(1-z_{t})\\odot\n\\widetilde h_{t}\\]</span> <span\nclass=\"math inline\">\\(z_{i}\\)</span>反映了相对历史记忆当前输入信息的重要程度，<span\nclass=\"math inline\">\\(z_{i}\\)</span>越小表明当前输入信息越重要。</p>\n<p>实际上在Bahdanau的论文中使用的是双向RNN（BiRNN），BiRNN在前向RNN的基础上增加了一个反向RNN，使得RNN可以同时看到历史和未来的信息，最终前向RNN的隐层状态和反向RNN的隐层状态拼接后输出。</p>\n<p><span class=\"math display\">\\[h_{i}=\\left [ \\begin{align} &amp;\n\\vec{h_{i}} \\\\ &amp; \\stackrel{\\leftarrow}{h_{i}} \\end{align}\\right\n]\\]</span></p>\n<h2 id=\"decoder\">Decoder</h2>\n<p>在Bahdanau的论文中decoder采用是一个前向的GRU，但与encoder\nGRU不同的是decoder GRU需要额外输入语义向量<span\nclass=\"math inline\">\\(c_{i}\\)</span>。decoder GRU隐层状态<span\nclass=\"math inline\">\\(s_{i}\\)</span>的计算如下： <span\nclass=\"math display\">\\[s_{i}=(1-z_{i})\\odot s_{i-1}+z_{i}\\odot\n\\widetilde s_{i}\\]</span> 其中，<br />\n<span class=\"math display\">\\[\\widetilde s_{i}=tanh(Wy_{i-1}+U[r_{i}\\odot\ns_{i-1}]+Cc_{i})\\]</span> <span\nclass=\"math display\">\\[r_{i}=\\sigma(W_{r}y_{i-1}+U_{r}s_{i-1}+C_{r}c_{i})\\]</span>\n<span\nclass=\"math display\">\\[z_{i}=\\sigma(W_{z}y_{i-1}+U_{z}s_{i-1}+C_{z}c_{i})\\]</span>\nencoder GRU的隐层状态会被传递到decoder\nGRU用于生成第一个目标词，所以decoder\nGRU的隐层状态的初始值不是0，而是将encoder中反向GRU第一个时刻的隐层状态直接复制给decoder\nGRU，即<span\nclass=\"math inline\">\\(s_{0}=tanh(W_{s}\\stackrel{\\leftarrow}{h_{1}})\\)</span>。</p>\n<h2 id=\"beam-search\">beam search</h2>"},{"title":"强化学习（一）","date":"2017-03-27T04:31:08.000Z","_content":"\n## 前言\n近几年，由于DeepMind成功地将强化学习（reinforcement learning）运用在AlphaGo上，机器首次在复杂任务上取得了超过人类的表现，使得强化学习成为目前机器学习研究的前沿方向之一。强化学习由来已久，Sutton等在1979年就已经开始研究强化学习，1998年出版了强化学习介绍一书，并于2012年发布第二版，本文前几部分内容主要参考该书。\n\n<!-- more -->\n\n强化学习最早主要用于智能控制领域，比如机器人控制、电梯调度、电信通讯等，如今已经在自动驾驶、NLP、内容推荐<sup>[4]</sup>和语音交互领域都有相关的应用。2013年底DeepMind发表文章Playing Atari with Deep Reinforcement Learning，首次成功地将深度学习运用到强化学习任务上，通过无监督学习实现从纯图像输入来玩Atari 2600游戏的效果。而后DeepMind逐渐改进算法，使得DQN在Atari几乎一半的游戏中超过人类水平，以至2016年AlphaGo和无人车的出现，人们惊奇地发现人工智能即将颠覆我们的生活，甚至有人评论说传统的深度学习已经可以很好地感知理解了，强化学习可以利用这些感知生成策略，因而可以创造更高的机器智能。\n\n下面是DeepMind使用DQN让机器学习玩Atari 2600游戏的视频。\n<iframe width=\"895\" height=\"503\" src=\"https://www.youtube.com/embed/TmPfTpjtdgg\" frameborder=\"0\" allowfullscreen></iframe>\n\n## 什么是强化学习\nReinforcement learning is learning what to do—how to map situations to actions—so as to maximize a numerical reward signal<sup>[1]</sup>.\n\n强化学习研究的是智能体agent与环境之间交互的任务，也就是让agent像人类一样通过试错，不断地学习在不同的环境下做出最优的动作，而不是有监督地直接告诉agent在什么环境下应该做出什么动作。在这里我们需要引入回报（reward）这个概念，回报是执行一个动作或一系列动作后得到的奖励，比如在游戏超级玛丽中，向上跳可以获得一个金币，也就是回报值为1，而不跳时回报就是0。回报又分为立即回报和长期回报，立即回报指的是执行当前动作后能立刻获得的奖励，但很多时候我们执行一个动作后并不能立即得到回报，而是在游戏结束时才能返回一个回报值，这就是长期回报。强化学习唯一的准则就是学习通过一序列的最优动作，获得最大的长期回报。比较有挑战性的是，任一状态下做出的动作不仅影响当前状态的立即回报，而且也会影响到下一个状态，因此也就会影响整个执行过程的回报。\n\n因此，强化学习和监督学习的区别主要有以下两点<sup>[6]</sup>：\n\n1. 强化学习是试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳策略。\n2. 延迟回报，强化学习的指导信息很少，而且往往是在事后（最后一个状态）才给出的，这就导致了一个问题，就是获得正回报或者负回报以后，如何将回报分配给前面的状态。\n\n## 问题描述与MDP\n前面已经提到强化学习是尝试并发现回报最大动作的过程，下面就具体来描述一下这个过程。首先考虑一个问题，一个之前完全没有接触过国际象棋的小白怎样和一个专业棋手对弈。刚开始小白对棋面并没有任何概念，只能随机下，但假设双方每一轮下完后都会得到立即回报，比如吃子回报为1，被吃回报为-1，其他回报为0。可以想象一开始小白会输得很惨，但如果小白很聪明，随着不断地尝试小白不仅理解了下棋的规则，并且知道在什么棋面下做出什么动作可以吃更多的棋子。在这里我们将小白作为我们的智能体agent，棋面就是状态，下棋就是agent根据当前状态做出的动作，每个动作执行完后都会引起状态改变，如果状态的改变只与前一个状态和当前的动作有关，而与之前的状态和动作无关（即满足马尔可夫性），那么整个过程可以用马尔可夫决策过程（Markov Decision Processes）来描述，而Sutton在书中直接将满足马尔可夫性的强化学习任务定义为马尔可夫决策过程，并将状态和动作都是有限空间的MDP定义为有限马尔可夫决策过程（finite MDP）。\n\n下面引入一些定义<sup>[1]</sup>：马尔可夫决策过程是一个agent与环境交互的过程，因此有一个离散的时间序列，$t=0,1,2,3,...$，在每一个时刻$t$，agent都会接收一个用来表示环境的状态$S_{t}\\in\\bf{S}$，其中$\\bf{S}$表示所有可能状态的集合，并且在状态的基础上选择一个动作$A_{t}\\in{\\bf{A}}(S_{t})$，其中${\\bf{A}}(S_{t})$表示在状态$S_{t}$时所有可能采取的动作的集合，在$t$时刻agent采取一个动作后都会收到一个回报值$R_{t+1}\\in\\bf{R}$，然后接收一个新状态$S_{t+1}$。下图为整个过程的示意图。\n\n<div align=center><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/19e9ab8239fe6be8a413990a592b83c2.png?raw=true width=600></div>\n</br>\n在任意时刻和状态下，agent都可以选择一个动作，选择的依据就是我们说的策略—即状态到动作的映射$\\pi(a\\mid{s})$，而一个使得在任意时刻和状态下的长期回报都是最大的策略是我们最终需要得到的。所谓长期回报我们可以用每个时刻的立即回报来表示：\n\n$$G_{t}=R_{t+1}+R_{t+2}+R_{t+3}+...=\\sum_{k=t+1}^{\\infty}R_{k}\\tag{1.1}$$\n\n但实际上我们一般会用下面更通用的公式来代替：\n\n$$G_{t}=R_{t+1}+\\gamma{R_{t+2}}+\\gamma^2{R_{t+3}}+...+\\gamma^{T-t-1}{R_{T}}=\\sum_{k=0}^{T-t-1}\\gamma^{k}R_{t+k+1}\\tag{1.2}$$\n\n其中$\\gamma\\in[0,1]$称为回报折扣因子，表明了未来的回报相对于当前回报的重要程度。$\\gamma=0$时，相当于只考虑立即回报不考虑长期回报，$\\gamma=1$时，将长期回报和立即回报看得同等重要。$T\\in[1,\\infty]$表示完成一次实验过程的总步数，$T=\\infty$和$\\gamma=1$不能同时满足，否则长期回报将无法收敛。特别地，我们将一次有限步数的实验称作一个单独的episodes，也就是经过有限步数后最终会接收一个终止状态，这一类的任务也叫做episodic tasks。下面讨论的强化学习任务都是有限MDP的episodic tasks。\n\n### 马尔可夫决策过程\n一个有限马尔可夫决策过程由一个四元组构成 $M=({\\bf{S}}, {\\bf{A}}, {\\bf{P}}, {\\bf{R}})$<sup>[6]</sup>。如上所述，$\\bf{S}$表示状态集空间，${\\bf{A}}$表示动作集空间，${\\bf{P}}$表示状态转移概率矩阵，${\\bf{R}}$表示期望回报值。\n\n在MDP中给定任何一个状态$s\\in\\bf{S}$和动作$a\\in\\bf{A}$，都会以某个概率转移到下一个状态$s^{'}$，这个概率为$p(s^{'}\\mid s, a)={\\bf{Pr}}\\{S_{t+1}=s^{'}\\mid S_{t}=s, A_{t}=a\\}\\in\\bf{P}$，并获得下一个回报的期望值为$r(s,a,s^{'})={\\bf{E}}\\left[R_{t+1}\\mid{S_{t}=s,A_{t}=a,S_{t+1}=s^{'}}\\right]\\in\\bf{R}$。\n\n### 值函数及贝尔曼公式\n增强学习的最终结果是找到一个环境到动作的映射—即策略$\\pi(a\\mid{s})$。如果一个策略只考虑立即回报，那么很可能就会掉入眼前陷阱。比如说有一个岔路口，往左回报是100，往右回报是10，如果策略只考虑立即回报，那肯定是往左，但往左走的下一次回报只有10，而往右走的下一次回报有200，可以看到这个策略并不是最优的策略，此外增强学习又往往有具有延迟回报的特点，在很多情况下的动作并不会产生立即回报，但这一系列动作的累积效果又的确会导致后续回报的产生，因此立即回报并不能说明策略的好坏。在几乎所有的强化学习理论中都会定义值函数来表示给定策略下期望的未来回报，并将值函数作为评估学习效果的指标。\n\n值函数有多种定义，目前常见的是将值函数直接定义为未来回报的期望：\n\n$$\n\\upsilon_{\\pi}(s)={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right]={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s}\\right]\\tag{2.1}\n$$\n\n上面表示的是在某个策略$\\pi$下，当环境处于状态$s$时未来回报的期望，因此又叫做状态值函数(state-value function for policy)，只跟当前状态有关。同样，我们也可以定义动作值函数(action-value function for policy)，如下：\n\n$$\n\\begin{split}q_{\\pi}(s,a)&={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s,A_{t}=a}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s,A_{t}=a}\\right]\\end{split}\\tag{2.2}\n$$\n\n动作值函数表示在某个策略$\\pi$下，当环境处于状态$s$时采取动作$a$的未来回报的期望。可以看到动作值函数与状态值函数唯一的不同是动作值函数不仅指定了一个初始状态，而且也指定了初始动作，而状态值函数的初始动作是根据策略产生的。由于在MDP中，给定状态$s$，agent根据策略选择动作$a$，下个时刻将以概率$p(s^{'}\\mid{s,a})$转移到状态$s^{'}$，因此值函数又可以改写成如下形式：\n\n$$\n\\begin{split}\\upsilon_{\\pi}(s)&={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s}\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\cdot{\\bf E}_{\\pi}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}}\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma{\\bf E}_{\\pi}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t+1}=s^{'}}\\right]\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]\\end{split}\n\\tag{2.3}\n$$\n\n也就是说在策略$\\pi$下当前状态的值函数可以通过下一个状态的值函数来迭代求解，这个公式被称为$\\upsilon_{\\pi}$的贝尔曼公式（Bellman equation for $\\upsilon_{\\pi}$）。\n\n同样，动作值函数也可以写成相似的形式：\n\n$$\n\\begin{split}q_{\\pi}(s,a)&={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s,A_{t}=a}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}=a}\\right] \\\\\n&=\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]\\end{split}\\tag{2.4}\n$$\n\n$\\upsilon_{\\pi}(s)$也可以用$q_{\\pi}(s,a)$来表示：\n\n$$\\upsilon_{\\pi}(s)=\\sum_{a}\\pi(a\\mid{s})q_{\\pi}(s,a)\\tag{2.5}$$\n\n下面是迭代计算$\\upsilon_{\\pi}(s)$和$q_{\\pi}(s,a)$的图解<sup>[1]</sup>，可以与上述公式对照理解。\n<div align=center><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/205fd62a7177a841cdc79585cf1ed6ae.png?raw=true width=600></div>\n\n### 最优值函数及贝尔曼最优公式\n上面所说的值函数都是未来回报的期望值，而我们需要得到的最优策略必然是使得任意时刻未来回报的期望值都是最大的，也就是说我们的优化目标可以表示为：\n\n$$\\pi_{*}=\\mathop{\\arg\\max}_{\\mathbf{\\pi}}\\upsilon_{\\pi}(s)\\tag{2.6}$$\n\n当然最优策略可能不止一个，但这些最优策略都有一个共同的特点，就是它们共享同样的状态值函数，这个状态值函数叫做最优状态值函数（optimal state-value function），用$\\upsilon_{*}$来表示。对于所有的$s\\in\\bf{S}$，\n\n$$\\upsilon_{*}(s)=\\max_{\\mathbf{\\pi}}\\upsilon_{\\pi}(s)\\tag{2.7}$$\n\n最优策略同样也共享相同的动作值函数（optimal action-value function），用$q_{*}$来表示。对于所有的$s\\in\\bf{S}$，$a\\in{\\bf{A}}(s)$，\n\n$$q_{*}(s,a)=\\max_{\\mathbf{\\pi}}q_{\\pi}(s,a)\\tag{2.8}$$\n\n回顾一下上面动作值函数的改写公式(2.4)，$q_{\\pi}(s,a)=\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]$，由于动作值函数表示的是给定初始动作，后面的动作遵循策略$\\pi$，因此最优动作值函数后面的动作应当遵循最优策略$\\pi_{*}$，不难得到下面的公式。\n$$q_{*}(s,a)=\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{*}(s^{'})\\right]\\tag{2.9}$$\n\n至此，最优值函数的形式已经给出了，现在我们继续回顾一下公式(2.5)的意义，$\\upsilon_{\\pi}(s)$的值是$q_{\\pi}(s,a)$的期望，那么必然存在$\\upsilon_{\\pi}(s)\\leq \\max q_{\\pi}(s,a)$。但对于最优策略来说，\n\n$$\n\\begin{split}\\upsilon_{*}(s)&=\\max_{\\mathbf{a}} q_{*}(s,a) \\\\\n&=\\max_{\\mathbf{a}}\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{*}(s^{'})\\right]\n\\end{split}\\tag{2.10}\n$$\n\n$$\nq_{*}(s,a)=\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\max_{\\mathbf{a^{'}}}q_{*}(s^{'},a^{'})\\right]\\tag{2.11}\n$$\n\n与状态值函数的贝尔曼公式一样，最优状态值函数和最优动作值函数也可以表示成递归的形式，因此公式(2.10)和公式(2.11)又分别叫做状态值函数和动作值函数的贝尔曼最优公式（Bellman optimality equation）。因为没有$\\pi(a\\mid{s})$，不需要根据策略生成动作，因此贝尔曼最优公式完全独立于策略，但如果我们已知$\\upsilon_{*}$或$q_{*}$，都可以很容易地得到最优策略。\n\n如果我们已知$\\upsilon_{*}$，而且在每一步都有多个动作可以选择，可以想到最优策略的$\\upsilon_{*}(s)$必然是满足贝尔曼最优公式的，因此至少有一个动作会满足公式中的最大化条件。任何一个采用上述动作并能够以非零概率转移到下一个状态的策略都是最优策略。我们可以把当前动作的选择看成是一个单步搜索（one-step search）的问题，在某个状态下单步搜索结果最大的动作即最优动作，而每个状态下都采取最优动作的策略即最优策略。如果我们已知$q_{*}$，那么只需要在每一步都选择使得$q_{*}(s,a)$最大的动作，就可以得到一个最优策略。\n\n贝尔曼公式与贝尔曼最优公式是MDP求解的基础，下面主要介绍几种MDP求解的方法。\n\n## 动态规划方法\n动态规划（dynamic programming）指的是能够用来解决给定环境模型，计算最优策略的算法总称。典型的动态规划算法存在两个问题，一是需要依赖一个非常好的环境状态转移模型，二是计算的开销非常大，因此在增强学习中几乎不会直接用动态规划求解MDP，但动态规划理论还是非常重要的，因为后面的一些算法都是在动态规划的基础上，摆脱模型依赖并尽可能地减少计算量。\n\n### 策略估计\n首先，我们考虑一下如果已知策略$\\pi$，如何来计算$\\upsilon_{\\pi}$。这个问题被称作DP迭代中的策略估计（policy evaluation）。\n\n先举一个例子，一个岔路口有向左和向右两个方向，向左回报为10，向右回报为100，我们没有任何先验知识，但我们需要估计站在路口的值函数，也就是估计当前状态的值函数，该如何来估计呢？首先我们将值函数初始化为0，然后进行大量的尝试，每次都以0.5的概率选择方向左，并获得回报10，以0.5的概率选择方向右，获得回报100。那么只要能将这两个方向都至少遍历一遍，就可以得到该状态的值函数$\\upsilon_{随机策略}=\\frac{1}{N}\\sum_{i=0}^{N}{0.5\\cdot R_{i}}$，其中$N$为实验的总次数。\n\n同样，我们也是采用相似的方法迭代来进行策略估计的。首先将所有的$\\upsilon_{\\pi}(s)$都初始化为0（或者任意值，但终止状态必须为0），然后采用如下公式更新所有状态$s$的值函数。\n\n$$\n\\begin{split}\\upsilon_{k+1}(s) &={\\bf{E}}_{\\pi}\\left[R_{t+1}+\\gamma \\upsilon_{k}(S_{t+1})\\mid S_{t}=s \\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{k}(s^{'})\\right]\n\\end{split}\\tag{3.1}\n$$\n\n其中$\\upsilon_{k+1}(s)$表示在当前策略下第$k+1$次迭代状态$s$的值函数，$\\upsilon_{k}(s^{'})$表示在当前策略下第$k$次迭代状态$s^{'}$的值函数，该公式就是用上一次迭代计算得到的值函数来更新本次迭代的值函数。在具体操作时，又有两种更新方法<sup>[6]</sup>，\n\n- 将第$k$次迭代计算得到的所有状态值函数$\\left[\\upsilon_{k}(s_{1}),\\upsilon_{k}(s_{2}),\\upsilon_{k}(s_{3}),...\\right]$保存在一个数组中，第$k+1$次迭代的$\\upsilon_{k+1}(s)$使用第$k$次的$\\upsilon_{k}(s^{'})$进行更新，更新后的值保存在另一个数组中。\n- 仅用一个数组来保存各状态的值函数，每次更新后就将原来的值覆盖。这样在第$k+1$次迭代时$\\upsilon_{k+1}(s)$就有可能使用的是第$k+1$次更新后的$\\upsilon_{k+1}(s^{'})$，这样可以及时地利用更新的值函数，收敛更快。\n\n下面为整个策略估计的算法过程：\n<div align=center><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/19f3246af64a89e7bf38a4d53ea26819.png?raw=true width=560></div>\n\n### 策略改进\n策略估计是为了计算当前策略下各状态的值函数，那得到值函数又有什么用呢？首先我们可以用来比较两个策略的好坏，如果状态值函数是已知的，那么就可以根据公式(2.4)计算动作值函数，如果一个策略$\\pi$的所有动作值函数都大于另一个策略$\\pi^{'}$，那么可以认为策略$\\pi$比策略$\\pi^{'}$更好。其次，最主要的用处是可以用来进行策略改进（policy improvement）。\n\n仍然是上面岔路口的例子，但是假设无论向左还是向右，下一个路口都是唯一且相同的。起初由于没有任何先验知识，因此采用了一个随机策略，然后我们可以计算得到随机策略下的状态值函数，那么我们就可以进行策略改进了。具体的做法就是前面提到的单步搜索，向左时当前动作的回报为10，因此单步搜索的结果为10+$\\gamma\\upsilon$，$\\upsilon$为下一个路口的值函数，而向右为100+$\\gamma\\upsilon$，因此策略会更新为向右，而不再是随机了，显然策略被改进了。同时我们注意到，单步搜索计算的值正是动作值函数。\n\n根据上面的例子，我们可以总结一下策略改进的方法：遍历所有的状态和所有可能的动作，采用贪婪算法进行策略的更新，即对所有$s\\in\\bf S$，\n\n$$\n\\begin{split}\\pi^{'}(s)&=\\arg\\max_{\\mathbf{a}}q_{\\pi}(s,a)\\\\\n&=\\arg\\max_{\\mathbf{a}}\\sum_{s^{'}}p(s^{'}\\mid s,a)\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]\\end{split}\\tag{3.2}\n$$\n\n现在我们已经知道如何计算当前策略的状态值函数，也知道可以根据动作值函数来更新策略，那下面就来讲讲如何从零开始求解最优策略。\n\n### 策略迭代\n一旦策略$\\pi$通过策略改进得到一个更好的策略$\\pi^{'}$，那么我们就可以通过策略估计算法，计算策略$\\pi^{'}$的状态值函数，并用公式(3.2)进行策略改进得到一个比策略$\\pi^{'}$更好的策略$\\pi^{''}$。如下图所示，经过无数次的策略估计和策略改进后，我们终将会收敛于最优策略$\\pi_{*}$。这种通过不断迭代地去改进策略的方法叫做策略迭代（policy iteration）。\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/c9c7ec7b0709d5492f5e8cb8a6096b7e.png?raw=true width=600></div>\n</br>\n下面为整个策略迭代的算法过程：\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/1b44935438fee7046950fcfddfd405c0.png?raw=true width=600></div>\n\n### 值迭代\n策略迭代算法需要不断地进行策略估计和策略改进，每次策略估计和改进都需要遍历一次所有的状态和动作，因此算法的计算量非常大，效率非常低。同时可以看到策略迭代的依据是贝尔曼公式，而如果直接利用贝尔曼最优公式会不会加速求解过程呢？事实上是可以的，下面的值迭代（value iteration）算法就是利用贝尔曼最优公式来提高求解效率的一种算法。\n\n我们还是需要先迭代估计状态值函数，但不必每次迭代都进行策略改进。根据贝尔曼最优公式，可以直接用上一次迭代的最大动作值函数对当前迭代的状态值函数进行更新，如下所示：\n\n$$\n\\begin{split}\\upsilon_{k+1}(s)&=\\max_{\\mathbf{a}} q_{k}(s,a) \\\\\n&=\\max_{\\mathbf{a}}\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{k}(s^{'})\\right]\n\\end{split}\\tag{3.3}\n$$\n\n值迭代算法的好处就是省去了每次迭代时的策略改进过程，并且由于每次迭代得到的$\\upsilon_{k+1}(s)$都要$\\geq$策略迭代得到的$\\upsilon_{k+1}(s)$，也就是说相同迭代次数下，策略迭代得到的策略肯定没有值迭代得到的策略好，因此能大大加快算法收敛。直到值函数收敛到最优值函数后，再通过最优值函数来计算得到最优策略，下面是值迭代算法的完整过程：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/c94f41587e075ba0ab3af4a82ff99a17.png?raw=true width=560></div>\n</br>\n一般来说值迭代和策略迭代都需要经过无数次迭代才能精确收敛到最优策略， 而实践中我们往往会设定一个阈值$\\Delta$来作为迭代中止条件，即当所有的$\\upsilon_{\\pi}(s)$变化量小于$\\Delta$时，我们就近似的认为获得了最优策略。值迭代和策略迭代都可以用来求解最优策略，但是都需要依赖一个现有的环境模型，而对环境进行精确建模往往是非常困难的，所以导致了动态规划方法在MDP求解时几乎不可用，当然如果状态转移是确定性的（$p(s^{'}\\mid s,a)=1$），那就另当别论了。\n\n## 蒙特卡罗方法\n下面我们要讲的是蒙特卡罗方法（Monte Carlo Methods）。与动态规划不同，蒙特卡罗方法不需要知道环境的完整模型，仅仅需要经验就可以获得最优策略，这些经验可以通过与环境在线或模拟交互的方式获得。在线交互显然是不需要任何环境的先验知识，模拟交互虽然需要知道环境状态的转移，但与动态规划不同的是这里不需要知道具体的转移概率。\n\n蒙特卡罗方法也称统计模拟方法，基本思想是通过对大量的重复随机事件进行统计，估计随机事件的概率分布或期望。一个典型的例子是利用蒙特卡罗方法计算圆周率。假设我们知道圆的面积公式为$S=\\pi r^{2}$，那计算圆周率的公式自然就是$\\pi = \\frac{S}{r^{2}}$，因此如果我们知道圆面积和圆半径，那么就可以求到圆周率。那么如何计算一个圆的面积呢？给定一个圆，我们可以画出这个圆的外切正方形，那么这个外切正方形的面积为$S_{正方形}=4r^{2}$，现在我们往正方形区域随机投点，并统计点落在圆内的概率$p$，那么圆面积可以这么计算：$S_{圆}=p\\cdot S_{正方形}$，因此$\\pi=4\\cdot p$。可以想到，如果投点次数越多，$p$估计越精确，$\\pi$的结果也就越接近真实值。\n\n### 蒙特卡罗策略估计\n我们现在来考虑一下如何利用蒙特卡罗方法估计给定策略下的状态值函数。与上面计算圆周率的例子稍有不同的是，现在我们估计的是未来回报的期望，而不是概率，但基本思想是一样的。很显然，如果要估计$\\upsilon_{\\pi}(s)$，我们首先需要根据给定策略生成大量的经验数据，然后从中统计从状态$s$开始的未来回报的平均值，这个平均值就是我们估计的状态值函数。这种利用蒙特卡罗方法进行策略估计的算法又叫做蒙特卡罗策略估计（Monte Carlo Policy Evaluation）。\n\n蒙特卡罗策略估计在具体实现时又分为first-visit MC methods和every-visit MC methods。由于在一个episode中，状态$s$可能会出现多次，first-visit MC methods就是只统计第一次到达该状态的未来回报，而every-visit MC methods是所有达到该状态的未来回报都会统计累加起来。下面我们举例说明first-visit MC methods的估计方法<sup>[6]</sup>。\n\n现在我们假设有如下一些样本（下图每一行都是在当前策略下的一个独立的episode），紫色实心点为状态$s$，取折扣因子γ=1，即直接计算累积回报。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/221402112851854.png?raw=true></div>\n</br>\n第一个episode中到达过两次状态$s$，我们只计算第一次的未来回报$R_{1}(s)=1-2+0+1-3+5=2$。假设我们已经用相同的方法计算得到$R_{2}(s)=1$，$R_{3}(s)=-5$，$R_{4}(s)=4$。那么当前策略下状态$s$的值函数\n\n$$\\upsilon_{\\pi}(s)={\\bf E}\\left[R(s)\\right]=\\frac{1}{N}\\sum_{i=1}^{N}\\left[R_{i}(s)\\right]=\\frac{1}{4}\\left(2+1-5+4\\right)=0.5$$\n\n同样，如果生成的episode数量越多，$\\upsilon_{\\pi}(s)$的估计就越接近真实值，下面是具体的算法流程：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/079fef1ab5cd0065007ae82d893b0520.png?raw=true width=560></div>\n</br>\n注意这里使用大写的$V$表示状态值函数的估计，Sutton的理由是状态值函数一旦初始化，就会立即变成一个随机的值了，因为$G$会随着生成的episode不同而不断变化。可以认为每次$G$都为$\\upsilon_{\\pi}(s)$的一个独立同分布估计，当数据量非常大时$V(s)$将最终收敛于这个分布的均值。\n\n### 动作值函数的蒙特卡罗估计\n由于我们没有完整的环境状态转移模型，因此即使我们得到当前策略的值函数，根据公式(3.2)也无法进行策略改进。既然我们可以估计得到状态值函数，那么肯定也可以用相同的方法直接估计动作值函数，在这里叫做动作值函数的蒙特卡罗估计（Monte Carlo Estimation of Action Values）。\n\n估计方法跟蒙特卡罗策略估计差不多，只不过我们需要找到所有的状态动作对(pair of state $s$ and action $a$)，然后统计每一个状态动作对的未来回报的平均值，即$q_{\\pi}(s,a)$的估计值。得到了$q_{\\pi}(s,a)$，我们就可以根据公式(3.2)进行策略改进了。\n\n### 蒙特卡罗控制\n蒙特卡罗控制（Monte Carlo Control）首要的问题就是如何估计最优策略。跟之前动态规划一样，这里也可以采用策略迭代和策略改进交替进行的方式，经过大量的迭代后收敛到最优策略。但蒙特卡罗方法有一个最大的问题，即我们需要产生无数的episode才能保证收敛到最优结果。无数的episode和大量的迭代导致计算量巨大，效率非常低。Sutton在书<sup>[1]</sup>中提到两种解决方法，其中一种方法是采用episode-by-episode的方式进行优化。\n\nepisode-by-episode的思想与动态规划中值迭代的in-place版本非常相似。在动态规划的值迭代中，我们每次迭代都直接覆盖更新值函数，因此能及时地利用到更新后的值函数，从而能加快收敛。episode-by-episode则是先用当前策略生成一个episode，然后根据这个episode进行动作值函数的更新，同时更新策略，并利用更新后的策略继续生成后续的episode。\n\n下面是exploring starts的蒙特卡罗控制（Monte Carlo ES，exploring starts指的是从一个随机的开始状态和动作生成一个episode）算法的完整过程：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/608a1293a52fa134b5168042bf7fd519.png?raw=true width=560></div>\n</br>\n至于为何要使用exploring starts，这与episode-by-episode在线生成episode的更新策略有关。还是上面的岔路口的例子，我们先随机指定一个策略，比如指定向左，那么使用该策略生成一个episode时必然也是向左，那么也就只能更新向左的动作值函数了，而无法更新向右的动作值函数。由于动作值函数是随机初始化的，如果向右的动作值函数初始值小于更新后的向左的动作值函数，那么下一次生成episode时仍然是向左，并且可以想象可能永远不会选择向右。但其实向右才是最优动作，因此上述更新的策略永远不可能是最优策略。但随机选择开始状态和动作，可以避免某些动作的值函数不会更新的问题，因此可以保证能获得最优策略。\n\n当然也可以采用其他方法避免使用exploring starts，下面要介绍的on-policy方法和off-policy方法就是其中的两种方法。\n\n### On-Policy蒙特卡罗控制\n前面的Monte Carlo ES算法使用exploring starts是为了保证所有可能的动作值函数都能得到更新，从而保证能获得最优策略。如果策略本身就可以在任何状态下都采取所有可能的动作，而不是贪婪地只选择动作值函数最大的那个，那问题不就迎刃而解了吗。下面要讨论策略是非确定性的，也就是对于所有的状态$s$和该状态下所有可能的动作$a$都有$\\pi(a\\mid s)>0$，并且用$\\epsilon-soft$策略生成episode。由于我们评估和改进的策略与生成episode的策略是相同的，因此叫做on-policy方法。\n\n在$\\epsilon-soft$策略中，大多数时候策略会选择动作值函数最大的动作（或者换句话说，以$1-\\epsilon$的概率选择动作值函数最大的动作，$\\epsilon$是一个非常小的正数），但也会以概率$\\epsilon$从其他动作中随机挑选一个动作，整体算法流程：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/a50e2ce4a881eea7b6b1a2a830f2db1d.png?raw=true width=560></div>\n\n### Off-Policy蒙特卡罗控制\n在off-policy方法中，生成episode的策略与评估和改进的策略并非同一个策略。其中生成episode的策略我们叫行为策略（behavior policy），而评估和改进的策略叫估计策略（estimation policy）。这种方法的好处是可以使行为策略是$\\epsilon-soft$策略，但估计策略是确定性的。下面只给出算法流程，具体推导请参考Sutton在书中的介绍<sup>[1]</sup>。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/6f3c3cd1ddbcbfb3fe3df6dc881ce4b8.png?raw=true width=560></div>\n\n## 时间差分学习\n时间差分学习（temporal-dierence (TD) learning）结合了动态规划和蒙特卡罗方法的优点，与蒙特卡罗方法一样不需要环境模型，与动态规划一样更新估计值时只依赖于下一个状态可用的估计值，而不需要等到策略自举出完整的episode。\n\n### TD预测\nTD预测（TD prediction）又叫TD策略估计，就是从给定的一系列经验数据中估计出当前策略的状态值函数$\\upsilon_{\\pi}$。回顾一下蒙特卡罗控制，我们是先自举一个episode，然后根据历史episode和当前最新的episode计算从状态$s$开始未来回报的均值，作为当前状态值函数的更新值。对上面更新方式稍做修改，我们可以用一种滑动平均的方法来更新，即只用当前episode的未来回报与状态值函数的差值来更新。一个简单的every-visit MC方法的更新公式就如下所示：\n\n$$V(S_{t})=（1-\\alpha）V(S_{t})+\\alpha G_{t}=V(S_{t})+\\alpha\\left[G_{t}-V(S_{t}) \\right]\\tag{4-1}$$\n\n$V(S_{t})$表示第$t$个时刻为状态$S_{t}$的状态值函数，$G_{t}$表示从状态$S_{t}$开始到episode结束时的总回报，$\\alpha$是一个常数步长参数（梯度下降算法中叫学习率），这个公式叫做$constant-\\alpha$ MC。在这个公式中，$G_{t}$是需要等到整个episode结束才能得到的，因此只有在自举完整的episode后才能进行更新。下面要说的TD算法就很好地解决了这个问题，只需要等到下一个时刻转移到下一个状态和获得回报值。下面是一种最简单的TD算法，叫做TD(0)。\n\n$$V(S_{t})=V(S_{t})+\\alpha\\left[R_{t+1}+\\gamma V(S_{t+1})-V(S_{t}) \\right]\\tag{4-2}$$\n\n我们这里只是用$R_{t+1}+\\gamma V(S_{t+1})$来估计$constant-\\alpha$ MC中未来回报的真实值。与蒙特卡罗控制一样，TD(0)也能确保收敛到最优状态值函数，当然前提也是需要大量的经验数据。至于TD(0)与蒙特卡罗控制哪个算法收敛更快，这个问题并没有准确的答案，不过Sutton在书中指出，在一些随机任务上TD(0)比$constant-\\alpha$ MC收敛更快。TD(0)算法在每个时刻都要进行一次更新，更高效的方法是在训练时使用batch updating的方式，即一个batch进行一次更新。\n\n显然，TD learning相比MC有以下优点<sup>[7]</sup>：\n\n- 由于TD预测使用差值进行更新，加上步进参数$\\alpha$的存在，TD learning的更新更平稳，方差更小。\n- TD learning可以用于在线训练，因为不需要等到整个episode结束才更新。\n- TD learning应用更广，可以用于非有限步数的情况。\n\n但也存在一些缺点，比如TD learning对初始值比较敏感，以及收敛结果是有偏的。\n\n### TD(λ)\n在介绍TD(λ)之前，我们先介绍一下n-Step TD预测。前面介绍的TD(0)算法在当前状态的基础上往后执行一步就可以进行更新，并且在更新时使用了贝尔曼公式对当前状态的未来回报进行估计，那我们是不是也可以往后执行n步之后再更新，这样用贝尔曼公式估计的未来回报是不是会更加精确呢？实际上，当n等于整个episode的总步数时，n-Step TD预测就完全成了MC估计了。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/8aabe6f419dfeca3f4ee9de376ceb3bd.png?raw=true width=540></div>\n</br>\n\n对于1-step来说，未来回报的值等于第一个回报值加上下一个状态值函数折扣后的值，用公式表示：\n\n$$G_{t}^{(1)}=R_{t+1}+\\gamma V(S_{t+1})$$\n\n2-step比1-step多执行一步，其未来回报值为：\n\n$$G_{t}^{(2)}=R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} V(S_{t+2})$$\n\n那么n-step的未来回报值为：\n\n$$G_{t}^{(n)}=R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} V(S_{t+2})+...+\\gamma^{n}V(S_{t+n})$$\n\n在公式(4-1)中我们用$G_{t}^{(n)}$替代$G_{t}$，最后n-Step TD预测的更新公式为：\n\n$$V(S_{t})=V(S_{t})+\\alpha\\left[G_{t}^{(n)}-V(S_{t}) \\right]\\tag{4-3}$$\n\nn-Step TD预测一定程度上可以使得估计的值函数更准确，因此收敛效果会更好，但更新时需要等待的步数增加了。下图是使用n-Step TD方法在random walk任务上的RMS error对比。\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/3a775aa18ad1b86a07d3b75d52b1c25c.png?raw=true width=600></div>\n</br>\nn-Step TD只使用了从当前状态开始执行n步未来回报的估计值$G_{t}^{(n)}$，其实为了充分利用中间每个step的信息，也可以使用不同的n对应的$G_{t}^{(n)}$的平均值。比如可以把2-step和4-step的均值作为$G_{t}$的估计值，\n\n$$G_{t}^{avg}=\\frac{1}{2}G_{t}^{(2)}+\\frac{1}{2}G_{t}^{(4)}$$\n\nTD(λ)也可以理解为一种特殊的n-step平均算法，每个n-step的权重为$(1-\\lambda)\\lambda^{(n-1)}$，所有权重和仍然为1，因此有：\n\n$$G_{t}^{(\\lambda)}=(1-\\lambda)\\sum_{n=1}^{\\infty}\\lambda^{n-1}G_{t}^{(n)}\\tag{4-4}$$\n\n公式(4-4)表示的是没有终止状态的情况，对于最终存在终止状态的episode任务或截断任务<sup>[注1]</sup>来讲，为了保证所有权重的和为1，最后一个n-step的权重被设置为$\\lambda^{T-t-1}$，其中$T$为episode总步数。\n\n$$G_{t}^{(\\lambda)}=(1-\\lambda)\\sum_{n=1}^{T-t-1}\\lambda^{n-1}G_{t}^{(n)}+\\lambda^{T-t-1}G_{t}\\tag{4-5}$$\n\n当$\\lambda=1$时，这时TD(λ)就相当于MC，而当$\\lambda=0$时，TD(λ)就退化成了TD(0)。\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/294acecc263a9668bd48e3403f9b5225.png?raw=true\" width=540></div>\n</br>\n\n\n### Sarsa\n接下来我们考虑一下如何使用TD预测进行策略改进。首先我们知道可以使用TD预测来估计状态值函数，并且可以使用公式(3-2)进行策略改进。但问题来了，公式(3-2)中的$p(s^{'}\\mid s,a)$是未知参数，无法直接进行策略改进。回顾一下蒙特卡洛控制方法，TD也可以直接对动作值函数$q_{\\pi}$进行估计。与$\\upsilon_{\\pi}$的更新公式一样，下面是$q_{\\pi}$的更新公式，\n\n$$Q(S_t,A_t)=Q(S_t,A_t)+\\alpha[R_{t+1}+\\gamma Q(S_{t+1},A_{t+1})-Q(S_t,A_t)]\\tag{4-3}$$\n\n有了状态值函数，接下来就可以使用公式(3-2)进行策略改进了。在公式(4-3)中，每次非结束状态$S_t$转移到下一个状态时都进行一次值函数的更新，每次更新都只与$(S_t,A_t,R_{t+1},S_{t+1},A_{t+1})$有关，因此叫做Sarsa算法。如果状态$S_{t+1}$为终止状态，则$Q(S_{t+1},A_{t+1})=0$。下面是Sarsa $\\epsilon-greedy$算法的完整过程，由于评估和改进时采用的策略与生成episode的策略是同一个策略，因此Sarsa算法是一种on-policy方法。\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/a8d5cc18d1df07802931d29487b29542.png?raw=true width=600></div>\n</br>\nSarsa的$Q$值更新公式与$TD(0)$一致，实际上也可以采用$TD(λ)$的形式进行$Q$值更新，这个改进算法就是Sarsa(λ)。关于Sarsa(λ)的具体介绍请参考《Reinforcement Learning: An Introduction》一书第七章。\n\n### Q-Learning\n下面介绍的Q学习是一种off-policy方法，并被认为是强化学习算法最重要的突破之一。在Q-learning中，动作值函数的更新完全独立于生成episode的策略，使得学习到的$Q(S_t,A_t)$直接是最优动作值函数$q_{*}$的估计值。\n\n$$Q(S_t,A_t)=Q(S_t,A_t)+\\alpha[R_{t+1}+\\gamma \\mathop \\max_{a} Q(S_{t+1},a)-Q(S_t,A_t)]\\tag{4-4}$$\n\n公式(4-4)为Q-learning的单步更新公式，与Sarsa唯一的不同是：类似于动态规划中的值迭代算法，Q学习也是直接使用最优的$Q(S_{t+1}, A_{t+1})$进行更新，也就相当于策略只采用了最大$Q$值对应的动作。 Q-learning简化了算法分析和收敛性证明的难度，使得它的收敛性很早就得到了证明。但与前面介绍的蒙特卡洛控制一样，由于每次只选择$Q$值最大的动作，因此这个算法也会导致部分state-action对不会被策略生成，相应的动作值函数也无法得到更新。为了确保能收敛到最优策略，下面的算法在生成episode时同样使用了$\\epsilon-greedy$策略，但更新时仍然采用确定性策略（即策略只选择$Q$值最大的动作）。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/3e01e229dc9f53393a25ded669fc0971.png?raw=true width=600></div> \n\n## DQN\n\n## DQN改进算法\n\n## 强化学习在内容推荐中的应用\n\n## 参考资料\n1、Reinforcement Learning: An Introduction, Richard S. Sutton and Andrew G. Barto，2012   \n2、Playing Atari with Deep Reinforcement Learning，DeepMind Technologies，Arxiv 2013.12   \n3、Human-level control through deep reinforcement learning，DeepMind Technologies，Nature 2015.02   \n4、DeepMind官网 https://deepmind.com/blog/deep-reinforcement-learning   \n5、https://www.nervanasys.com/demystifying-deep-reinforcement-learning   \n6、http://www.cnblogs.com/jinxulin/p/3511298.html   \n7、Introduction to Reinforcement Learning，David Silver    \n\n## 注释\n1、截断任务：在强化学习中，非episode任务由于不存在终止状态，为了便于训练可以将非episode任务截断成episode。\n","source":"_posts/强化学习（一）.md","raw":"---\ntitle: 强化学习（一）\ndate: 2017-03-27 12:31:08\ncategory: reinforcement learning\ntags: [reinforcement learning, machine learning]\n---\n\n## 前言\n近几年，由于DeepMind成功地将强化学习（reinforcement learning）运用在AlphaGo上，机器首次在复杂任务上取得了超过人类的表现，使得强化学习成为目前机器学习研究的前沿方向之一。强化学习由来已久，Sutton等在1979年就已经开始研究强化学习，1998年出版了强化学习介绍一书，并于2012年发布第二版，本文前几部分内容主要参考该书。\n\n<!-- more -->\n\n强化学习最早主要用于智能控制领域，比如机器人控制、电梯调度、电信通讯等，如今已经在自动驾驶、NLP、内容推荐<sup>[4]</sup>和语音交互领域都有相关的应用。2013年底DeepMind发表文章Playing Atari with Deep Reinforcement Learning，首次成功地将深度学习运用到强化学习任务上，通过无监督学习实现从纯图像输入来玩Atari 2600游戏的效果。而后DeepMind逐渐改进算法，使得DQN在Atari几乎一半的游戏中超过人类水平，以至2016年AlphaGo和无人车的出现，人们惊奇地发现人工智能即将颠覆我们的生活，甚至有人评论说传统的深度学习已经可以很好地感知理解了，强化学习可以利用这些感知生成策略，因而可以创造更高的机器智能。\n\n下面是DeepMind使用DQN让机器学习玩Atari 2600游戏的视频。\n<iframe width=\"895\" height=\"503\" src=\"https://www.youtube.com/embed/TmPfTpjtdgg\" frameborder=\"0\" allowfullscreen></iframe>\n\n## 什么是强化学习\nReinforcement learning is learning what to do—how to map situations to actions—so as to maximize a numerical reward signal<sup>[1]</sup>.\n\n强化学习研究的是智能体agent与环境之间交互的任务，也就是让agent像人类一样通过试错，不断地学习在不同的环境下做出最优的动作，而不是有监督地直接告诉agent在什么环境下应该做出什么动作。在这里我们需要引入回报（reward）这个概念，回报是执行一个动作或一系列动作后得到的奖励，比如在游戏超级玛丽中，向上跳可以获得一个金币，也就是回报值为1，而不跳时回报就是0。回报又分为立即回报和长期回报，立即回报指的是执行当前动作后能立刻获得的奖励，但很多时候我们执行一个动作后并不能立即得到回报，而是在游戏结束时才能返回一个回报值，这就是长期回报。强化学习唯一的准则就是学习通过一序列的最优动作，获得最大的长期回报。比较有挑战性的是，任一状态下做出的动作不仅影响当前状态的立即回报，而且也会影响到下一个状态，因此也就会影响整个执行过程的回报。\n\n因此，强化学习和监督学习的区别主要有以下两点<sup>[6]</sup>：\n\n1. 强化学习是试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳策略。\n2. 延迟回报，强化学习的指导信息很少，而且往往是在事后（最后一个状态）才给出的，这就导致了一个问题，就是获得正回报或者负回报以后，如何将回报分配给前面的状态。\n\n## 问题描述与MDP\n前面已经提到强化学习是尝试并发现回报最大动作的过程，下面就具体来描述一下这个过程。首先考虑一个问题，一个之前完全没有接触过国际象棋的小白怎样和一个专业棋手对弈。刚开始小白对棋面并没有任何概念，只能随机下，但假设双方每一轮下完后都会得到立即回报，比如吃子回报为1，被吃回报为-1，其他回报为0。可以想象一开始小白会输得很惨，但如果小白很聪明，随着不断地尝试小白不仅理解了下棋的规则，并且知道在什么棋面下做出什么动作可以吃更多的棋子。在这里我们将小白作为我们的智能体agent，棋面就是状态，下棋就是agent根据当前状态做出的动作，每个动作执行完后都会引起状态改变，如果状态的改变只与前一个状态和当前的动作有关，而与之前的状态和动作无关（即满足马尔可夫性），那么整个过程可以用马尔可夫决策过程（Markov Decision Processes）来描述，而Sutton在书中直接将满足马尔可夫性的强化学习任务定义为马尔可夫决策过程，并将状态和动作都是有限空间的MDP定义为有限马尔可夫决策过程（finite MDP）。\n\n下面引入一些定义<sup>[1]</sup>：马尔可夫决策过程是一个agent与环境交互的过程，因此有一个离散的时间序列，$t=0,1,2,3,...$，在每一个时刻$t$，agent都会接收一个用来表示环境的状态$S_{t}\\in\\bf{S}$，其中$\\bf{S}$表示所有可能状态的集合，并且在状态的基础上选择一个动作$A_{t}\\in{\\bf{A}}(S_{t})$，其中${\\bf{A}}(S_{t})$表示在状态$S_{t}$时所有可能采取的动作的集合，在$t$时刻agent采取一个动作后都会收到一个回报值$R_{t+1}\\in\\bf{R}$，然后接收一个新状态$S_{t+1}$。下图为整个过程的示意图。\n\n<div align=center><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/19e9ab8239fe6be8a413990a592b83c2.png?raw=true width=600></div>\n</br>\n在任意时刻和状态下，agent都可以选择一个动作，选择的依据就是我们说的策略—即状态到动作的映射$\\pi(a\\mid{s})$，而一个使得在任意时刻和状态下的长期回报都是最大的策略是我们最终需要得到的。所谓长期回报我们可以用每个时刻的立即回报来表示：\n\n$$G_{t}=R_{t+1}+R_{t+2}+R_{t+3}+...=\\sum_{k=t+1}^{\\infty}R_{k}\\tag{1.1}$$\n\n但实际上我们一般会用下面更通用的公式来代替：\n\n$$G_{t}=R_{t+1}+\\gamma{R_{t+2}}+\\gamma^2{R_{t+3}}+...+\\gamma^{T-t-1}{R_{T}}=\\sum_{k=0}^{T-t-1}\\gamma^{k}R_{t+k+1}\\tag{1.2}$$\n\n其中$\\gamma\\in[0,1]$称为回报折扣因子，表明了未来的回报相对于当前回报的重要程度。$\\gamma=0$时，相当于只考虑立即回报不考虑长期回报，$\\gamma=1$时，将长期回报和立即回报看得同等重要。$T\\in[1,\\infty]$表示完成一次实验过程的总步数，$T=\\infty$和$\\gamma=1$不能同时满足，否则长期回报将无法收敛。特别地，我们将一次有限步数的实验称作一个单独的episodes，也就是经过有限步数后最终会接收一个终止状态，这一类的任务也叫做episodic tasks。下面讨论的强化学习任务都是有限MDP的episodic tasks。\n\n### 马尔可夫决策过程\n一个有限马尔可夫决策过程由一个四元组构成 $M=({\\bf{S}}, {\\bf{A}}, {\\bf{P}}, {\\bf{R}})$<sup>[6]</sup>。如上所述，$\\bf{S}$表示状态集空间，${\\bf{A}}$表示动作集空间，${\\bf{P}}$表示状态转移概率矩阵，${\\bf{R}}$表示期望回报值。\n\n在MDP中给定任何一个状态$s\\in\\bf{S}$和动作$a\\in\\bf{A}$，都会以某个概率转移到下一个状态$s^{'}$，这个概率为$p(s^{'}\\mid s, a)={\\bf{Pr}}\\{S_{t+1}=s^{'}\\mid S_{t}=s, A_{t}=a\\}\\in\\bf{P}$，并获得下一个回报的期望值为$r(s,a,s^{'})={\\bf{E}}\\left[R_{t+1}\\mid{S_{t}=s,A_{t}=a,S_{t+1}=s^{'}}\\right]\\in\\bf{R}$。\n\n### 值函数及贝尔曼公式\n增强学习的最终结果是找到一个环境到动作的映射—即策略$\\pi(a\\mid{s})$。如果一个策略只考虑立即回报，那么很可能就会掉入眼前陷阱。比如说有一个岔路口，往左回报是100，往右回报是10，如果策略只考虑立即回报，那肯定是往左，但往左走的下一次回报只有10，而往右走的下一次回报有200，可以看到这个策略并不是最优的策略，此外增强学习又往往有具有延迟回报的特点，在很多情况下的动作并不会产生立即回报，但这一系列动作的累积效果又的确会导致后续回报的产生，因此立即回报并不能说明策略的好坏。在几乎所有的强化学习理论中都会定义值函数来表示给定策略下期望的未来回报，并将值函数作为评估学习效果的指标。\n\n值函数有多种定义，目前常见的是将值函数直接定义为未来回报的期望：\n\n$$\n\\upsilon_{\\pi}(s)={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right]={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s}\\right]\\tag{2.1}\n$$\n\n上面表示的是在某个策略$\\pi$下，当环境处于状态$s$时未来回报的期望，因此又叫做状态值函数(state-value function for policy)，只跟当前状态有关。同样，我们也可以定义动作值函数(action-value function for policy)，如下：\n\n$$\n\\begin{split}q_{\\pi}(s,a)&={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s,A_{t}=a}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s,A_{t}=a}\\right]\\end{split}\\tag{2.2}\n$$\n\n动作值函数表示在某个策略$\\pi$下，当环境处于状态$s$时采取动作$a$的未来回报的期望。可以看到动作值函数与状态值函数唯一的不同是动作值函数不仅指定了一个初始状态，而且也指定了初始动作，而状态值函数的初始动作是根据策略产生的。由于在MDP中，给定状态$s$，agent根据策略选择动作$a$，下个时刻将以概率$p(s^{'}\\mid{s,a})$转移到状态$s^{'}$，因此值函数又可以改写成如下形式：\n\n$$\n\\begin{split}\\upsilon_{\\pi}(s)&={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s}\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\cdot{\\bf E}_{\\pi}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}}\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma{\\bf E}_{\\pi}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t+1}=s^{'}}\\right]\\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]\\end{split}\n\\tag{2.3}\n$$\n\n也就是说在策略$\\pi$下当前状态的值函数可以通过下一个状态的值函数来迭代求解，这个公式被称为$\\upsilon_{\\pi}$的贝尔曼公式（Bellman equation for $\\upsilon_{\\pi}$）。\n\n同样，动作值函数也可以写成相似的形式：\n\n$$\n\\begin{split}q_{\\pi}(s,a)&={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s,A_{t}=a}\\right] \\\\\n&={\\bf{E_{\\pi}}}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}=a}\\right] \\\\\n&=\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]\\end{split}\\tag{2.4}\n$$\n\n$\\upsilon_{\\pi}(s)$也可以用$q_{\\pi}(s,a)$来表示：\n\n$$\\upsilon_{\\pi}(s)=\\sum_{a}\\pi(a\\mid{s})q_{\\pi}(s,a)\\tag{2.5}$$\n\n下面是迭代计算$\\upsilon_{\\pi}(s)$和$q_{\\pi}(s,a)$的图解<sup>[1]</sup>，可以与上述公式对照理解。\n<div align=center><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/205fd62a7177a841cdc79585cf1ed6ae.png?raw=true width=600></div>\n\n### 最优值函数及贝尔曼最优公式\n上面所说的值函数都是未来回报的期望值，而我们需要得到的最优策略必然是使得任意时刻未来回报的期望值都是最大的，也就是说我们的优化目标可以表示为：\n\n$$\\pi_{*}=\\mathop{\\arg\\max}_{\\mathbf{\\pi}}\\upsilon_{\\pi}(s)\\tag{2.6}$$\n\n当然最优策略可能不止一个，但这些最优策略都有一个共同的特点，就是它们共享同样的状态值函数，这个状态值函数叫做最优状态值函数（optimal state-value function），用$\\upsilon_{*}$来表示。对于所有的$s\\in\\bf{S}$，\n\n$$\\upsilon_{*}(s)=\\max_{\\mathbf{\\pi}}\\upsilon_{\\pi}(s)\\tag{2.7}$$\n\n最优策略同样也共享相同的动作值函数（optimal action-value function），用$q_{*}$来表示。对于所有的$s\\in\\bf{S}$，$a\\in{\\bf{A}}(s)$，\n\n$$q_{*}(s,a)=\\max_{\\mathbf{\\pi}}q_{\\pi}(s,a)\\tag{2.8}$$\n\n回顾一下上面动作值函数的改写公式(2.4)，$q_{\\pi}(s,a)=\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]$，由于动作值函数表示的是给定初始动作，后面的动作遵循策略$\\pi$，因此最优动作值函数后面的动作应当遵循最优策略$\\pi_{*}$，不难得到下面的公式。\n$$q_{*}(s,a)=\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{*}(s^{'})\\right]\\tag{2.9}$$\n\n至此，最优值函数的形式已经给出了，现在我们继续回顾一下公式(2.5)的意义，$\\upsilon_{\\pi}(s)$的值是$q_{\\pi}(s,a)$的期望，那么必然存在$\\upsilon_{\\pi}(s)\\leq \\max q_{\\pi}(s,a)$。但对于最优策略来说，\n\n$$\n\\begin{split}\\upsilon_{*}(s)&=\\max_{\\mathbf{a}} q_{*}(s,a) \\\\\n&=\\max_{\\mathbf{a}}\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{*}(s^{'})\\right]\n\\end{split}\\tag{2.10}\n$$\n\n$$\nq_{*}(s,a)=\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\max_{\\mathbf{a^{'}}}q_{*}(s^{'},a^{'})\\right]\\tag{2.11}\n$$\n\n与状态值函数的贝尔曼公式一样，最优状态值函数和最优动作值函数也可以表示成递归的形式，因此公式(2.10)和公式(2.11)又分别叫做状态值函数和动作值函数的贝尔曼最优公式（Bellman optimality equation）。因为没有$\\pi(a\\mid{s})$，不需要根据策略生成动作，因此贝尔曼最优公式完全独立于策略，但如果我们已知$\\upsilon_{*}$或$q_{*}$，都可以很容易地得到最优策略。\n\n如果我们已知$\\upsilon_{*}$，而且在每一步都有多个动作可以选择，可以想到最优策略的$\\upsilon_{*}(s)$必然是满足贝尔曼最优公式的，因此至少有一个动作会满足公式中的最大化条件。任何一个采用上述动作并能够以非零概率转移到下一个状态的策略都是最优策略。我们可以把当前动作的选择看成是一个单步搜索（one-step search）的问题，在某个状态下单步搜索结果最大的动作即最优动作，而每个状态下都采取最优动作的策略即最优策略。如果我们已知$q_{*}$，那么只需要在每一步都选择使得$q_{*}(s,a)$最大的动作，就可以得到一个最优策略。\n\n贝尔曼公式与贝尔曼最优公式是MDP求解的基础，下面主要介绍几种MDP求解的方法。\n\n## 动态规划方法\n动态规划（dynamic programming）指的是能够用来解决给定环境模型，计算最优策略的算法总称。典型的动态规划算法存在两个问题，一是需要依赖一个非常好的环境状态转移模型，二是计算的开销非常大，因此在增强学习中几乎不会直接用动态规划求解MDP，但动态规划理论还是非常重要的，因为后面的一些算法都是在动态规划的基础上，摆脱模型依赖并尽可能地减少计算量。\n\n### 策略估计\n首先，我们考虑一下如果已知策略$\\pi$，如何来计算$\\upsilon_{\\pi}$。这个问题被称作DP迭代中的策略估计（policy evaluation）。\n\n先举一个例子，一个岔路口有向左和向右两个方向，向左回报为10，向右回报为100，我们没有任何先验知识，但我们需要估计站在路口的值函数，也就是估计当前状态的值函数，该如何来估计呢？首先我们将值函数初始化为0，然后进行大量的尝试，每次都以0.5的概率选择方向左，并获得回报10，以0.5的概率选择方向右，获得回报100。那么只要能将这两个方向都至少遍历一遍，就可以得到该状态的值函数$\\upsilon_{随机策略}=\\frac{1}{N}\\sum_{i=0}^{N}{0.5\\cdot R_{i}}$，其中$N$为实验的总次数。\n\n同样，我们也是采用相似的方法迭代来进行策略估计的。首先将所有的$\\upsilon_{\\pi}(s)$都初始化为0（或者任意值，但终止状态必须为0），然后采用如下公式更新所有状态$s$的值函数。\n\n$$\n\\begin{split}\\upsilon_{k+1}(s) &={\\bf{E}}_{\\pi}\\left[R_{t+1}+\\gamma \\upsilon_{k}(S_{t+1})\\mid S_{t}=s \\right] \\\\\n&=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{k}(s^{'})\\right]\n\\end{split}\\tag{3.1}\n$$\n\n其中$\\upsilon_{k+1}(s)$表示在当前策略下第$k+1$次迭代状态$s$的值函数，$\\upsilon_{k}(s^{'})$表示在当前策略下第$k$次迭代状态$s^{'}$的值函数，该公式就是用上一次迭代计算得到的值函数来更新本次迭代的值函数。在具体操作时，又有两种更新方法<sup>[6]</sup>，\n\n- 将第$k$次迭代计算得到的所有状态值函数$\\left[\\upsilon_{k}(s_{1}),\\upsilon_{k}(s_{2}),\\upsilon_{k}(s_{3}),...\\right]$保存在一个数组中，第$k+1$次迭代的$\\upsilon_{k+1}(s)$使用第$k$次的$\\upsilon_{k}(s^{'})$进行更新，更新后的值保存在另一个数组中。\n- 仅用一个数组来保存各状态的值函数，每次更新后就将原来的值覆盖。这样在第$k+1$次迭代时$\\upsilon_{k+1}(s)$就有可能使用的是第$k+1$次更新后的$\\upsilon_{k+1}(s^{'})$，这样可以及时地利用更新的值函数，收敛更快。\n\n下面为整个策略估计的算法过程：\n<div align=center><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/19f3246af64a89e7bf38a4d53ea26819.png?raw=true width=560></div>\n\n### 策略改进\n策略估计是为了计算当前策略下各状态的值函数，那得到值函数又有什么用呢？首先我们可以用来比较两个策略的好坏，如果状态值函数是已知的，那么就可以根据公式(2.4)计算动作值函数，如果一个策略$\\pi$的所有动作值函数都大于另一个策略$\\pi^{'}$，那么可以认为策略$\\pi$比策略$\\pi^{'}$更好。其次，最主要的用处是可以用来进行策略改进（policy improvement）。\n\n仍然是上面岔路口的例子，但是假设无论向左还是向右，下一个路口都是唯一且相同的。起初由于没有任何先验知识，因此采用了一个随机策略，然后我们可以计算得到随机策略下的状态值函数，那么我们就可以进行策略改进了。具体的做法就是前面提到的单步搜索，向左时当前动作的回报为10，因此单步搜索的结果为10+$\\gamma\\upsilon$，$\\upsilon$为下一个路口的值函数，而向右为100+$\\gamma\\upsilon$，因此策略会更新为向右，而不再是随机了，显然策略被改进了。同时我们注意到，单步搜索计算的值正是动作值函数。\n\n根据上面的例子，我们可以总结一下策略改进的方法：遍历所有的状态和所有可能的动作，采用贪婪算法进行策略的更新，即对所有$s\\in\\bf S$，\n\n$$\n\\begin{split}\\pi^{'}(s)&=\\arg\\max_{\\mathbf{a}}q_{\\pi}(s,a)\\\\\n&=\\arg\\max_{\\mathbf{a}}\\sum_{s^{'}}p(s^{'}\\mid s,a)\\left[r(s,a,s^{'})+\\gamma\\upsilon_{\\pi}(s^{'})\\right]\\end{split}\\tag{3.2}\n$$\n\n现在我们已经知道如何计算当前策略的状态值函数，也知道可以根据动作值函数来更新策略，那下面就来讲讲如何从零开始求解最优策略。\n\n### 策略迭代\n一旦策略$\\pi$通过策略改进得到一个更好的策略$\\pi^{'}$，那么我们就可以通过策略估计算法，计算策略$\\pi^{'}$的状态值函数，并用公式(3.2)进行策略改进得到一个比策略$\\pi^{'}$更好的策略$\\pi^{''}$。如下图所示，经过无数次的策略估计和策略改进后，我们终将会收敛于最优策略$\\pi_{*}$。这种通过不断迭代地去改进策略的方法叫做策略迭代（policy iteration）。\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/c9c7ec7b0709d5492f5e8cb8a6096b7e.png?raw=true width=600></div>\n</br>\n下面为整个策略迭代的算法过程：\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/1b44935438fee7046950fcfddfd405c0.png?raw=true width=600></div>\n\n### 值迭代\n策略迭代算法需要不断地进行策略估计和策略改进，每次策略估计和改进都需要遍历一次所有的状态和动作，因此算法的计算量非常大，效率非常低。同时可以看到策略迭代的依据是贝尔曼公式，而如果直接利用贝尔曼最优公式会不会加速求解过程呢？事实上是可以的，下面的值迭代（value iteration）算法就是利用贝尔曼最优公式来提高求解效率的一种算法。\n\n我们还是需要先迭代估计状态值函数，但不必每次迭代都进行策略改进。根据贝尔曼最优公式，可以直接用上一次迭代的最大动作值函数对当前迭代的状态值函数进行更新，如下所示：\n\n$$\n\\begin{split}\\upsilon_{k+1}(s)&=\\max_{\\mathbf{a}} q_{k}(s,a) \\\\\n&=\\max_{\\mathbf{a}}\\sum_{s^{'}}p(s^{'}\\mid{s,a})\\left[r(s,a,s^{'})+\\gamma\\upsilon_{k}(s^{'})\\right]\n\\end{split}\\tag{3.3}\n$$\n\n值迭代算法的好处就是省去了每次迭代时的策略改进过程，并且由于每次迭代得到的$\\upsilon_{k+1}(s)$都要$\\geq$策略迭代得到的$\\upsilon_{k+1}(s)$，也就是说相同迭代次数下，策略迭代得到的策略肯定没有值迭代得到的策略好，因此能大大加快算法收敛。直到值函数收敛到最优值函数后，再通过最优值函数来计算得到最优策略，下面是值迭代算法的完整过程：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/c94f41587e075ba0ab3af4a82ff99a17.png?raw=true width=560></div>\n</br>\n一般来说值迭代和策略迭代都需要经过无数次迭代才能精确收敛到最优策略， 而实践中我们往往会设定一个阈值$\\Delta$来作为迭代中止条件，即当所有的$\\upsilon_{\\pi}(s)$变化量小于$\\Delta$时，我们就近似的认为获得了最优策略。值迭代和策略迭代都可以用来求解最优策略，但是都需要依赖一个现有的环境模型，而对环境进行精确建模往往是非常困难的，所以导致了动态规划方法在MDP求解时几乎不可用，当然如果状态转移是确定性的（$p(s^{'}\\mid s,a)=1$），那就另当别论了。\n\n## 蒙特卡罗方法\n下面我们要讲的是蒙特卡罗方法（Monte Carlo Methods）。与动态规划不同，蒙特卡罗方法不需要知道环境的完整模型，仅仅需要经验就可以获得最优策略，这些经验可以通过与环境在线或模拟交互的方式获得。在线交互显然是不需要任何环境的先验知识，模拟交互虽然需要知道环境状态的转移，但与动态规划不同的是这里不需要知道具体的转移概率。\n\n蒙特卡罗方法也称统计模拟方法，基本思想是通过对大量的重复随机事件进行统计，估计随机事件的概率分布或期望。一个典型的例子是利用蒙特卡罗方法计算圆周率。假设我们知道圆的面积公式为$S=\\pi r^{2}$，那计算圆周率的公式自然就是$\\pi = \\frac{S}{r^{2}}$，因此如果我们知道圆面积和圆半径，那么就可以求到圆周率。那么如何计算一个圆的面积呢？给定一个圆，我们可以画出这个圆的外切正方形，那么这个外切正方形的面积为$S_{正方形}=4r^{2}$，现在我们往正方形区域随机投点，并统计点落在圆内的概率$p$，那么圆面积可以这么计算：$S_{圆}=p\\cdot S_{正方形}$，因此$\\pi=4\\cdot p$。可以想到，如果投点次数越多，$p$估计越精确，$\\pi$的结果也就越接近真实值。\n\n### 蒙特卡罗策略估计\n我们现在来考虑一下如何利用蒙特卡罗方法估计给定策略下的状态值函数。与上面计算圆周率的例子稍有不同的是，现在我们估计的是未来回报的期望，而不是概率，但基本思想是一样的。很显然，如果要估计$\\upsilon_{\\pi}(s)$，我们首先需要根据给定策略生成大量的经验数据，然后从中统计从状态$s$开始的未来回报的平均值，这个平均值就是我们估计的状态值函数。这种利用蒙特卡罗方法进行策略估计的算法又叫做蒙特卡罗策略估计（Monte Carlo Policy Evaluation）。\n\n蒙特卡罗策略估计在具体实现时又分为first-visit MC methods和every-visit MC methods。由于在一个episode中，状态$s$可能会出现多次，first-visit MC methods就是只统计第一次到达该状态的未来回报，而every-visit MC methods是所有达到该状态的未来回报都会统计累加起来。下面我们举例说明first-visit MC methods的估计方法<sup>[6]</sup>。\n\n现在我们假设有如下一些样本（下图每一行都是在当前策略下的一个独立的episode），紫色实心点为状态$s$，取折扣因子γ=1，即直接计算累积回报。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/221402112851854.png?raw=true></div>\n</br>\n第一个episode中到达过两次状态$s$，我们只计算第一次的未来回报$R_{1}(s)=1-2+0+1-3+5=2$。假设我们已经用相同的方法计算得到$R_{2}(s)=1$，$R_{3}(s)=-5$，$R_{4}(s)=4$。那么当前策略下状态$s$的值函数\n\n$$\\upsilon_{\\pi}(s)={\\bf E}\\left[R(s)\\right]=\\frac{1}{N}\\sum_{i=1}^{N}\\left[R_{i}(s)\\right]=\\frac{1}{4}\\left(2+1-5+4\\right)=0.5$$\n\n同样，如果生成的episode数量越多，$\\upsilon_{\\pi}(s)$的估计就越接近真实值，下面是具体的算法流程：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/079fef1ab5cd0065007ae82d893b0520.png?raw=true width=560></div>\n</br>\n注意这里使用大写的$V$表示状态值函数的估计，Sutton的理由是状态值函数一旦初始化，就会立即变成一个随机的值了，因为$G$会随着生成的episode不同而不断变化。可以认为每次$G$都为$\\upsilon_{\\pi}(s)$的一个独立同分布估计，当数据量非常大时$V(s)$将最终收敛于这个分布的均值。\n\n### 动作值函数的蒙特卡罗估计\n由于我们没有完整的环境状态转移模型，因此即使我们得到当前策略的值函数，根据公式(3.2)也无法进行策略改进。既然我们可以估计得到状态值函数，那么肯定也可以用相同的方法直接估计动作值函数，在这里叫做动作值函数的蒙特卡罗估计（Monte Carlo Estimation of Action Values）。\n\n估计方法跟蒙特卡罗策略估计差不多，只不过我们需要找到所有的状态动作对(pair of state $s$ and action $a$)，然后统计每一个状态动作对的未来回报的平均值，即$q_{\\pi}(s,a)$的估计值。得到了$q_{\\pi}(s,a)$，我们就可以根据公式(3.2)进行策略改进了。\n\n### 蒙特卡罗控制\n蒙特卡罗控制（Monte Carlo Control）首要的问题就是如何估计最优策略。跟之前动态规划一样，这里也可以采用策略迭代和策略改进交替进行的方式，经过大量的迭代后收敛到最优策略。但蒙特卡罗方法有一个最大的问题，即我们需要产生无数的episode才能保证收敛到最优结果。无数的episode和大量的迭代导致计算量巨大，效率非常低。Sutton在书<sup>[1]</sup>中提到两种解决方法，其中一种方法是采用episode-by-episode的方式进行优化。\n\nepisode-by-episode的思想与动态规划中值迭代的in-place版本非常相似。在动态规划的值迭代中，我们每次迭代都直接覆盖更新值函数，因此能及时地利用到更新后的值函数，从而能加快收敛。episode-by-episode则是先用当前策略生成一个episode，然后根据这个episode进行动作值函数的更新，同时更新策略，并利用更新后的策略继续生成后续的episode。\n\n下面是exploring starts的蒙特卡罗控制（Monte Carlo ES，exploring starts指的是从一个随机的开始状态和动作生成一个episode）算法的完整过程：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/608a1293a52fa134b5168042bf7fd519.png?raw=true width=560></div>\n</br>\n至于为何要使用exploring starts，这与episode-by-episode在线生成episode的更新策略有关。还是上面的岔路口的例子，我们先随机指定一个策略，比如指定向左，那么使用该策略生成一个episode时必然也是向左，那么也就只能更新向左的动作值函数了，而无法更新向右的动作值函数。由于动作值函数是随机初始化的，如果向右的动作值函数初始值小于更新后的向左的动作值函数，那么下一次生成episode时仍然是向左，并且可以想象可能永远不会选择向右。但其实向右才是最优动作，因此上述更新的策略永远不可能是最优策略。但随机选择开始状态和动作，可以避免某些动作的值函数不会更新的问题，因此可以保证能获得最优策略。\n\n当然也可以采用其他方法避免使用exploring starts，下面要介绍的on-policy方法和off-policy方法就是其中的两种方法。\n\n### On-Policy蒙特卡罗控制\n前面的Monte Carlo ES算法使用exploring starts是为了保证所有可能的动作值函数都能得到更新，从而保证能获得最优策略。如果策略本身就可以在任何状态下都采取所有可能的动作，而不是贪婪地只选择动作值函数最大的那个，那问题不就迎刃而解了吗。下面要讨论策略是非确定性的，也就是对于所有的状态$s$和该状态下所有可能的动作$a$都有$\\pi(a\\mid s)>0$，并且用$\\epsilon-soft$策略生成episode。由于我们评估和改进的策略与生成episode的策略是相同的，因此叫做on-policy方法。\n\n在$\\epsilon-soft$策略中，大多数时候策略会选择动作值函数最大的动作（或者换句话说，以$1-\\epsilon$的概率选择动作值函数最大的动作，$\\epsilon$是一个非常小的正数），但也会以概率$\\epsilon$从其他动作中随机挑选一个动作，整体算法流程：\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/a50e2ce4a881eea7b6b1a2a830f2db1d.png?raw=true width=560></div>\n\n### Off-Policy蒙特卡罗控制\n在off-policy方法中，生成episode的策略与评估和改进的策略并非同一个策略。其中生成episode的策略我们叫行为策略（behavior policy），而评估和改进的策略叫估计策略（estimation policy）。这种方法的好处是可以使行为策略是$\\epsilon-soft$策略，但估计策略是确定性的。下面只给出算法流程，具体推导请参考Sutton在书中的介绍<sup>[1]</sup>。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/6f3c3cd1ddbcbfb3fe3df6dc881ce4b8.png?raw=true width=560></div>\n\n## 时间差分学习\n时间差分学习（temporal-dierence (TD) learning）结合了动态规划和蒙特卡罗方法的优点，与蒙特卡罗方法一样不需要环境模型，与动态规划一样更新估计值时只依赖于下一个状态可用的估计值，而不需要等到策略自举出完整的episode。\n\n### TD预测\nTD预测（TD prediction）又叫TD策略估计，就是从给定的一系列经验数据中估计出当前策略的状态值函数$\\upsilon_{\\pi}$。回顾一下蒙特卡罗控制，我们是先自举一个episode，然后根据历史episode和当前最新的episode计算从状态$s$开始未来回报的均值，作为当前状态值函数的更新值。对上面更新方式稍做修改，我们可以用一种滑动平均的方法来更新，即只用当前episode的未来回报与状态值函数的差值来更新。一个简单的every-visit MC方法的更新公式就如下所示：\n\n$$V(S_{t})=（1-\\alpha）V(S_{t})+\\alpha G_{t}=V(S_{t})+\\alpha\\left[G_{t}-V(S_{t}) \\right]\\tag{4-1}$$\n\n$V(S_{t})$表示第$t$个时刻为状态$S_{t}$的状态值函数，$G_{t}$表示从状态$S_{t}$开始到episode结束时的总回报，$\\alpha$是一个常数步长参数（梯度下降算法中叫学习率），这个公式叫做$constant-\\alpha$ MC。在这个公式中，$G_{t}$是需要等到整个episode结束才能得到的，因此只有在自举完整的episode后才能进行更新。下面要说的TD算法就很好地解决了这个问题，只需要等到下一个时刻转移到下一个状态和获得回报值。下面是一种最简单的TD算法，叫做TD(0)。\n\n$$V(S_{t})=V(S_{t})+\\alpha\\left[R_{t+1}+\\gamma V(S_{t+1})-V(S_{t}) \\right]\\tag{4-2}$$\n\n我们这里只是用$R_{t+1}+\\gamma V(S_{t+1})$来估计$constant-\\alpha$ MC中未来回报的真实值。与蒙特卡罗控制一样，TD(0)也能确保收敛到最优状态值函数，当然前提也是需要大量的经验数据。至于TD(0)与蒙特卡罗控制哪个算法收敛更快，这个问题并没有准确的答案，不过Sutton在书中指出，在一些随机任务上TD(0)比$constant-\\alpha$ MC收敛更快。TD(0)算法在每个时刻都要进行一次更新，更高效的方法是在训练时使用batch updating的方式，即一个batch进行一次更新。\n\n显然，TD learning相比MC有以下优点<sup>[7]</sup>：\n\n- 由于TD预测使用差值进行更新，加上步进参数$\\alpha$的存在，TD learning的更新更平稳，方差更小。\n- TD learning可以用于在线训练，因为不需要等到整个episode结束才更新。\n- TD learning应用更广，可以用于非有限步数的情况。\n\n但也存在一些缺点，比如TD learning对初始值比较敏感，以及收敛结果是有偏的。\n\n### TD(λ)\n在介绍TD(λ)之前，我们先介绍一下n-Step TD预测。前面介绍的TD(0)算法在当前状态的基础上往后执行一步就可以进行更新，并且在更新时使用了贝尔曼公式对当前状态的未来回报进行估计，那我们是不是也可以往后执行n步之后再更新，这样用贝尔曼公式估计的未来回报是不是会更加精确呢？实际上，当n等于整个episode的总步数时，n-Step TD预测就完全成了MC估计了。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/8aabe6f419dfeca3f4ee9de376ceb3bd.png?raw=true width=540></div>\n</br>\n\n对于1-step来说，未来回报的值等于第一个回报值加上下一个状态值函数折扣后的值，用公式表示：\n\n$$G_{t}^{(1)}=R_{t+1}+\\gamma V(S_{t+1})$$\n\n2-step比1-step多执行一步，其未来回报值为：\n\n$$G_{t}^{(2)}=R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} V(S_{t+2})$$\n\n那么n-step的未来回报值为：\n\n$$G_{t}^{(n)}=R_{t+1}+\\gamma R_{t+2}+\\gamma^{2} V(S_{t+2})+...+\\gamma^{n}V(S_{t+n})$$\n\n在公式(4-1)中我们用$G_{t}^{(n)}$替代$G_{t}$，最后n-Step TD预测的更新公式为：\n\n$$V(S_{t})=V(S_{t})+\\alpha\\left[G_{t}^{(n)}-V(S_{t}) \\right]\\tag{4-3}$$\n\nn-Step TD预测一定程度上可以使得估计的值函数更准确，因此收敛效果会更好，但更新时需要等待的步数增加了。下图是使用n-Step TD方法在random walk任务上的RMS error对比。\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/3a775aa18ad1b86a07d3b75d52b1c25c.png?raw=true width=600></div>\n</br>\nn-Step TD只使用了从当前状态开始执行n步未来回报的估计值$G_{t}^{(n)}$，其实为了充分利用中间每个step的信息，也可以使用不同的n对应的$G_{t}^{(n)}$的平均值。比如可以把2-step和4-step的均值作为$G_{t}$的估计值，\n\n$$G_{t}^{avg}=\\frac{1}{2}G_{t}^{(2)}+\\frac{1}{2}G_{t}^{(4)}$$\n\nTD(λ)也可以理解为一种特殊的n-step平均算法，每个n-step的权重为$(1-\\lambda)\\lambda^{(n-1)}$，所有权重和仍然为1，因此有：\n\n$$G_{t}^{(\\lambda)}=(1-\\lambda)\\sum_{n=1}^{\\infty}\\lambda^{n-1}G_{t}^{(n)}\\tag{4-4}$$\n\n公式(4-4)表示的是没有终止状态的情况，对于最终存在终止状态的episode任务或截断任务<sup>[注1]</sup>来讲，为了保证所有权重的和为1，最后一个n-step的权重被设置为$\\lambda^{T-t-1}$，其中$T$为episode总步数。\n\n$$G_{t}^{(\\lambda)}=(1-\\lambda)\\sum_{n=1}^{T-t-1}\\lambda^{n-1}G_{t}^{(n)}+\\lambda^{T-t-1}G_{t}\\tag{4-5}$$\n\n当$\\lambda=1$时，这时TD(λ)就相当于MC，而当$\\lambda=0$时，TD(λ)就退化成了TD(0)。\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/294acecc263a9668bd48e3403f9b5225.png?raw=true\" width=540></div>\n</br>\n\n\n### Sarsa\n接下来我们考虑一下如何使用TD预测进行策略改进。首先我们知道可以使用TD预测来估计状态值函数，并且可以使用公式(3-2)进行策略改进。但问题来了，公式(3-2)中的$p(s^{'}\\mid s,a)$是未知参数，无法直接进行策略改进。回顾一下蒙特卡洛控制方法，TD也可以直接对动作值函数$q_{\\pi}$进行估计。与$\\upsilon_{\\pi}$的更新公式一样，下面是$q_{\\pi}$的更新公式，\n\n$$Q(S_t,A_t)=Q(S_t,A_t)+\\alpha[R_{t+1}+\\gamma Q(S_{t+1},A_{t+1})-Q(S_t,A_t)]\\tag{4-3}$$\n\n有了状态值函数，接下来就可以使用公式(3-2)进行策略改进了。在公式(4-3)中，每次非结束状态$S_t$转移到下一个状态时都进行一次值函数的更新，每次更新都只与$(S_t,A_t,R_{t+1},S_{t+1},A_{t+1})$有关，因此叫做Sarsa算法。如果状态$S_{t+1}$为终止状态，则$Q(S_{t+1},A_{t+1})=0$。下面是Sarsa $\\epsilon-greedy$算法的完整过程，由于评估和改进时采用的策略与生成episode的策略是同一个策略，因此Sarsa算法是一种on-policy方法。\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/a8d5cc18d1df07802931d29487b29542.png?raw=true width=600></div>\n</br>\nSarsa的$Q$值更新公式与$TD(0)$一致，实际上也可以采用$TD(λ)$的形式进行$Q$值更新，这个改进算法就是Sarsa(λ)。关于Sarsa(λ)的具体介绍请参考《Reinforcement Learning: An Introduction》一书第七章。\n\n### Q-Learning\n下面介绍的Q学习是一种off-policy方法，并被认为是强化学习算法最重要的突破之一。在Q-learning中，动作值函数的更新完全独立于生成episode的策略，使得学习到的$Q(S_t,A_t)$直接是最优动作值函数$q_{*}$的估计值。\n\n$$Q(S_t,A_t)=Q(S_t,A_t)+\\alpha[R_{t+1}+\\gamma \\mathop \\max_{a} Q(S_{t+1},a)-Q(S_t,A_t)]\\tag{4-4}$$\n\n公式(4-4)为Q-learning的单步更新公式，与Sarsa唯一的不同是：类似于动态规划中的值迭代算法，Q学习也是直接使用最优的$Q(S_{t+1}, A_{t+1})$进行更新，也就相当于策略只采用了最大$Q$值对应的动作。 Q-learning简化了算法分析和收敛性证明的难度，使得它的收敛性很早就得到了证明。但与前面介绍的蒙特卡洛控制一样，由于每次只选择$Q$值最大的动作，因此这个算法也会导致部分state-action对不会被策略生成，相应的动作值函数也无法得到更新。为了确保能收敛到最优策略，下面的算法在生成episode时同样使用了$\\epsilon-greedy$策略，但更新时仍然采用确定性策略（即策略只选择$Q$值最大的动作）。\n\n<div align='center'><img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/3e01e229dc9f53393a25ded669fc0971.png?raw=true width=600></div> \n\n## DQN\n\n## DQN改进算法\n\n## 强化学习在内容推荐中的应用\n\n## 参考资料\n1、Reinforcement Learning: An Introduction, Richard S. Sutton and Andrew G. Barto，2012   \n2、Playing Atari with Deep Reinforcement Learning，DeepMind Technologies，Arxiv 2013.12   \n3、Human-level control through deep reinforcement learning，DeepMind Technologies，Nature 2015.02   \n4、DeepMind官网 https://deepmind.com/blog/deep-reinforcement-learning   \n5、https://www.nervanasys.com/demystifying-deep-reinforcement-learning   \n6、http://www.cnblogs.com/jinxulin/p/3511298.html   \n7、Introduction to Reinforcement Learning，David Silver    \n\n## 注释\n1、截断任务：在强化学习中，非episode任务由于不存在终止状态，为了便于训练可以将非episode任务截断成episode。\n","slug":"强化学习（一）","published":1,"updated":"2023-01-03T14:06:23.421Z","_id":"clcgavfts000ihbeqbnbrgs8j","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\">前言</h2>\n<p>近几年，由于DeepMind成功地将强化学习（reinforcement\nlearning）运用在AlphaGo上，机器首次在复杂任务上取得了超过人类的表现，使得强化学习成为目前机器学习研究的前沿方向之一。强化学习由来已久，Sutton等在1979年就已经开始研究强化学习，1998年出版了强化学习介绍一书，并于2012年发布第二版，本文前几部分内容主要参考该书。</p>\n<span id=\"more\"></span>\n<p>强化学习最早主要用于智能控制领域，比如机器人控制、电梯调度、电信通讯等，如今已经在自动驾驶、NLP、内容推荐<sup>[4]</sup>和语音交互领域都有相关的应用。2013年底DeepMind发表文章Playing\nAtari with Deep Reinforcement\nLearning，首次成功地将深度学习运用到强化学习任务上，通过无监督学习实现从纯图像输入来玩Atari\n2600游戏的效果。而后DeepMind逐渐改进算法，使得DQN在Atari几乎一半的游戏中超过人类水平，以至2016年AlphaGo和无人车的出现，人们惊奇地发现人工智能即将颠覆我们的生活，甚至有人评论说传统的深度学习已经可以很好地感知理解了，强化学习可以利用这些感知生成策略，因而可以创造更高的机器智能。</p>\n<p>下面是DeepMind使用DQN让机器学习玩Atari 2600游戏的视频。\n<iframe width=\"895\" height=\"503\" src=\"https://www.youtube.com/embed/TmPfTpjtdgg\" frameborder=\"0\" allowfullscreen></iframe></p>\n<h2 id=\"什么是强化学习\">什么是强化学习</h2>\n<p>Reinforcement learning is learning what to do—how to map situations\nto actions—so as to maximize a numerical reward\nsignal<sup>[1]</sup>.</p>\n<p>强化学习研究的是智能体agent与环境之间交互的任务，也就是让agent像人类一样通过试错，不断地学习在不同的环境下做出最优的动作，而不是有监督地直接告诉agent在什么环境下应该做出什么动作。在这里我们需要引入回报（reward）这个概念，回报是执行一个动作或一系列动作后得到的奖励，比如在游戏超级玛丽中，向上跳可以获得一个金币，也就是回报值为1，而不跳时回报就是0。回报又分为立即回报和长期回报，立即回报指的是执行当前动作后能立刻获得的奖励，但很多时候我们执行一个动作后并不能立即得到回报，而是在游戏结束时才能返回一个回报值，这就是长期回报。强化学习唯一的准则就是学习通过一序列的最优动作，获得最大的长期回报。比较有挑战性的是，任一状态下做出的动作不仅影响当前状态的立即回报，而且也会影响到下一个状态，因此也就会影响整个执行过程的回报。</p>\n<p>因此，强化学习和监督学习的区别主要有以下两点<sup>[6]</sup>：</p>\n<ol type=\"1\">\n<li>强化学习是试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳策略。</li>\n<li>延迟回报，强化学习的指导信息很少，而且往往是在事后（最后一个状态）才给出的，这就导致了一个问题，就是获得正回报或者负回报以后，如何将回报分配给前面的状态。</li>\n</ol>\n<h2 id=\"问题描述与mdp\">问题描述与MDP</h2>\n<p>前面已经提到强化学习是尝试并发现回报最大动作的过程，下面就具体来描述一下这个过程。首先考虑一个问题，一个之前完全没有接触过国际象棋的小白怎样和一个专业棋手对弈。刚开始小白对棋面并没有任何概念，只能随机下，但假设双方每一轮下完后都会得到立即回报，比如吃子回报为1，被吃回报为-1，其他回报为0。可以想象一开始小白会输得很惨，但如果小白很聪明，随着不断地尝试小白不仅理解了下棋的规则，并且知道在什么棋面下做出什么动作可以吃更多的棋子。在这里我们将小白作为我们的智能体agent，棋面就是状态，下棋就是agent根据当前状态做出的动作，每个动作执行完后都会引起状态改变，如果状态的改变只与前一个状态和当前的动作有关，而与之前的状态和动作无关（即满足马尔可夫性），那么整个过程可以用马尔可夫决策过程（Markov\nDecision\nProcesses）来描述，而Sutton在书中直接将满足马尔可夫性的强化学习任务定义为马尔可夫决策过程，并将状态和动作都是有限空间的MDP定义为有限马尔可夫决策过程（finite\nMDP）。</p>\n<p>下面引入一些定义<sup>[1]</sup>：马尔可夫决策过程是一个agent与环境交互的过程，因此有一个离散的时间序列，<span\nclass=\"math inline\">\\(t=0,1,2,3,...\\)</span>，在每一个时刻<span\nclass=\"math inline\">\\(t\\)</span>，agent都会接收一个用来表示环境的状态<span\nclass=\"math inline\">\\(S_{t}\\in\\bf{S}\\)</span>，其中<span\nclass=\"math inline\">\\(\\bf{S}\\)</span>表示所有可能状态的集合，并且在状态的基础上选择一个动作<span\nclass=\"math inline\">\\(A_{t}\\in{\\bf{A}}(S_{t})\\)</span>，其中<span\nclass=\"math inline\">\\({\\bf{A}}(S_{t})\\)</span>表示在状态<span\nclass=\"math inline\">\\(S_{t}\\)</span>时所有可能采取的动作的集合，在<span\nclass=\"math inline\">\\(t\\)</span>时刻agent采取一个动作后都会收到一个回报值<span\nclass=\"math inline\">\\(R_{t+1}\\in\\bf{R}\\)</span>，然后接收一个新状态<span\nclass=\"math inline\">\\(S_{t+1}\\)</span>。下图为整个过程的示意图。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/19e9ab8239fe6be8a413990a592b83c2.png?raw=true width=600>\n</div>\n<p></br>\n在任意时刻和状态下，agent都可以选择一个动作，选择的依据就是我们说的策略—即状态到动作的映射<span\nclass=\"math inline\">\\(\\pi(a\\mid{s})\\)</span>，而一个使得在任意时刻和状态下的长期回报都是最大的策略是我们最终需要得到的。所谓长期回报我们可以用每个时刻的立即回报来表示：</p>\n<p><span\nclass=\"math display\">\\[G_{t}=R_{t+1}+R_{t+2}+R_{t+3}+...=\\sum_{k=t+1}^{\\infty}R_{k}\\tag{1.1}\\]</span></p>\n<p>但实际上我们一般会用下面更通用的公式来代替：</p>\n<p><span\nclass=\"math display\">\\[G_{t}=R_{t+1}+\\gamma{R_{t+2}}+\\gamma^2{R_{t+3}}+...+\\gamma^{T-t-1}{R_{T}}=\\sum_{k=0}^{T-t-1}\\gamma^{k}R_{t+k+1}\\tag{1.2}\\]</span></p>\n<p>其中<span\nclass=\"math inline\">\\(\\gamma\\in[0,1]\\)</span>称为回报折扣因子，表明了未来的回报相对于当前回报的重要程度。<span\nclass=\"math inline\">\\(\\gamma=0\\)</span>时，相当于只考虑立即回报不考虑长期回报，<span\nclass=\"math inline\">\\(\\gamma=1\\)</span>时，将长期回报和立即回报看得同等重要。<span\nclass=\"math inline\">\\(T\\in[1,\\infty]\\)</span>表示完成一次实验过程的总步数，<span\nclass=\"math inline\">\\(T=\\infty\\)</span>和<span\nclass=\"math inline\">\\(\\gamma=1\\)</span>不能同时满足，否则长期回报将无法收敛。特别地，我们将一次有限步数的实验称作一个单独的episodes，也就是经过有限步数后最终会接收一个终止状态，这一类的任务也叫做episodic\ntasks。下面讨论的强化学习任务都是有限MDP的episodic tasks。</p>\n<h3 id=\"马尔可夫决策过程\">马尔可夫决策过程</h3>\n<p>一个有限马尔可夫决策过程由一个四元组构成 <span\nclass=\"math inline\">\\(M=({\\bf{S}}, {\\bf{A}}, {\\bf{P}},\n{\\bf{R}})\\)</span><sup>[6]</sup>。如上所述，<span\nclass=\"math inline\">\\(\\bf{S}\\)</span>表示状态集空间，<span\nclass=\"math inline\">\\({\\bf{A}}\\)</span>表示动作集空间，<span\nclass=\"math inline\">\\({\\bf{P}}\\)</span>表示状态转移概率矩阵，<span\nclass=\"math inline\">\\({\\bf{R}}\\)</span>表示期望回报值。</p>\n<p>在MDP中给定任何一个状态<span\nclass=\"math inline\">\\(s\\in\\bf{S}\\)</span>和动作<span\nclass=\"math inline\">\\(a\\in\\bf{A}\\)</span>，都会以某个概率转移到下一个状态<span\nclass=\"math inline\">\\(s^{&#39;}\\)</span>，这个概率为<span\nclass=\"math inline\">\\(p(s^{&#39;}\\mid s,\na)={\\bf{Pr}}\\{S_{t+1}=s^{&#39;}\\mid S_{t}=s,\nA_{t}=a\\}\\in\\bf{P}\\)</span>，并获得下一个回报的期望值为<span\nclass=\"math inline\">\\(r(s,a,s^{&#39;})={\\bf{E}}\\left[R_{t+1}\\mid{S_{t}=s,A_{t}=a,S_{t+1}=s^{&#39;}}\\right]\\in\\bf{R}\\)</span>。</p>\n<h3 id=\"值函数及贝尔曼公式\">值函数及贝尔曼公式</h3>\n<p>增强学习的最终结果是找到一个环境到动作的映射—即策略<span\nclass=\"math inline\">\\(\\pi(a\\mid{s})\\)</span>。如果一个策略只考虑立即回报，那么很可能就会掉入眼前陷阱。比如说有一个岔路口，往左回报是100，往右回报是10，如果策略只考虑立即回报，那肯定是往左，但往左走的下一次回报只有10，而往右走的下一次回报有200，可以看到这个策略并不是最优的策略，此外增强学习又往往有具有延迟回报的特点，在很多情况下的动作并不会产生立即回报，但这一系列动作的累积效果又的确会导致后续回报的产生，因此立即回报并不能说明策略的好坏。在几乎所有的强化学习理论中都会定义值函数来表示给定策略下期望的未来回报，并将值函数作为评估学习效果的指标。</p>\n<p>值函数有多种定义，目前常见的是将值函数直接定义为未来回报的期望：</p>\n<p><span class=\"math display\">\\[\n\\upsilon_{\\pi}(s)={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right]={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s}\\right]\\tag{2.1}\n\\]</span></p>\n<p>上面表示的是在某个策略<span\nclass=\"math inline\">\\(\\pi\\)</span>下，当环境处于状态<span\nclass=\"math inline\">\\(s\\)</span>时未来回报的期望，因此又叫做状态值函数(state-value\nfunction for\npolicy)，只跟当前状态有关。同样，我们也可以定义动作值函数(action-value\nfunction for policy)，如下：</p>\n<p><span class=\"math display\">\\[\n\\begin{split}q_{\\pi}(s,a)&amp;={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s,A_{t}=a}\\right]\n\\\\\n&amp;={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s,A_{t}=a}\\right]\\end{split}\\tag{2.2}\n\\]</span></p>\n<p>动作值函数表示在某个策略<span\nclass=\"math inline\">\\(\\pi\\)</span>下，当环境处于状态<span\nclass=\"math inline\">\\(s\\)</span>时采取动作<span\nclass=\"math inline\">\\(a\\)</span>的未来回报的期望。可以看到动作值函数与状态值函数唯一的不同是动作值函数不仅指定了一个初始状态，而且也指定了初始动作，而状态值函数的初始动作是根据策略产生的。由于在MDP中，给定状态<span\nclass=\"math inline\">\\(s\\)</span>，agent根据策略选择动作<span\nclass=\"math inline\">\\(a\\)</span>，下个时刻将以概率<span\nclass=\"math inline\">\\(p(s^{&#39;}\\mid{s,a})\\)</span>转移到状态<span\nclass=\"math inline\">\\(s^{&#39;}\\)</span>，因此值函数又可以改写成如下形式：</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\upsilon_{\\pi}(s)&amp;={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right]\n\\\\\n&amp;={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s}\\right]\n\\\\\n&amp;={\\bf{E_{\\pi}}}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s}\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\cdot{\\bf\nE}_{\\pi}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}}\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma{\\bf\nE}_{\\pi}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t+1}=s^{&#39;}}\\right]\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\\end{split}\n\\tag{2.3}\n\\]</span></p>\n<p>也就是说在策略<span\nclass=\"math inline\">\\(\\pi\\)</span>下当前状态的值函数可以通过下一个状态的值函数来迭代求解，这个公式被称为<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>的贝尔曼公式（Bellman\nequation for <span class=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>）。</p>\n<p>同样，动作值函数也可以写成相似的形式：</p>\n<p><span class=\"math display\">\\[\n\\begin{split}q_{\\pi}(s,a)&amp;={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s,A_{t}=a}\\right]\n\\\\\n&amp;={\\bf{E_{\\pi}}}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}=a}\\right]\n\\\\\n&amp;=\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\\end{split}\\tag{2.4}\n\\]</span></p>\n<p><span class=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>也可以用<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>来表示：</p>\n<p><span\nclass=\"math display\">\\[\\upsilon_{\\pi}(s)=\\sum_{a}\\pi(a\\mid{s})q_{\\pi}(s,a)\\tag{2.5}\\]</span></p>\n下面是迭代计算<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>和<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>的图解<sup>[1]</sup>，可以与上述公式对照理解。\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/205fd62a7177a841cdc79585cf1ed6ae.png?raw=true width=600>\n</div>\n<h3 id=\"最优值函数及贝尔曼最优公式\">最优值函数及贝尔曼最优公式</h3>\n<p>上面所说的值函数都是未来回报的期望值，而我们需要得到的最优策略必然是使得任意时刻未来回报的期望值都是最大的，也就是说我们的优化目标可以表示为：</p>\n<p><span\nclass=\"math display\">\\[\\pi_{*}=\\mathop{\\arg\\max}_{\\mathbf{\\pi}}\\upsilon_{\\pi}(s)\\tag{2.6}\\]</span></p>\n<p>当然最优策略可能不止一个，但这些最优策略都有一个共同的特点，就是它们共享同样的状态值函数，这个状态值函数叫做最优状态值函数（optimal\nstate-value function），用<span\nclass=\"math inline\">\\(\\upsilon_{*}\\)</span>来表示。对于所有的<span\nclass=\"math inline\">\\(s\\in\\bf{S}\\)</span>，</p>\n<p><span\nclass=\"math display\">\\[\\upsilon_{*}(s)=\\max_{\\mathbf{\\pi}}\\upsilon_{\\pi}(s)\\tag{2.7}\\]</span></p>\n<p>最优策略同样也共享相同的动作值函数（optimal action-value\nfunction），用<span\nclass=\"math inline\">\\(q_{*}\\)</span>来表示。对于所有的<span\nclass=\"math inline\">\\(s\\in\\bf{S}\\)</span>，<span\nclass=\"math inline\">\\(a\\in{\\bf{A}}(s)\\)</span>，</p>\n<p><span\nclass=\"math display\">\\[q_{*}(s,a)=\\max_{\\mathbf{\\pi}}q_{\\pi}(s,a)\\tag{2.8}\\]</span></p>\n<p>回顾一下上面动作值函数的改写公式(2.4)，<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)=\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\\)</span>，由于动作值函数表示的是给定初始动作，后面的动作遵循策略<span\nclass=\"math inline\">\\(\\pi\\)</span>，因此最优动作值函数后面的动作应当遵循最优策略<span\nclass=\"math inline\">\\(\\pi_{*}\\)</span>，不难得到下面的公式。 <span\nclass=\"math display\">\\[q_{*}(s,a)=\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{*}(s^{&#39;})\\right]\\tag{2.9}\\]</span></p>\n<p>至此，最优值函数的形式已经给出了，现在我们继续回顾一下公式(2.5)的意义，<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>的值是<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>的期望，那么必然存在<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\leq \\max\nq_{\\pi}(s,a)\\)</span>。但对于最优策略来说，</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\upsilon_{*}(s)&amp;=\\max_{\\mathbf{a}} q_{*}(s,a) \\\\\n&amp;=\\max_{\\mathbf{a}}\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{*}(s^{&#39;})\\right]\n\\end{split}\\tag{2.10}\n\\]</span></p>\n<p><span class=\"math display\">\\[\nq_{*}(s,a)=\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\max_{\\mathbf{a^{&#39;}}}q_{*}(s^{&#39;},a^{&#39;})\\right]\\tag{2.11}\n\\]</span></p>\n<p>与状态值函数的贝尔曼公式一样，最优状态值函数和最优动作值函数也可以表示成递归的形式，因此公式(2.10)和公式(2.11)又分别叫做状态值函数和动作值函数的贝尔曼最优公式（Bellman\noptimality equation）。因为没有<span\nclass=\"math inline\">\\(\\pi(a\\mid{s})\\)</span>，不需要根据策略生成动作，因此贝尔曼最优公式完全独立于策略，但如果我们已知<span\nclass=\"math inline\">\\(\\upsilon_{*}\\)</span>或<span\nclass=\"math inline\">\\(q_{*}\\)</span>，都可以很容易地得到最优策略。</p>\n<p>如果我们已知<span\nclass=\"math inline\">\\(\\upsilon_{*}\\)</span>，而且在每一步都有多个动作可以选择，可以想到最优策略的<span\nclass=\"math inline\">\\(\\upsilon_{*}(s)\\)</span>必然是满足贝尔曼最优公式的，因此至少有一个动作会满足公式中的最大化条件。任何一个采用上述动作并能够以非零概率转移到下一个状态的策略都是最优策略。我们可以把当前动作的选择看成是一个单步搜索（one-step\nsearch）的问题，在某个状态下单步搜索结果最大的动作即最优动作，而每个状态下都采取最优动作的策略即最优策略。如果我们已知<span\nclass=\"math inline\">\\(q_{*}\\)</span>，那么只需要在每一步都选择使得<span\nclass=\"math inline\">\\(q_{*}(s,a)\\)</span>最大的动作，就可以得到一个最优策略。</p>\n<p>贝尔曼公式与贝尔曼最优公式是MDP求解的基础，下面主要介绍几种MDP求解的方法。</p>\n<h2 id=\"动态规划方法\">动态规划方法</h2>\n<p>动态规划（dynamic\nprogramming）指的是能够用来解决给定环境模型，计算最优策略的算法总称。典型的动态规划算法存在两个问题，一是需要依赖一个非常好的环境状态转移模型，二是计算的开销非常大，因此在增强学习中几乎不会直接用动态规划求解MDP，但动态规划理论还是非常重要的，因为后面的一些算法都是在动态规划的基础上，摆脱模型依赖并尽可能地减少计算量。</p>\n<h3 id=\"策略估计\">策略估计</h3>\n<p>首先，我们考虑一下如果已知策略<span\nclass=\"math inline\">\\(\\pi\\)</span>，如何来计算<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>。这个问题被称作DP迭代中的策略估计（policy\nevaluation）。</p>\n<p>先举一个例子，一个岔路口有向左和向右两个方向，向左回报为10，向右回报为100，我们没有任何先验知识，但我们需要估计站在路口的值函数，也就是估计当前状态的值函数，该如何来估计呢？首先我们将值函数初始化为0，然后进行大量的尝试，每次都以0.5的概率选择方向左，并获得回报10，以0.5的概率选择方向右，获得回报100。那么只要能将这两个方向都至少遍历一遍，就可以得到该状态的值函数<span\nclass=\"math inline\">\\(\\upsilon_{随机策略}=\\frac{1}{N}\\sum_{i=0}^{N}{0.5\\cdot\nR_{i}}\\)</span>，其中<span\nclass=\"math inline\">\\(N\\)</span>为实验的总次数。</p>\n<p>同样，我们也是采用相似的方法迭代来进行策略估计的。首先将所有的<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>都初始化为0（或者任意值，但终止状态必须为0），然后采用如下公式更新所有状态<span\nclass=\"math inline\">\\(s\\)</span>的值函数。</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\upsilon_{k+1}(s) &amp;={\\bf{E}}_{\\pi}\\left[R_{t+1}+\\gamma\n\\upsilon_{k}(S_{t+1})\\mid S_{t}=s \\right] \\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{k}(s^{&#39;})\\right]\n\\end{split}\\tag{3.1}\n\\]</span></p>\n<p>其中<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>表示在当前策略下第<span\nclass=\"math inline\">\\(k+1\\)</span>次迭代状态<span\nclass=\"math inline\">\\(s\\)</span>的值函数，<span\nclass=\"math inline\">\\(\\upsilon_{k}(s^{&#39;})\\)</span>表示在当前策略下第<span\nclass=\"math inline\">\\(k\\)</span>次迭代状态<span\nclass=\"math inline\">\\(s^{&#39;}\\)</span>的值函数，该公式就是用上一次迭代计算得到的值函数来更新本次迭代的值函数。在具体操作时，又有两种更新方法<sup>[6]</sup>，</p>\n<ul>\n<li>将第<span\nclass=\"math inline\">\\(k\\)</span>次迭代计算得到的所有状态值函数<span\nclass=\"math inline\">\\(\\left[\\upsilon_{k}(s_{1}),\\upsilon_{k}(s_{2}),\\upsilon_{k}(s_{3}),...\\right]\\)</span>保存在一个数组中，第<span\nclass=\"math inline\">\\(k+1\\)</span>次迭代的<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>使用第<span\nclass=\"math inline\">\\(k\\)</span>次的<span\nclass=\"math inline\">\\(\\upsilon_{k}(s^{&#39;})\\)</span>进行更新，更新后的值保存在另一个数组中。</li>\n<li>仅用一个数组来保存各状态的值函数，每次更新后就将原来的值覆盖。这样在第<span\nclass=\"math inline\">\\(k+1\\)</span>次迭代时<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>就有可能使用的是第<span\nclass=\"math inline\">\\(k+1\\)</span>次更新后的<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s^{&#39;})\\)</span>，这样可以及时地利用更新的值函数，收敛更快。</li>\n</ul>\n下面为整个策略估计的算法过程：\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/19f3246af64a89e7bf38a4d53ea26819.png?raw=true width=560>\n</div>\n<h3 id=\"策略改进\">策略改进</h3>\n<p>策略估计是为了计算当前策略下各状态的值函数，那得到值函数又有什么用呢？首先我们可以用来比较两个策略的好坏，如果状态值函数是已知的，那么就可以根据公式(2.4)计算动作值函数，如果一个策略<span\nclass=\"math inline\">\\(\\pi\\)</span>的所有动作值函数都大于另一个策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>，那么可以认为策略<span\nclass=\"math inline\">\\(\\pi\\)</span>比策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>更好。其次，最主要的用处是可以用来进行策略改进（policy\nimprovement）。</p>\n<p>仍然是上面岔路口的例子，但是假设无论向左还是向右，下一个路口都是唯一且相同的。起初由于没有任何先验知识，因此采用了一个随机策略，然后我们可以计算得到随机策略下的状态值函数，那么我们就可以进行策略改进了。具体的做法就是前面提到的单步搜索，向左时当前动作的回报为10，因此单步搜索的结果为10+<span\nclass=\"math inline\">\\(\\gamma\\upsilon\\)</span>，<span\nclass=\"math inline\">\\(\\upsilon\\)</span>为下一个路口的值函数，而向右为100+<span\nclass=\"math inline\">\\(\\gamma\\upsilon\\)</span>，因此策略会更新为向右，而不再是随机了，显然策略被改进了。同时我们注意到，单步搜索计算的值正是动作值函数。</p>\n<p>根据上面的例子，我们可以总结一下策略改进的方法：遍历所有的状态和所有可能的动作，采用贪婪算法进行策略的更新，即对所有<span\nclass=\"math inline\">\\(s\\in\\bf S\\)</span>，</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\pi^{&#39;}(s)&amp;=\\arg\\max_{\\mathbf{a}}q_{\\pi}(s,a)\\\\\n&amp;=\\arg\\max_{\\mathbf{a}}\\sum_{s^{&#39;}}p(s^{&#39;}\\mid\ns,a)\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\\end{split}\\tag{3.2}\n\\]</span></p>\n<p>现在我们已经知道如何计算当前策略的状态值函数，也知道可以根据动作值函数来更新策略，那下面就来讲讲如何从零开始求解最优策略。</p>\n<h3 id=\"策略迭代\">策略迭代</h3>\n一旦策略<span\nclass=\"math inline\">\\(\\pi\\)</span>通过策略改进得到一个更好的策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>，那么我们就可以通过策略估计算法，计算策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>的状态值函数，并用公式(3.2)进行策略改进得到一个比策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>更好的策略<span\nclass=\"math inline\">\\(\\pi^{&#39;&#39;}\\)</span>。如下图所示，经过无数次的策略估计和策略改进后，我们终将会收敛于最优策略<span\nclass=\"math inline\">\\(\\pi_{*}\\)</span>。这种通过不断迭代地去改进策略的方法叫做策略迭代（policy\niteration）。\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/c9c7ec7b0709d5492f5e8cb8a6096b7e.png?raw=true width=600>\n</div>\n</br> 下面为整个策略迭代的算法过程：\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/1b44935438fee7046950fcfddfd405c0.png?raw=true width=600>\n</div>\n<h3 id=\"值迭代\">值迭代</h3>\n<p>策略迭代算法需要不断地进行策略估计和策略改进，每次策略估计和改进都需要遍历一次所有的状态和动作，因此算法的计算量非常大，效率非常低。同时可以看到策略迭代的依据是贝尔曼公式，而如果直接利用贝尔曼最优公式会不会加速求解过程呢？事实上是可以的，下面的值迭代（value\niteration）算法就是利用贝尔曼最优公式来提高求解效率的一种算法。</p>\n<p>我们还是需要先迭代估计状态值函数，但不必每次迭代都进行策略改进。根据贝尔曼最优公式，可以直接用上一次迭代的最大动作值函数对当前迭代的状态值函数进行更新，如下所示：</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\upsilon_{k+1}(s)&amp;=\\max_{\\mathbf{a}} q_{k}(s,a) \\\\\n&amp;=\\max_{\\mathbf{a}}\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{k}(s^{&#39;})\\right]\n\\end{split}\\tag{3.3}\n\\]</span></p>\n<p>值迭代算法的好处就是省去了每次迭代时的策略改进过程，并且由于每次迭代得到的<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>都要<span\nclass=\"math inline\">\\(\\geq\\)</span>策略迭代得到的<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>，也就是说相同迭代次数下，策略迭代得到的策略肯定没有值迭代得到的策略好，因此能大大加快算法收敛。直到值函数收敛到最优值函数后，再通过最优值函数来计算得到最优策略，下面是值迭代算法的完整过程：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/c94f41587e075ba0ab3af4a82ff99a17.png?raw=true width=560>\n</div>\n<p></br>\n一般来说值迭代和策略迭代都需要经过无数次迭代才能精确收敛到最优策略，\n而实践中我们往往会设定一个阈值<span\nclass=\"math inline\">\\(\\Delta\\)</span>来作为迭代中止条件，即当所有的<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>变化量小于<span\nclass=\"math inline\">\\(\\Delta\\)</span>时，我们就近似的认为获得了最优策略。值迭代和策略迭代都可以用来求解最优策略，但是都需要依赖一个现有的环境模型，而对环境进行精确建模往往是非常困难的，所以导致了动态规划方法在MDP求解时几乎不可用，当然如果状态转移是确定性的（<span\nclass=\"math inline\">\\(p(s^{&#39;}\\mid\ns,a)=1\\)</span>），那就另当别论了。</p>\n<h2 id=\"蒙特卡罗方法\">蒙特卡罗方法</h2>\n<p>下面我们要讲的是蒙特卡罗方法（Monte Carlo\nMethods）。与动态规划不同，蒙特卡罗方法不需要知道环境的完整模型，仅仅需要经验就可以获得最优策略，这些经验可以通过与环境在线或模拟交互的方式获得。在线交互显然是不需要任何环境的先验知识，模拟交互虽然需要知道环境状态的转移，但与动态规划不同的是这里不需要知道具体的转移概率。</p>\n<p>蒙特卡罗方法也称统计模拟方法，基本思想是通过对大量的重复随机事件进行统计，估计随机事件的概率分布或期望。一个典型的例子是利用蒙特卡罗方法计算圆周率。假设我们知道圆的面积公式为<span\nclass=\"math inline\">\\(S=\\pi\nr^{2}\\)</span>，那计算圆周率的公式自然就是<span\nclass=\"math inline\">\\(\\pi =\n\\frac{S}{r^{2}}\\)</span>，因此如果我们知道圆面积和圆半径，那么就可以求到圆周率。那么如何计算一个圆的面积呢？给定一个圆，我们可以画出这个圆的外切正方形，那么这个外切正方形的面积为<span\nclass=\"math inline\">\\(S_{正方形}=4r^{2}\\)</span>，现在我们往正方形区域随机投点，并统计点落在圆内的概率<span\nclass=\"math inline\">\\(p\\)</span>，那么圆面积可以这么计算：<span\nclass=\"math inline\">\\(S_{圆}=p\\cdot S_{正方形}\\)</span>，因此<span\nclass=\"math inline\">\\(\\pi=4\\cdot\np\\)</span>。可以想到，如果投点次数越多，<span\nclass=\"math inline\">\\(p\\)</span>估计越精确，<span\nclass=\"math inline\">\\(\\pi\\)</span>的结果也就越接近真实值。</p>\n<h3 id=\"蒙特卡罗策略估计\">蒙特卡罗策略估计</h3>\n<p>我们现在来考虑一下如何利用蒙特卡罗方法估计给定策略下的状态值函数。与上面计算圆周率的例子稍有不同的是，现在我们估计的是未来回报的期望，而不是概率，但基本思想是一样的。很显然，如果要估计<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>，我们首先需要根据给定策略生成大量的经验数据，然后从中统计从状态<span\nclass=\"math inline\">\\(s\\)</span>开始的未来回报的平均值，这个平均值就是我们估计的状态值函数。这种利用蒙特卡罗方法进行策略估计的算法又叫做蒙特卡罗策略估计（Monte\nCarlo Policy Evaluation）。</p>\n<p>蒙特卡罗策略估计在具体实现时又分为first-visit MC methods和every-visit\nMC methods。由于在一个episode中，状态<span\nclass=\"math inline\">\\(s\\)</span>可能会出现多次，first-visit MC\nmethods就是只统计第一次到达该状态的未来回报，而every-visit MC\nmethods是所有达到该状态的未来回报都会统计累加起来。下面我们举例说明first-visit\nMC methods的估计方法<sup>[6]</sup>。</p>\n<p>现在我们假设有如下一些样本（下图每一行都是在当前策略下的一个独立的episode），紫色实心点为状态<span\nclass=\"math inline\">\\(s\\)</span>，取折扣因子γ=1，即直接计算累积回报。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/221402112851854.png?raw=true>\n</div>\n<p></br> 第一个episode中到达过两次状态<span\nclass=\"math inline\">\\(s\\)</span>，我们只计算第一次的未来回报<span\nclass=\"math inline\">\\(R_{1}(s)=1-2+0+1-3+5=2\\)</span>。假设我们已经用相同的方法计算得到<span\nclass=\"math inline\">\\(R_{2}(s)=1\\)</span>，<span\nclass=\"math inline\">\\(R_{3}(s)=-5\\)</span>，<span\nclass=\"math inline\">\\(R_{4}(s)=4\\)</span>。那么当前策略下状态<span\nclass=\"math inline\">\\(s\\)</span>的值函数</p>\n<p><span class=\"math display\">\\[\\upsilon_{\\pi}(s)={\\bf\nE}\\left[R(s)\\right]=\\frac{1}{N}\\sum_{i=1}^{N}\\left[R_{i}(s)\\right]=\\frac{1}{4}\\left(2+1-5+4\\right)=0.5\\]</span></p>\n<p>同样，如果生成的episode数量越多，<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>的估计就越接近真实值，下面是具体的算法流程：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/079fef1ab5cd0065007ae82d893b0520.png?raw=true width=560>\n</div>\n<p></br> 注意这里使用大写的<span\nclass=\"math inline\">\\(V\\)</span>表示状态值函数的估计，Sutton的理由是状态值函数一旦初始化，就会立即变成一个随机的值了，因为<span\nclass=\"math inline\">\\(G\\)</span>会随着生成的episode不同而不断变化。可以认为每次<span\nclass=\"math inline\">\\(G\\)</span>都为<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>的一个独立同分布估计，当数据量非常大时<span\nclass=\"math inline\">\\(V(s)\\)</span>将最终收敛于这个分布的均值。</p>\n<h3 id=\"动作值函数的蒙特卡罗估计\">动作值函数的蒙特卡罗估计</h3>\n<p>由于我们没有完整的环境状态转移模型，因此即使我们得到当前策略的值函数，根据公式(3.2)也无法进行策略改进。既然我们可以估计得到状态值函数，那么肯定也可以用相同的方法直接估计动作值函数，在这里叫做动作值函数的蒙特卡罗估计（Monte\nCarlo Estimation of Action Values）。</p>\n<p>估计方法跟蒙特卡罗策略估计差不多，只不过我们需要找到所有的状态动作对(pair\nof state <span class=\"math inline\">\\(s\\)</span> and action <span\nclass=\"math inline\">\\(a\\)</span>)，然后统计每一个状态动作对的未来回报的平均值，即<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>的估计值。得到了<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>，我们就可以根据公式(3.2)进行策略改进了。</p>\n<h3 id=\"蒙特卡罗控制\">蒙特卡罗控制</h3>\n<p>蒙特卡罗控制（Monte Carlo\nControl）首要的问题就是如何估计最优策略。跟之前动态规划一样，这里也可以采用策略迭代和策略改进交替进行的方式，经过大量的迭代后收敛到最优策略。但蒙特卡罗方法有一个最大的问题，即我们需要产生无数的episode才能保证收敛到最优结果。无数的episode和大量的迭代导致计算量巨大，效率非常低。Sutton在书<sup>[1]</sup>中提到两种解决方法，其中一种方法是采用episode-by-episode的方式进行优化。</p>\n<p>episode-by-episode的思想与动态规划中值迭代的in-place版本非常相似。在动态规划的值迭代中，我们每次迭代都直接覆盖更新值函数，因此能及时地利用到更新后的值函数，从而能加快收敛。episode-by-episode则是先用当前策略生成一个episode，然后根据这个episode进行动作值函数的更新，同时更新策略，并利用更新后的策略继续生成后续的episode。</p>\n<p>下面是exploring starts的蒙特卡罗控制（Monte Carlo ES，exploring\nstarts指的是从一个随机的开始状态和动作生成一个episode）算法的完整过程：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/608a1293a52fa134b5168042bf7fd519.png?raw=true width=560>\n</div>\n<p></br> 至于为何要使用exploring\nstarts，这与episode-by-episode在线生成episode的更新策略有关。还是上面的岔路口的例子，我们先随机指定一个策略，比如指定向左，那么使用该策略生成一个episode时必然也是向左，那么也就只能更新向左的动作值函数了，而无法更新向右的动作值函数。由于动作值函数是随机初始化的，如果向右的动作值函数初始值小于更新后的向左的动作值函数，那么下一次生成episode时仍然是向左，并且可以想象可能永远不会选择向右。但其实向右才是最优动作，因此上述更新的策略永远不可能是最优策略。但随机选择开始状态和动作，可以避免某些动作的值函数不会更新的问题，因此可以保证能获得最优策略。</p>\n<p>当然也可以采用其他方法避免使用exploring\nstarts，下面要介绍的on-policy方法和off-policy方法就是其中的两种方法。</p>\n<h3 id=\"on-policy蒙特卡罗控制\">On-Policy蒙特卡罗控制</h3>\n<p>前面的Monte Carlo ES算法使用exploring\nstarts是为了保证所有可能的动作值函数都能得到更新，从而保证能获得最优策略。如果策略本身就可以在任何状态下都采取所有可能的动作，而不是贪婪地只选择动作值函数最大的那个，那问题不就迎刃而解了吗。下面要讨论策略是非确定性的，也就是对于所有的状态<span\nclass=\"math inline\">\\(s\\)</span>和该状态下所有可能的动作<span\nclass=\"math inline\">\\(a\\)</span>都有<span\nclass=\"math inline\">\\(\\pi(a\\mid s)&gt;0\\)</span>，并且用<span\nclass=\"math inline\">\\(\\epsilon-soft\\)</span>策略生成episode。由于我们评估和改进的策略与生成episode的策略是相同的，因此叫做on-policy方法。</p>\n<p>在<span\nclass=\"math inline\">\\(\\epsilon-soft\\)</span>策略中，大多数时候策略会选择动作值函数最大的动作（或者换句话说，以<span\nclass=\"math inline\">\\(1-\\epsilon\\)</span>的概率选择动作值函数最大的动作，<span\nclass=\"math inline\">\\(\\epsilon\\)</span>是一个非常小的正数），但也会以概率<span\nclass=\"math inline\">\\(\\epsilon\\)</span>从其他动作中随机挑选一个动作，整体算法流程：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/a50e2ce4a881eea7b6b1a2a830f2db1d.png?raw=true width=560>\n</div>\n<h3 id=\"off-policy蒙特卡罗控制\">Off-Policy蒙特卡罗控制</h3>\n<p>在off-policy方法中，生成episode的策略与评估和改进的策略并非同一个策略。其中生成episode的策略我们叫行为策略（behavior\npolicy），而评估和改进的策略叫估计策略（estimation\npolicy）。这种方法的好处是可以使行为策略是<span\nclass=\"math inline\">\\(\\epsilon-soft\\)</span>策略，但估计策略是确定性的。下面只给出算法流程，具体推导请参考Sutton在书中的介绍<sup>[1]</sup>。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/6f3c3cd1ddbcbfb3fe3df6dc881ce4b8.png?raw=true width=560>\n</div>\n<h2 id=\"时间差分学习\">时间差分学习</h2>\n<p>时间差分学习（temporal-dierence (TD)\nlearning）结合了动态规划和蒙特卡罗方法的优点，与蒙特卡罗方法一样不需要环境模型，与动态规划一样更新估计值时只依赖于下一个状态可用的估计值，而不需要等到策略自举出完整的episode。</p>\n<h3 id=\"td预测\">TD预测</h3>\n<p>TD预测（TD\nprediction）又叫TD策略估计，就是从给定的一系列经验数据中估计出当前策略的状态值函数<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>。回顾一下蒙特卡罗控制，我们是先自举一个episode，然后根据历史episode和当前最新的episode计算从状态<span\nclass=\"math inline\">\\(s\\)</span>开始未来回报的均值，作为当前状态值函数的更新值。对上面更新方式稍做修改，我们可以用一种滑动平均的方法来更新，即只用当前episode的未来回报与状态值函数的差值来更新。一个简单的every-visit\nMC方法的更新公式就如下所示：</p>\n<p><span class=\"math display\">\\[V(S_{t})=（1-\\alpha）V(S_{t})+\\alpha\nG_{t}=V(S_{t})+\\alpha\\left[G_{t}-V(S_{t}) \\right]\\tag{4-1}\\]</span></p>\n<p><span class=\"math inline\">\\(V(S_{t})\\)</span>表示第<span\nclass=\"math inline\">\\(t\\)</span>个时刻为状态<span\nclass=\"math inline\">\\(S_{t}\\)</span>的状态值函数，<span\nclass=\"math inline\">\\(G_{t}\\)</span>表示从状态<span\nclass=\"math inline\">\\(S_{t}\\)</span>开始到episode结束时的总回报，<span\nclass=\"math inline\">\\(\\alpha\\)</span>是一个常数步长参数（梯度下降算法中叫学习率），这个公式叫做<span\nclass=\"math inline\">\\(constant-\\alpha\\)</span> MC。在这个公式中，<span\nclass=\"math inline\">\\(G_{t}\\)</span>是需要等到整个episode结束才能得到的，因此只有在自举完整的episode后才能进行更新。下面要说的TD算法就很好地解决了这个问题，只需要等到下一个时刻转移到下一个状态和获得回报值。下面是一种最简单的TD算法，叫做TD(0)。</p>\n<p><span\nclass=\"math display\">\\[V(S_{t})=V(S_{t})+\\alpha\\left[R_{t+1}+\\gamma\nV(S_{t+1})-V(S_{t}) \\right]\\tag{4-2}\\]</span></p>\n<p>我们这里只是用<span class=\"math inline\">\\(R_{t+1}+\\gamma\nV(S_{t+1})\\)</span>来估计<span\nclass=\"math inline\">\\(constant-\\alpha\\)</span>\nMC中未来回报的真实值。与蒙特卡罗控制一样，TD(0)也能确保收敛到最优状态值函数，当然前提也是需要大量的经验数据。至于TD(0)与蒙特卡罗控制哪个算法收敛更快，这个问题并没有准确的答案，不过Sutton在书中指出，在一些随机任务上TD(0)比<span\nclass=\"math inline\">\\(constant-\\alpha\\)</span>\nMC收敛更快。TD(0)算法在每个时刻都要进行一次更新，更高效的方法是在训练时使用batch\nupdating的方式，即一个batch进行一次更新。</p>\n<p>显然，TD learning相比MC有以下优点<sup>[7]</sup>：</p>\n<ul>\n<li>由于TD预测使用差值进行更新，加上步进参数<span\nclass=\"math inline\">\\(\\alpha\\)</span>的存在，TD\nlearning的更新更平稳，方差更小。</li>\n<li>TD\nlearning可以用于在线训练，因为不需要等到整个episode结束才更新。</li>\n<li>TD learning应用更广，可以用于非有限步数的情况。</li>\n</ul>\n<p>但也存在一些缺点，比如TD\nlearning对初始值比较敏感，以及收敛结果是有偏的。</p>\n<h3 id=\"tdλ\">TD(λ)</h3>\n<p>在介绍TD(λ)之前，我们先介绍一下n-Step\nTD预测。前面介绍的TD(0)算法在当前状态的基础上往后执行一步就可以进行更新，并且在更新时使用了贝尔曼公式对当前状态的未来回报进行估计，那我们是不是也可以往后执行n步之后再更新，这样用贝尔曼公式估计的未来回报是不是会更加精确呢？实际上，当n等于整个episode的总步数时，n-Step\nTD预测就完全成了MC估计了。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/8aabe6f419dfeca3f4ee9de376ceb3bd.png?raw=true width=540>\n</div>\n<p></br></p>\n<p>对于1-step来说，未来回报的值等于第一个回报值加上下一个状态值函数折扣后的值，用公式表示：</p>\n<p><span class=\"math display\">\\[G_{t}^{(1)}=R_{t+1}+\\gamma\nV(S_{t+1})\\]</span></p>\n<p>2-step比1-step多执行一步，其未来回报值为：</p>\n<p><span class=\"math display\">\\[G_{t}^{(2)}=R_{t+1}+\\gamma\nR_{t+2}+\\gamma^{2} V(S_{t+2})\\]</span></p>\n<p>那么n-step的未来回报值为：</p>\n<p><span class=\"math display\">\\[G_{t}^{(n)}=R_{t+1}+\\gamma\nR_{t+2}+\\gamma^{2} V(S_{t+2})+...+\\gamma^{n}V(S_{t+n})\\]</span></p>\n<p>在公式(4-1)中我们用<span\nclass=\"math inline\">\\(G_{t}^{(n)}\\)</span>替代<span\nclass=\"math inline\">\\(G_{t}\\)</span>，最后n-Step\nTD预测的更新公式为：</p>\n<p><span\nclass=\"math display\">\\[V(S_{t})=V(S_{t})+\\alpha\\left[G_{t}^{(n)}-V(S_{t})\n\\right]\\tag{4-3}\\]</span></p>\nn-Step\nTD预测一定程度上可以使得估计的值函数更准确，因此收敛效果会更好，但更新时需要等待的步数增加了。下图是使用n-Step\nTD方法在random walk任务上的RMS error对比。\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/3a775aa18ad1b86a07d3b75d52b1c25c.png?raw=true width=600>\n</div>\n<p></br> n-Step TD只使用了从当前状态开始执行n步未来回报的估计值<span\nclass=\"math inline\">\\(G_{t}^{(n)}\\)</span>，其实为了充分利用中间每个step的信息，也可以使用不同的n对应的<span\nclass=\"math inline\">\\(G_{t}^{(n)}\\)</span>的平均值。比如可以把2-step和4-step的均值作为<span\nclass=\"math inline\">\\(G_{t}\\)</span>的估计值，</p>\n<p><span\nclass=\"math display\">\\[G_{t}^{avg}=\\frac{1}{2}G_{t}^{(2)}+\\frac{1}{2}G_{t}^{(4)}\\]</span></p>\n<p>TD(λ)也可以理解为一种特殊的n-step平均算法，每个n-step的权重为<span\nclass=\"math inline\">\\((1-\\lambda)\\lambda^{(n-1)}\\)</span>，所有权重和仍然为1，因此有：</p>\n<p><span\nclass=\"math display\">\\[G_{t}^{(\\lambda)}=(1-\\lambda)\\sum_{n=1}^{\\infty}\\lambda^{n-1}G_{t}^{(n)}\\tag{4-4}\\]</span></p>\n<p>公式(4-4)表示的是没有终止状态的情况，对于最终存在终止状态的episode任务或截断任务<sup>[注1]</sup>来讲，为了保证所有权重的和为1，最后一个n-step的权重被设置为<span\nclass=\"math inline\">\\(\\lambda^{T-t-1}\\)</span>，其中<span\nclass=\"math inline\">\\(T\\)</span>为episode总步数。</p>\n<p><span\nclass=\"math display\">\\[G_{t}^{(\\lambda)}=(1-\\lambda)\\sum_{n=1}^{T-t-1}\\lambda^{n-1}G_{t}^{(n)}+\\lambda^{T-t-1}G_{t}\\tag{4-5}\\]</span></p>\n<p>当<span\nclass=\"math inline\">\\(\\lambda=1\\)</span>时，这时TD(λ)就相当于MC，而当<span\nclass=\"math inline\">\\(\\lambda=0\\)</span>时，TD(λ)就退化成了TD(0)。</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/294acecc263a9668bd48e3403f9b5225.png?raw=true\" width=540>\n</div>\n<p></br></p>\n<h3 id=\"sarsa\">Sarsa</h3>\n<p>接下来我们考虑一下如何使用TD预测进行策略改进。首先我们知道可以使用TD预测来估计状态值函数，并且可以使用公式(3-2)进行策略改进。但问题来了，公式(3-2)中的<span\nclass=\"math inline\">\\(p(s^{&#39;}\\mid\ns,a)\\)</span>是未知参数，无法直接进行策略改进。回顾一下蒙特卡洛控制方法，TD也可以直接对动作值函数<span\nclass=\"math inline\">\\(q_{\\pi}\\)</span>进行估计。与<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>的更新公式一样，下面是<span\nclass=\"math inline\">\\(q_{\\pi}\\)</span>的更新公式，</p>\n<p><span\nclass=\"math display\">\\[Q(S_t,A_t)=Q(S_t,A_t)+\\alpha[R_{t+1}+\\gamma\nQ(S_{t+1},A_{t+1})-Q(S_t,A_t)]\\tag{4-3}\\]</span></p>\n有了状态值函数，接下来就可以使用公式(3-2)进行策略改进了。在公式(4-3)中，每次非结束状态<span\nclass=\"math inline\">\\(S_t\\)</span>转移到下一个状态时都进行一次值函数的更新，每次更新都只与<span\nclass=\"math inline\">\\((S_t,A_t,R_{t+1},S_{t+1},A_{t+1})\\)</span>有关，因此叫做Sarsa算法。如果状态<span\nclass=\"math inline\">\\(S_{t+1}\\)</span>为终止状态，则<span\nclass=\"math inline\">\\(Q(S_{t+1},A_{t+1})=0\\)</span>。下面是Sarsa <span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>算法的完整过程，由于评估和改进时采用的策略与生成episode的策略是同一个策略，因此Sarsa算法是一种on-policy方法。\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/a8d5cc18d1df07802931d29487b29542.png?raw=true width=600>\n</div>\n<p></br> Sarsa的<span class=\"math inline\">\\(Q\\)</span>值更新公式与<span\nclass=\"math inline\">\\(TD(0)\\)</span>一致，实际上也可以采用<span\nclass=\"math inline\">\\(TD(λ)\\)</span>的形式进行<span\nclass=\"math inline\">\\(Q\\)</span>值更新，这个改进算法就是Sarsa(λ)。关于Sarsa(λ)的具体介绍请参考《Reinforcement\nLearning: An Introduction》一书第七章。</p>\n<h3 id=\"q-learning\">Q-Learning</h3>\n<p>下面介绍的Q学习是一种off-policy方法，并被认为是强化学习算法最重要的突破之一。在Q-learning中，动作值函数的更新完全独立于生成episode的策略，使得学习到的<span\nclass=\"math inline\">\\(Q(S_t,A_t)\\)</span>直接是最优动作值函数<span\nclass=\"math inline\">\\(q_{*}\\)</span>的估计值。</p>\n<p><span\nclass=\"math display\">\\[Q(S_t,A_t)=Q(S_t,A_t)+\\alpha[R_{t+1}+\\gamma\n\\mathop \\max_{a} Q(S_{t+1},a)-Q(S_t,A_t)]\\tag{4-4}\\]</span></p>\n<p>公式(4-4)为Q-learning的单步更新公式，与Sarsa唯一的不同是：类似于动态规划中的值迭代算法，Q学习也是直接使用最优的<span\nclass=\"math inline\">\\(Q(S_{t+1},\nA_{t+1})\\)</span>进行更新，也就相当于策略只采用了最大<span\nclass=\"math inline\">\\(Q\\)</span>值对应的动作。\nQ-learning简化了算法分析和收敛性证明的难度，使得它的收敛性很早就得到了证明。但与前面介绍的蒙特卡洛控制一样，由于每次只选择<span\nclass=\"math inline\">\\(Q\\)</span>值最大的动作，因此这个算法也会导致部分state-action对不会被策略生成，相应的动作值函数也无法得到更新。为了确保能收敛到最优策略，下面的算法在生成episode时同样使用了<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略，但更新时仍然采用确定性策略（即策略只选择<span\nclass=\"math inline\">\\(Q\\)</span>值最大的动作）。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/3e01e229dc9f53393a25ded669fc0971.png?raw=true width=600>\n</div>\n<h2 id=\"dqn\">DQN</h2>\n<h2 id=\"dqn改进算法\">DQN改进算法</h2>\n<h2 id=\"强化学习在内容推荐中的应用\">强化学习在内容推荐中的应用</h2>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>1、Reinforcement Learning: An Introduction, Richard S. Sutton and\nAndrew G. Barto，2012<br />\n2、Playing Atari with Deep Reinforcement Learning，DeepMind\nTechnologies，Arxiv 2013.12<br />\n3、Human-level control through deep reinforcement learning，DeepMind\nTechnologies，Nature 2015.02<br />\n4、DeepMind官网\nhttps://deepmind.com/blog/deep-reinforcement-learning<br />\n5、https://www.nervanasys.com/demystifying-deep-reinforcement-learning<br />\n6、http://www.cnblogs.com/jinxulin/p/3511298.html<br />\n7、Introduction to Reinforcement Learning，David Silver</p>\n<h2 id=\"注释\">注释</h2>\n<p>1、截断任务：在强化学习中，非episode任务由于不存在终止状态，为了便于训练可以将非episode任务截断成episode。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\">前言</h2>\n<p>近几年，由于DeepMind成功地将强化学习（reinforcement\nlearning）运用在AlphaGo上，机器首次在复杂任务上取得了超过人类的表现，使得强化学习成为目前机器学习研究的前沿方向之一。强化学习由来已久，Sutton等在1979年就已经开始研究强化学习，1998年出版了强化学习介绍一书，并于2012年发布第二版，本文前几部分内容主要参考该书。</p>","more":"<p>强化学习最早主要用于智能控制领域，比如机器人控制、电梯调度、电信通讯等，如今已经在自动驾驶、NLP、内容推荐<sup>[4]</sup>和语音交互领域都有相关的应用。2013年底DeepMind发表文章Playing\nAtari with Deep Reinforcement\nLearning，首次成功地将深度学习运用到强化学习任务上，通过无监督学习实现从纯图像输入来玩Atari\n2600游戏的效果。而后DeepMind逐渐改进算法，使得DQN在Atari几乎一半的游戏中超过人类水平，以至2016年AlphaGo和无人车的出现，人们惊奇地发现人工智能即将颠覆我们的生活，甚至有人评论说传统的深度学习已经可以很好地感知理解了，强化学习可以利用这些感知生成策略，因而可以创造更高的机器智能。</p>\n<p>下面是DeepMind使用DQN让机器学习玩Atari 2600游戏的视频。\n<iframe width=\"895\" height=\"503\" src=\"https://www.youtube.com/embed/TmPfTpjtdgg\" frameborder=\"0\" allowfullscreen></iframe></p>\n<h2 id=\"什么是强化学习\">什么是强化学习</h2>\n<p>Reinforcement learning is learning what to do—how to map situations\nto actions—so as to maximize a numerical reward\nsignal<sup>[1]</sup>.</p>\n<p>强化学习研究的是智能体agent与环境之间交互的任务，也就是让agent像人类一样通过试错，不断地学习在不同的环境下做出最优的动作，而不是有监督地直接告诉agent在什么环境下应该做出什么动作。在这里我们需要引入回报（reward）这个概念，回报是执行一个动作或一系列动作后得到的奖励，比如在游戏超级玛丽中，向上跳可以获得一个金币，也就是回报值为1，而不跳时回报就是0。回报又分为立即回报和长期回报，立即回报指的是执行当前动作后能立刻获得的奖励，但很多时候我们执行一个动作后并不能立即得到回报，而是在游戏结束时才能返回一个回报值，这就是长期回报。强化学习唯一的准则就是学习通过一序列的最优动作，获得最大的长期回报。比较有挑战性的是，任一状态下做出的动作不仅影响当前状态的立即回报，而且也会影响到下一个状态，因此也就会影响整个执行过程的回报。</p>\n<p>因此，强化学习和监督学习的区别主要有以下两点<sup>[6]</sup>：</p>\n<ol type=\"1\">\n<li>强化学习是试错学习(Trail-and-error)，由于没有直接的指导信息，智能体要以不断与环境进行交互，通过试错的方式来获得最佳策略。</li>\n<li>延迟回报，强化学习的指导信息很少，而且往往是在事后（最后一个状态）才给出的，这就导致了一个问题，就是获得正回报或者负回报以后，如何将回报分配给前面的状态。</li>\n</ol>\n<h2 id=\"问题描述与mdp\">问题描述与MDP</h2>\n<p>前面已经提到强化学习是尝试并发现回报最大动作的过程，下面就具体来描述一下这个过程。首先考虑一个问题，一个之前完全没有接触过国际象棋的小白怎样和一个专业棋手对弈。刚开始小白对棋面并没有任何概念，只能随机下，但假设双方每一轮下完后都会得到立即回报，比如吃子回报为1，被吃回报为-1，其他回报为0。可以想象一开始小白会输得很惨，但如果小白很聪明，随着不断地尝试小白不仅理解了下棋的规则，并且知道在什么棋面下做出什么动作可以吃更多的棋子。在这里我们将小白作为我们的智能体agent，棋面就是状态，下棋就是agent根据当前状态做出的动作，每个动作执行完后都会引起状态改变，如果状态的改变只与前一个状态和当前的动作有关，而与之前的状态和动作无关（即满足马尔可夫性），那么整个过程可以用马尔可夫决策过程（Markov\nDecision\nProcesses）来描述，而Sutton在书中直接将满足马尔可夫性的强化学习任务定义为马尔可夫决策过程，并将状态和动作都是有限空间的MDP定义为有限马尔可夫决策过程（finite\nMDP）。</p>\n<p>下面引入一些定义<sup>[1]</sup>：马尔可夫决策过程是一个agent与环境交互的过程，因此有一个离散的时间序列，<span\nclass=\"math inline\">\\(t=0,1,2,3,...\\)</span>，在每一个时刻<span\nclass=\"math inline\">\\(t\\)</span>，agent都会接收一个用来表示环境的状态<span\nclass=\"math inline\">\\(S_{t}\\in\\bf{S}\\)</span>，其中<span\nclass=\"math inline\">\\(\\bf{S}\\)</span>表示所有可能状态的集合，并且在状态的基础上选择一个动作<span\nclass=\"math inline\">\\(A_{t}\\in{\\bf{A}}(S_{t})\\)</span>，其中<span\nclass=\"math inline\">\\({\\bf{A}}(S_{t})\\)</span>表示在状态<span\nclass=\"math inline\">\\(S_{t}\\)</span>时所有可能采取的动作的集合，在<span\nclass=\"math inline\">\\(t\\)</span>时刻agent采取一个动作后都会收到一个回报值<span\nclass=\"math inline\">\\(R_{t+1}\\in\\bf{R}\\)</span>，然后接收一个新状态<span\nclass=\"math inline\">\\(S_{t+1}\\)</span>。下图为整个过程的示意图。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/19e9ab8239fe6be8a413990a592b83c2.png?raw=true width=600>\n</div>\n<p></br>\n在任意时刻和状态下，agent都可以选择一个动作，选择的依据就是我们说的策略—即状态到动作的映射<span\nclass=\"math inline\">\\(\\pi(a\\mid{s})\\)</span>，而一个使得在任意时刻和状态下的长期回报都是最大的策略是我们最终需要得到的。所谓长期回报我们可以用每个时刻的立即回报来表示：</p>\n<p><span\nclass=\"math display\">\\[G_{t}=R_{t+1}+R_{t+2}+R_{t+3}+...=\\sum_{k=t+1}^{\\infty}R_{k}\\tag{1.1}\\]</span></p>\n<p>但实际上我们一般会用下面更通用的公式来代替：</p>\n<p><span\nclass=\"math display\">\\[G_{t}=R_{t+1}+\\gamma{R_{t+2}}+\\gamma^2{R_{t+3}}+...+\\gamma^{T-t-1}{R_{T}}=\\sum_{k=0}^{T-t-1}\\gamma^{k}R_{t+k+1}\\tag{1.2}\\]</span></p>\n<p>其中<span\nclass=\"math inline\">\\(\\gamma\\in[0,1]\\)</span>称为回报折扣因子，表明了未来的回报相对于当前回报的重要程度。<span\nclass=\"math inline\">\\(\\gamma=0\\)</span>时，相当于只考虑立即回报不考虑长期回报，<span\nclass=\"math inline\">\\(\\gamma=1\\)</span>时，将长期回报和立即回报看得同等重要。<span\nclass=\"math inline\">\\(T\\in[1,\\infty]\\)</span>表示完成一次实验过程的总步数，<span\nclass=\"math inline\">\\(T=\\infty\\)</span>和<span\nclass=\"math inline\">\\(\\gamma=1\\)</span>不能同时满足，否则长期回报将无法收敛。特别地，我们将一次有限步数的实验称作一个单独的episodes，也就是经过有限步数后最终会接收一个终止状态，这一类的任务也叫做episodic\ntasks。下面讨论的强化学习任务都是有限MDP的episodic tasks。</p>\n<h3 id=\"马尔可夫决策过程\">马尔可夫决策过程</h3>\n<p>一个有限马尔可夫决策过程由一个四元组构成 <span\nclass=\"math inline\">\\(M=({\\bf{S}}, {\\bf{A}}, {\\bf{P}},\n{\\bf{R}})\\)</span><sup>[6]</sup>。如上所述，<span\nclass=\"math inline\">\\(\\bf{S}\\)</span>表示状态集空间，<span\nclass=\"math inline\">\\({\\bf{A}}\\)</span>表示动作集空间，<span\nclass=\"math inline\">\\({\\bf{P}}\\)</span>表示状态转移概率矩阵，<span\nclass=\"math inline\">\\({\\bf{R}}\\)</span>表示期望回报值。</p>\n<p>在MDP中给定任何一个状态<span\nclass=\"math inline\">\\(s\\in\\bf{S}\\)</span>和动作<span\nclass=\"math inline\">\\(a\\in\\bf{A}\\)</span>，都会以某个概率转移到下一个状态<span\nclass=\"math inline\">\\(s^{&#39;}\\)</span>，这个概率为<span\nclass=\"math inline\">\\(p(s^{&#39;}\\mid s,\na)={\\bf{Pr}}\\{S_{t+1}=s^{&#39;}\\mid S_{t}=s,\nA_{t}=a\\}\\in\\bf{P}\\)</span>，并获得下一个回报的期望值为<span\nclass=\"math inline\">\\(r(s,a,s^{&#39;})={\\bf{E}}\\left[R_{t+1}\\mid{S_{t}=s,A_{t}=a,S_{t+1}=s^{&#39;}}\\right]\\in\\bf{R}\\)</span>。</p>\n<h3 id=\"值函数及贝尔曼公式\">值函数及贝尔曼公式</h3>\n<p>增强学习的最终结果是找到一个环境到动作的映射—即策略<span\nclass=\"math inline\">\\(\\pi(a\\mid{s})\\)</span>。如果一个策略只考虑立即回报，那么很可能就会掉入眼前陷阱。比如说有一个岔路口，往左回报是100，往右回报是10，如果策略只考虑立即回报，那肯定是往左，但往左走的下一次回报只有10，而往右走的下一次回报有200，可以看到这个策略并不是最优的策略，此外增强学习又往往有具有延迟回报的特点，在很多情况下的动作并不会产生立即回报，但这一系列动作的累积效果又的确会导致后续回报的产生，因此立即回报并不能说明策略的好坏。在几乎所有的强化学习理论中都会定义值函数来表示给定策略下期望的未来回报，并将值函数作为评估学习效果的指标。</p>\n<p>值函数有多种定义，目前常见的是将值函数直接定义为未来回报的期望：</p>\n<p><span class=\"math display\">\\[\n\\upsilon_{\\pi}(s)={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right]={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s}\\right]\\tag{2.1}\n\\]</span></p>\n<p>上面表示的是在某个策略<span\nclass=\"math inline\">\\(\\pi\\)</span>下，当环境处于状态<span\nclass=\"math inline\">\\(s\\)</span>时未来回报的期望，因此又叫做状态值函数(state-value\nfunction for\npolicy)，只跟当前状态有关。同样，我们也可以定义动作值函数(action-value\nfunction for policy)，如下：</p>\n<p><span class=\"math display\">\\[\n\\begin{split}q_{\\pi}(s,a)&amp;={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s,A_{t}=a}\\right]\n\\\\\n&amp;={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s,A_{t}=a}\\right]\\end{split}\\tag{2.2}\n\\]</span></p>\n<p>动作值函数表示在某个策略<span\nclass=\"math inline\">\\(\\pi\\)</span>下，当环境处于状态<span\nclass=\"math inline\">\\(s\\)</span>时采取动作<span\nclass=\"math inline\">\\(a\\)</span>的未来回报的期望。可以看到动作值函数与状态值函数唯一的不同是动作值函数不仅指定了一个初始状态，而且也指定了初始动作，而状态值函数的初始动作是根据策略产生的。由于在MDP中，给定状态<span\nclass=\"math inline\">\\(s\\)</span>，agent根据策略选择动作<span\nclass=\"math inline\">\\(a\\)</span>，下个时刻将以概率<span\nclass=\"math inline\">\\(p(s^{&#39;}\\mid{s,a})\\)</span>转移到状态<span\nclass=\"math inline\">\\(s^{&#39;}\\)</span>，因此值函数又可以改写成如下形式：</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\upsilon_{\\pi}(s)&amp;={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s}\\right]\n\\\\\n&amp;={\\bf{E_{\\pi}}}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid{S_{t}=s}\\right]\n\\\\\n&amp;={\\bf{E_{\\pi}}}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s}\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\cdot{\\bf\nE}_{\\pi}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}}\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma{\\bf\nE}_{\\pi}\\left[\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t+1}=s^{&#39;}}\\right]\\right]\n\\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\\end{split}\n\\tag{2.3}\n\\]</span></p>\n<p>也就是说在策略<span\nclass=\"math inline\">\\(\\pi\\)</span>下当前状态的值函数可以通过下一个状态的值函数来迭代求解，这个公式被称为<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>的贝尔曼公式（Bellman\nequation for <span class=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>）。</p>\n<p>同样，动作值函数也可以写成相似的形式：</p>\n<p><span class=\"math display\">\\[\n\\begin{split}q_{\\pi}(s,a)&amp;={\\bf{E_{\\pi}}}\\left[G_{t}\\mid{S_{t}=s,A_{t}=a}\\right]\n\\\\\n&amp;={\\bf{E_{\\pi}}}\\left[R_{t+1}+\\gamma\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+2}\\mid{S_{t}=s,A_{t}=a}\\right]\n\\\\\n&amp;=\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\\end{split}\\tag{2.4}\n\\]</span></p>\n<p><span class=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>也可以用<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>来表示：</p>\n<p><span\nclass=\"math display\">\\[\\upsilon_{\\pi}(s)=\\sum_{a}\\pi(a\\mid{s})q_{\\pi}(s,a)\\tag{2.5}\\]</span></p>\n下面是迭代计算<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>和<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>的图解<sup>[1]</sup>，可以与上述公式对照理解。\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/205fd62a7177a841cdc79585cf1ed6ae.png?raw=true width=600>\n</div>\n<h3 id=\"最优值函数及贝尔曼最优公式\">最优值函数及贝尔曼最优公式</h3>\n<p>上面所说的值函数都是未来回报的期望值，而我们需要得到的最优策略必然是使得任意时刻未来回报的期望值都是最大的，也就是说我们的优化目标可以表示为：</p>\n<p><span\nclass=\"math display\">\\[\\pi_{*}=\\mathop{\\arg\\max}_{\\mathbf{\\pi}}\\upsilon_{\\pi}(s)\\tag{2.6}\\]</span></p>\n<p>当然最优策略可能不止一个，但这些最优策略都有一个共同的特点，就是它们共享同样的状态值函数，这个状态值函数叫做最优状态值函数（optimal\nstate-value function），用<span\nclass=\"math inline\">\\(\\upsilon_{*}\\)</span>来表示。对于所有的<span\nclass=\"math inline\">\\(s\\in\\bf{S}\\)</span>，</p>\n<p><span\nclass=\"math display\">\\[\\upsilon_{*}(s)=\\max_{\\mathbf{\\pi}}\\upsilon_{\\pi}(s)\\tag{2.7}\\]</span></p>\n<p>最优策略同样也共享相同的动作值函数（optimal action-value\nfunction），用<span\nclass=\"math inline\">\\(q_{*}\\)</span>来表示。对于所有的<span\nclass=\"math inline\">\\(s\\in\\bf{S}\\)</span>，<span\nclass=\"math inline\">\\(a\\in{\\bf{A}}(s)\\)</span>，</p>\n<p><span\nclass=\"math display\">\\[q_{*}(s,a)=\\max_{\\mathbf{\\pi}}q_{\\pi}(s,a)\\tag{2.8}\\]</span></p>\n<p>回顾一下上面动作值函数的改写公式(2.4)，<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)=\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\\)</span>，由于动作值函数表示的是给定初始动作，后面的动作遵循策略<span\nclass=\"math inline\">\\(\\pi\\)</span>，因此最优动作值函数后面的动作应当遵循最优策略<span\nclass=\"math inline\">\\(\\pi_{*}\\)</span>，不难得到下面的公式。 <span\nclass=\"math display\">\\[q_{*}(s,a)=\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{*}(s^{&#39;})\\right]\\tag{2.9}\\]</span></p>\n<p>至此，最优值函数的形式已经给出了，现在我们继续回顾一下公式(2.5)的意义，<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>的值是<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>的期望，那么必然存在<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\leq \\max\nq_{\\pi}(s,a)\\)</span>。但对于最优策略来说，</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\upsilon_{*}(s)&amp;=\\max_{\\mathbf{a}} q_{*}(s,a) \\\\\n&amp;=\\max_{\\mathbf{a}}\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{*}(s^{&#39;})\\right]\n\\end{split}\\tag{2.10}\n\\]</span></p>\n<p><span class=\"math display\">\\[\nq_{*}(s,a)=\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\max_{\\mathbf{a^{&#39;}}}q_{*}(s^{&#39;},a^{&#39;})\\right]\\tag{2.11}\n\\]</span></p>\n<p>与状态值函数的贝尔曼公式一样，最优状态值函数和最优动作值函数也可以表示成递归的形式，因此公式(2.10)和公式(2.11)又分别叫做状态值函数和动作值函数的贝尔曼最优公式（Bellman\noptimality equation）。因为没有<span\nclass=\"math inline\">\\(\\pi(a\\mid{s})\\)</span>，不需要根据策略生成动作，因此贝尔曼最优公式完全独立于策略，但如果我们已知<span\nclass=\"math inline\">\\(\\upsilon_{*}\\)</span>或<span\nclass=\"math inline\">\\(q_{*}\\)</span>，都可以很容易地得到最优策略。</p>\n<p>如果我们已知<span\nclass=\"math inline\">\\(\\upsilon_{*}\\)</span>，而且在每一步都有多个动作可以选择，可以想到最优策略的<span\nclass=\"math inline\">\\(\\upsilon_{*}(s)\\)</span>必然是满足贝尔曼最优公式的，因此至少有一个动作会满足公式中的最大化条件。任何一个采用上述动作并能够以非零概率转移到下一个状态的策略都是最优策略。我们可以把当前动作的选择看成是一个单步搜索（one-step\nsearch）的问题，在某个状态下单步搜索结果最大的动作即最优动作，而每个状态下都采取最优动作的策略即最优策略。如果我们已知<span\nclass=\"math inline\">\\(q_{*}\\)</span>，那么只需要在每一步都选择使得<span\nclass=\"math inline\">\\(q_{*}(s,a)\\)</span>最大的动作，就可以得到一个最优策略。</p>\n<p>贝尔曼公式与贝尔曼最优公式是MDP求解的基础，下面主要介绍几种MDP求解的方法。</p>\n<h2 id=\"动态规划方法\">动态规划方法</h2>\n<p>动态规划（dynamic\nprogramming）指的是能够用来解决给定环境模型，计算最优策略的算法总称。典型的动态规划算法存在两个问题，一是需要依赖一个非常好的环境状态转移模型，二是计算的开销非常大，因此在增强学习中几乎不会直接用动态规划求解MDP，但动态规划理论还是非常重要的，因为后面的一些算法都是在动态规划的基础上，摆脱模型依赖并尽可能地减少计算量。</p>\n<h3 id=\"策略估计\">策略估计</h3>\n<p>首先，我们考虑一下如果已知策略<span\nclass=\"math inline\">\\(\\pi\\)</span>，如何来计算<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>。这个问题被称作DP迭代中的策略估计（policy\nevaluation）。</p>\n<p>先举一个例子，一个岔路口有向左和向右两个方向，向左回报为10，向右回报为100，我们没有任何先验知识，但我们需要估计站在路口的值函数，也就是估计当前状态的值函数，该如何来估计呢？首先我们将值函数初始化为0，然后进行大量的尝试，每次都以0.5的概率选择方向左，并获得回报10，以0.5的概率选择方向右，获得回报100。那么只要能将这两个方向都至少遍历一遍，就可以得到该状态的值函数<span\nclass=\"math inline\">\\(\\upsilon_{随机策略}=\\frac{1}{N}\\sum_{i=0}^{N}{0.5\\cdot\nR_{i}}\\)</span>，其中<span\nclass=\"math inline\">\\(N\\)</span>为实验的总次数。</p>\n<p>同样，我们也是采用相似的方法迭代来进行策略估计的。首先将所有的<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>都初始化为0（或者任意值，但终止状态必须为0），然后采用如下公式更新所有状态<span\nclass=\"math inline\">\\(s\\)</span>的值函数。</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\upsilon_{k+1}(s) &amp;={\\bf{E}}_{\\pi}\\left[R_{t+1}+\\gamma\n\\upsilon_{k}(S_{t+1})\\mid S_{t}=s \\right] \\\\\n&amp;=\\sum_{a}\\pi(a\\mid{s})\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{k}(s^{&#39;})\\right]\n\\end{split}\\tag{3.1}\n\\]</span></p>\n<p>其中<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>表示在当前策略下第<span\nclass=\"math inline\">\\(k+1\\)</span>次迭代状态<span\nclass=\"math inline\">\\(s\\)</span>的值函数，<span\nclass=\"math inline\">\\(\\upsilon_{k}(s^{&#39;})\\)</span>表示在当前策略下第<span\nclass=\"math inline\">\\(k\\)</span>次迭代状态<span\nclass=\"math inline\">\\(s^{&#39;}\\)</span>的值函数，该公式就是用上一次迭代计算得到的值函数来更新本次迭代的值函数。在具体操作时，又有两种更新方法<sup>[6]</sup>，</p>\n<ul>\n<li>将第<span\nclass=\"math inline\">\\(k\\)</span>次迭代计算得到的所有状态值函数<span\nclass=\"math inline\">\\(\\left[\\upsilon_{k}(s_{1}),\\upsilon_{k}(s_{2}),\\upsilon_{k}(s_{3}),...\\right]\\)</span>保存在一个数组中，第<span\nclass=\"math inline\">\\(k+1\\)</span>次迭代的<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>使用第<span\nclass=\"math inline\">\\(k\\)</span>次的<span\nclass=\"math inline\">\\(\\upsilon_{k}(s^{&#39;})\\)</span>进行更新，更新后的值保存在另一个数组中。</li>\n<li>仅用一个数组来保存各状态的值函数，每次更新后就将原来的值覆盖。这样在第<span\nclass=\"math inline\">\\(k+1\\)</span>次迭代时<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>就有可能使用的是第<span\nclass=\"math inline\">\\(k+1\\)</span>次更新后的<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s^{&#39;})\\)</span>，这样可以及时地利用更新的值函数，收敛更快。</li>\n</ul>\n下面为整个策略估计的算法过程：\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/19f3246af64a89e7bf38a4d53ea26819.png?raw=true width=560>\n</div>\n<h3 id=\"策略改进\">策略改进</h3>\n<p>策略估计是为了计算当前策略下各状态的值函数，那得到值函数又有什么用呢？首先我们可以用来比较两个策略的好坏，如果状态值函数是已知的，那么就可以根据公式(2.4)计算动作值函数，如果一个策略<span\nclass=\"math inline\">\\(\\pi\\)</span>的所有动作值函数都大于另一个策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>，那么可以认为策略<span\nclass=\"math inline\">\\(\\pi\\)</span>比策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>更好。其次，最主要的用处是可以用来进行策略改进（policy\nimprovement）。</p>\n<p>仍然是上面岔路口的例子，但是假设无论向左还是向右，下一个路口都是唯一且相同的。起初由于没有任何先验知识，因此采用了一个随机策略，然后我们可以计算得到随机策略下的状态值函数，那么我们就可以进行策略改进了。具体的做法就是前面提到的单步搜索，向左时当前动作的回报为10，因此单步搜索的结果为10+<span\nclass=\"math inline\">\\(\\gamma\\upsilon\\)</span>，<span\nclass=\"math inline\">\\(\\upsilon\\)</span>为下一个路口的值函数，而向右为100+<span\nclass=\"math inline\">\\(\\gamma\\upsilon\\)</span>，因此策略会更新为向右，而不再是随机了，显然策略被改进了。同时我们注意到，单步搜索计算的值正是动作值函数。</p>\n<p>根据上面的例子，我们可以总结一下策略改进的方法：遍历所有的状态和所有可能的动作，采用贪婪算法进行策略的更新，即对所有<span\nclass=\"math inline\">\\(s\\in\\bf S\\)</span>，</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\pi^{&#39;}(s)&amp;=\\arg\\max_{\\mathbf{a}}q_{\\pi}(s,a)\\\\\n&amp;=\\arg\\max_{\\mathbf{a}}\\sum_{s^{&#39;}}p(s^{&#39;}\\mid\ns,a)\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{\\pi}(s^{&#39;})\\right]\\end{split}\\tag{3.2}\n\\]</span></p>\n<p>现在我们已经知道如何计算当前策略的状态值函数，也知道可以根据动作值函数来更新策略，那下面就来讲讲如何从零开始求解最优策略。</p>\n<h3 id=\"策略迭代\">策略迭代</h3>\n一旦策略<span\nclass=\"math inline\">\\(\\pi\\)</span>通过策略改进得到一个更好的策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>，那么我们就可以通过策略估计算法，计算策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>的状态值函数，并用公式(3.2)进行策略改进得到一个比策略<span\nclass=\"math inline\">\\(\\pi^{&#39;}\\)</span>更好的策略<span\nclass=\"math inline\">\\(\\pi^{&#39;&#39;}\\)</span>。如下图所示，经过无数次的策略估计和策略改进后，我们终将会收敛于最优策略<span\nclass=\"math inline\">\\(\\pi_{*}\\)</span>。这种通过不断迭代地去改进策略的方法叫做策略迭代（policy\niteration）。\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/c9c7ec7b0709d5492f5e8cb8a6096b7e.png?raw=true width=600>\n</div>\n</br> 下面为整个策略迭代的算法过程：\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/1b44935438fee7046950fcfddfd405c0.png?raw=true width=600>\n</div>\n<h3 id=\"值迭代\">值迭代</h3>\n<p>策略迭代算法需要不断地进行策略估计和策略改进，每次策略估计和改进都需要遍历一次所有的状态和动作，因此算法的计算量非常大，效率非常低。同时可以看到策略迭代的依据是贝尔曼公式，而如果直接利用贝尔曼最优公式会不会加速求解过程呢？事实上是可以的，下面的值迭代（value\niteration）算法就是利用贝尔曼最优公式来提高求解效率的一种算法。</p>\n<p>我们还是需要先迭代估计状态值函数，但不必每次迭代都进行策略改进。根据贝尔曼最优公式，可以直接用上一次迭代的最大动作值函数对当前迭代的状态值函数进行更新，如下所示：</p>\n<p><span class=\"math display\">\\[\n\\begin{split}\\upsilon_{k+1}(s)&amp;=\\max_{\\mathbf{a}} q_{k}(s,a) \\\\\n&amp;=\\max_{\\mathbf{a}}\\sum_{s^{&#39;}}p(s^{&#39;}\\mid{s,a})\\left[r(s,a,s^{&#39;})+\\gamma\\upsilon_{k}(s^{&#39;})\\right]\n\\end{split}\\tag{3.3}\n\\]</span></p>\n<p>值迭代算法的好处就是省去了每次迭代时的策略改进过程，并且由于每次迭代得到的<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>都要<span\nclass=\"math inline\">\\(\\geq\\)</span>策略迭代得到的<span\nclass=\"math inline\">\\(\\upsilon_{k+1}(s)\\)</span>，也就是说相同迭代次数下，策略迭代得到的策略肯定没有值迭代得到的策略好，因此能大大加快算法收敛。直到值函数收敛到最优值函数后，再通过最优值函数来计算得到最优策略，下面是值迭代算法的完整过程：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/c94f41587e075ba0ab3af4a82ff99a17.png?raw=true width=560>\n</div>\n<p></br>\n一般来说值迭代和策略迭代都需要经过无数次迭代才能精确收敛到最优策略，\n而实践中我们往往会设定一个阈值<span\nclass=\"math inline\">\\(\\Delta\\)</span>来作为迭代中止条件，即当所有的<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>变化量小于<span\nclass=\"math inline\">\\(\\Delta\\)</span>时，我们就近似的认为获得了最优策略。值迭代和策略迭代都可以用来求解最优策略，但是都需要依赖一个现有的环境模型，而对环境进行精确建模往往是非常困难的，所以导致了动态规划方法在MDP求解时几乎不可用，当然如果状态转移是确定性的（<span\nclass=\"math inline\">\\(p(s^{&#39;}\\mid\ns,a)=1\\)</span>），那就另当别论了。</p>\n<h2 id=\"蒙特卡罗方法\">蒙特卡罗方法</h2>\n<p>下面我们要讲的是蒙特卡罗方法（Monte Carlo\nMethods）。与动态规划不同，蒙特卡罗方法不需要知道环境的完整模型，仅仅需要经验就可以获得最优策略，这些经验可以通过与环境在线或模拟交互的方式获得。在线交互显然是不需要任何环境的先验知识，模拟交互虽然需要知道环境状态的转移，但与动态规划不同的是这里不需要知道具体的转移概率。</p>\n<p>蒙特卡罗方法也称统计模拟方法，基本思想是通过对大量的重复随机事件进行统计，估计随机事件的概率分布或期望。一个典型的例子是利用蒙特卡罗方法计算圆周率。假设我们知道圆的面积公式为<span\nclass=\"math inline\">\\(S=\\pi\nr^{2}\\)</span>，那计算圆周率的公式自然就是<span\nclass=\"math inline\">\\(\\pi =\n\\frac{S}{r^{2}}\\)</span>，因此如果我们知道圆面积和圆半径，那么就可以求到圆周率。那么如何计算一个圆的面积呢？给定一个圆，我们可以画出这个圆的外切正方形，那么这个外切正方形的面积为<span\nclass=\"math inline\">\\(S_{正方形}=4r^{2}\\)</span>，现在我们往正方形区域随机投点，并统计点落在圆内的概率<span\nclass=\"math inline\">\\(p\\)</span>，那么圆面积可以这么计算：<span\nclass=\"math inline\">\\(S_{圆}=p\\cdot S_{正方形}\\)</span>，因此<span\nclass=\"math inline\">\\(\\pi=4\\cdot\np\\)</span>。可以想到，如果投点次数越多，<span\nclass=\"math inline\">\\(p\\)</span>估计越精确，<span\nclass=\"math inline\">\\(\\pi\\)</span>的结果也就越接近真实值。</p>\n<h3 id=\"蒙特卡罗策略估计\">蒙特卡罗策略估计</h3>\n<p>我们现在来考虑一下如何利用蒙特卡罗方法估计给定策略下的状态值函数。与上面计算圆周率的例子稍有不同的是，现在我们估计的是未来回报的期望，而不是概率，但基本思想是一样的。很显然，如果要估计<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>，我们首先需要根据给定策略生成大量的经验数据，然后从中统计从状态<span\nclass=\"math inline\">\\(s\\)</span>开始的未来回报的平均值，这个平均值就是我们估计的状态值函数。这种利用蒙特卡罗方法进行策略估计的算法又叫做蒙特卡罗策略估计（Monte\nCarlo Policy Evaluation）。</p>\n<p>蒙特卡罗策略估计在具体实现时又分为first-visit MC methods和every-visit\nMC methods。由于在一个episode中，状态<span\nclass=\"math inline\">\\(s\\)</span>可能会出现多次，first-visit MC\nmethods就是只统计第一次到达该状态的未来回报，而every-visit MC\nmethods是所有达到该状态的未来回报都会统计累加起来。下面我们举例说明first-visit\nMC methods的估计方法<sup>[6]</sup>。</p>\n<p>现在我们假设有如下一些样本（下图每一行都是在当前策略下的一个独立的episode），紫色实心点为状态<span\nclass=\"math inline\">\\(s\\)</span>，取折扣因子γ=1，即直接计算累积回报。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/221402112851854.png?raw=true>\n</div>\n<p></br> 第一个episode中到达过两次状态<span\nclass=\"math inline\">\\(s\\)</span>，我们只计算第一次的未来回报<span\nclass=\"math inline\">\\(R_{1}(s)=1-2+0+1-3+5=2\\)</span>。假设我们已经用相同的方法计算得到<span\nclass=\"math inline\">\\(R_{2}(s)=1\\)</span>，<span\nclass=\"math inline\">\\(R_{3}(s)=-5\\)</span>，<span\nclass=\"math inline\">\\(R_{4}(s)=4\\)</span>。那么当前策略下状态<span\nclass=\"math inline\">\\(s\\)</span>的值函数</p>\n<p><span class=\"math display\">\\[\\upsilon_{\\pi}(s)={\\bf\nE}\\left[R(s)\\right]=\\frac{1}{N}\\sum_{i=1}^{N}\\left[R_{i}(s)\\right]=\\frac{1}{4}\\left(2+1-5+4\\right)=0.5\\]</span></p>\n<p>同样，如果生成的episode数量越多，<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>的估计就越接近真实值，下面是具体的算法流程：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/079fef1ab5cd0065007ae82d893b0520.png?raw=true width=560>\n</div>\n<p></br> 注意这里使用大写的<span\nclass=\"math inline\">\\(V\\)</span>表示状态值函数的估计，Sutton的理由是状态值函数一旦初始化，就会立即变成一个随机的值了，因为<span\nclass=\"math inline\">\\(G\\)</span>会随着生成的episode不同而不断变化。可以认为每次<span\nclass=\"math inline\">\\(G\\)</span>都为<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}(s)\\)</span>的一个独立同分布估计，当数据量非常大时<span\nclass=\"math inline\">\\(V(s)\\)</span>将最终收敛于这个分布的均值。</p>\n<h3 id=\"动作值函数的蒙特卡罗估计\">动作值函数的蒙特卡罗估计</h3>\n<p>由于我们没有完整的环境状态转移模型，因此即使我们得到当前策略的值函数，根据公式(3.2)也无法进行策略改进。既然我们可以估计得到状态值函数，那么肯定也可以用相同的方法直接估计动作值函数，在这里叫做动作值函数的蒙特卡罗估计（Monte\nCarlo Estimation of Action Values）。</p>\n<p>估计方法跟蒙特卡罗策略估计差不多，只不过我们需要找到所有的状态动作对(pair\nof state <span class=\"math inline\">\\(s\\)</span> and action <span\nclass=\"math inline\">\\(a\\)</span>)，然后统计每一个状态动作对的未来回报的平均值，即<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>的估计值。得到了<span\nclass=\"math inline\">\\(q_{\\pi}(s,a)\\)</span>，我们就可以根据公式(3.2)进行策略改进了。</p>\n<h3 id=\"蒙特卡罗控制\">蒙特卡罗控制</h3>\n<p>蒙特卡罗控制（Monte Carlo\nControl）首要的问题就是如何估计最优策略。跟之前动态规划一样，这里也可以采用策略迭代和策略改进交替进行的方式，经过大量的迭代后收敛到最优策略。但蒙特卡罗方法有一个最大的问题，即我们需要产生无数的episode才能保证收敛到最优结果。无数的episode和大量的迭代导致计算量巨大，效率非常低。Sutton在书<sup>[1]</sup>中提到两种解决方法，其中一种方法是采用episode-by-episode的方式进行优化。</p>\n<p>episode-by-episode的思想与动态规划中值迭代的in-place版本非常相似。在动态规划的值迭代中，我们每次迭代都直接覆盖更新值函数，因此能及时地利用到更新后的值函数，从而能加快收敛。episode-by-episode则是先用当前策略生成一个episode，然后根据这个episode进行动作值函数的更新，同时更新策略，并利用更新后的策略继续生成后续的episode。</p>\n<p>下面是exploring starts的蒙特卡罗控制（Monte Carlo ES，exploring\nstarts指的是从一个随机的开始状态和动作生成一个episode）算法的完整过程：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/608a1293a52fa134b5168042bf7fd519.png?raw=true width=560>\n</div>\n<p></br> 至于为何要使用exploring\nstarts，这与episode-by-episode在线生成episode的更新策略有关。还是上面的岔路口的例子，我们先随机指定一个策略，比如指定向左，那么使用该策略生成一个episode时必然也是向左，那么也就只能更新向左的动作值函数了，而无法更新向右的动作值函数。由于动作值函数是随机初始化的，如果向右的动作值函数初始值小于更新后的向左的动作值函数，那么下一次生成episode时仍然是向左，并且可以想象可能永远不会选择向右。但其实向右才是最优动作，因此上述更新的策略永远不可能是最优策略。但随机选择开始状态和动作，可以避免某些动作的值函数不会更新的问题，因此可以保证能获得最优策略。</p>\n<p>当然也可以采用其他方法避免使用exploring\nstarts，下面要介绍的on-policy方法和off-policy方法就是其中的两种方法。</p>\n<h3 id=\"on-policy蒙特卡罗控制\">On-Policy蒙特卡罗控制</h3>\n<p>前面的Monte Carlo ES算法使用exploring\nstarts是为了保证所有可能的动作值函数都能得到更新，从而保证能获得最优策略。如果策略本身就可以在任何状态下都采取所有可能的动作，而不是贪婪地只选择动作值函数最大的那个，那问题不就迎刃而解了吗。下面要讨论策略是非确定性的，也就是对于所有的状态<span\nclass=\"math inline\">\\(s\\)</span>和该状态下所有可能的动作<span\nclass=\"math inline\">\\(a\\)</span>都有<span\nclass=\"math inline\">\\(\\pi(a\\mid s)&gt;0\\)</span>，并且用<span\nclass=\"math inline\">\\(\\epsilon-soft\\)</span>策略生成episode。由于我们评估和改进的策略与生成episode的策略是相同的，因此叫做on-policy方法。</p>\n<p>在<span\nclass=\"math inline\">\\(\\epsilon-soft\\)</span>策略中，大多数时候策略会选择动作值函数最大的动作（或者换句话说，以<span\nclass=\"math inline\">\\(1-\\epsilon\\)</span>的概率选择动作值函数最大的动作，<span\nclass=\"math inline\">\\(\\epsilon\\)</span>是一个非常小的正数），但也会以概率<span\nclass=\"math inline\">\\(\\epsilon\\)</span>从其他动作中随机挑选一个动作，整体算法流程：</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/a50e2ce4a881eea7b6b1a2a830f2db1d.png?raw=true width=560>\n</div>\n<h3 id=\"off-policy蒙特卡罗控制\">Off-Policy蒙特卡罗控制</h3>\n<p>在off-policy方法中，生成episode的策略与评估和改进的策略并非同一个策略。其中生成episode的策略我们叫行为策略（behavior\npolicy），而评估和改进的策略叫估计策略（estimation\npolicy）。这种方法的好处是可以使行为策略是<span\nclass=\"math inline\">\\(\\epsilon-soft\\)</span>策略，但估计策略是确定性的。下面只给出算法流程，具体推导请参考Sutton在书中的介绍<sup>[1]</sup>。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/pictures/6f3c3cd1ddbcbfb3fe3df6dc881ce4b8.png?raw=true width=560>\n</div>\n<h2 id=\"时间差分学习\">时间差分学习</h2>\n<p>时间差分学习（temporal-dierence (TD)\nlearning）结合了动态规划和蒙特卡罗方法的优点，与蒙特卡罗方法一样不需要环境模型，与动态规划一样更新估计值时只依赖于下一个状态可用的估计值，而不需要等到策略自举出完整的episode。</p>\n<h3 id=\"td预测\">TD预测</h3>\n<p>TD预测（TD\nprediction）又叫TD策略估计，就是从给定的一系列经验数据中估计出当前策略的状态值函数<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>。回顾一下蒙特卡罗控制，我们是先自举一个episode，然后根据历史episode和当前最新的episode计算从状态<span\nclass=\"math inline\">\\(s\\)</span>开始未来回报的均值，作为当前状态值函数的更新值。对上面更新方式稍做修改，我们可以用一种滑动平均的方法来更新，即只用当前episode的未来回报与状态值函数的差值来更新。一个简单的every-visit\nMC方法的更新公式就如下所示：</p>\n<p><span class=\"math display\">\\[V(S_{t})=（1-\\alpha）V(S_{t})+\\alpha\nG_{t}=V(S_{t})+\\alpha\\left[G_{t}-V(S_{t}) \\right]\\tag{4-1}\\]</span></p>\n<p><span class=\"math inline\">\\(V(S_{t})\\)</span>表示第<span\nclass=\"math inline\">\\(t\\)</span>个时刻为状态<span\nclass=\"math inline\">\\(S_{t}\\)</span>的状态值函数，<span\nclass=\"math inline\">\\(G_{t}\\)</span>表示从状态<span\nclass=\"math inline\">\\(S_{t}\\)</span>开始到episode结束时的总回报，<span\nclass=\"math inline\">\\(\\alpha\\)</span>是一个常数步长参数（梯度下降算法中叫学习率），这个公式叫做<span\nclass=\"math inline\">\\(constant-\\alpha\\)</span> MC。在这个公式中，<span\nclass=\"math inline\">\\(G_{t}\\)</span>是需要等到整个episode结束才能得到的，因此只有在自举完整的episode后才能进行更新。下面要说的TD算法就很好地解决了这个问题，只需要等到下一个时刻转移到下一个状态和获得回报值。下面是一种最简单的TD算法，叫做TD(0)。</p>\n<p><span\nclass=\"math display\">\\[V(S_{t})=V(S_{t})+\\alpha\\left[R_{t+1}+\\gamma\nV(S_{t+1})-V(S_{t}) \\right]\\tag{4-2}\\]</span></p>\n<p>我们这里只是用<span class=\"math inline\">\\(R_{t+1}+\\gamma\nV(S_{t+1})\\)</span>来估计<span\nclass=\"math inline\">\\(constant-\\alpha\\)</span>\nMC中未来回报的真实值。与蒙特卡罗控制一样，TD(0)也能确保收敛到最优状态值函数，当然前提也是需要大量的经验数据。至于TD(0)与蒙特卡罗控制哪个算法收敛更快，这个问题并没有准确的答案，不过Sutton在书中指出，在一些随机任务上TD(0)比<span\nclass=\"math inline\">\\(constant-\\alpha\\)</span>\nMC收敛更快。TD(0)算法在每个时刻都要进行一次更新，更高效的方法是在训练时使用batch\nupdating的方式，即一个batch进行一次更新。</p>\n<p>显然，TD learning相比MC有以下优点<sup>[7]</sup>：</p>\n<ul>\n<li>由于TD预测使用差值进行更新，加上步进参数<span\nclass=\"math inline\">\\(\\alpha\\)</span>的存在，TD\nlearning的更新更平稳，方差更小。</li>\n<li>TD\nlearning可以用于在线训练，因为不需要等到整个episode结束才更新。</li>\n<li>TD learning应用更广，可以用于非有限步数的情况。</li>\n</ul>\n<p>但也存在一些缺点，比如TD\nlearning对初始值比较敏感，以及收敛结果是有偏的。</p>\n<h3 id=\"tdλ\">TD(λ)</h3>\n<p>在介绍TD(λ)之前，我们先介绍一下n-Step\nTD预测。前面介绍的TD(0)算法在当前状态的基础上往后执行一步就可以进行更新，并且在更新时使用了贝尔曼公式对当前状态的未来回报进行估计，那我们是不是也可以往后执行n步之后再更新，这样用贝尔曼公式估计的未来回报是不是会更加精确呢？实际上，当n等于整个episode的总步数时，n-Step\nTD预测就完全成了MC估计了。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/8aabe6f419dfeca3f4ee9de376ceb3bd.png?raw=true width=540>\n</div>\n<p></br></p>\n<p>对于1-step来说，未来回报的值等于第一个回报值加上下一个状态值函数折扣后的值，用公式表示：</p>\n<p><span class=\"math display\">\\[G_{t}^{(1)}=R_{t+1}+\\gamma\nV(S_{t+1})\\]</span></p>\n<p>2-step比1-step多执行一步，其未来回报值为：</p>\n<p><span class=\"math display\">\\[G_{t}^{(2)}=R_{t+1}+\\gamma\nR_{t+2}+\\gamma^{2} V(S_{t+2})\\]</span></p>\n<p>那么n-step的未来回报值为：</p>\n<p><span class=\"math display\">\\[G_{t}^{(n)}=R_{t+1}+\\gamma\nR_{t+2}+\\gamma^{2} V(S_{t+2})+...+\\gamma^{n}V(S_{t+n})\\]</span></p>\n<p>在公式(4-1)中我们用<span\nclass=\"math inline\">\\(G_{t}^{(n)}\\)</span>替代<span\nclass=\"math inline\">\\(G_{t}\\)</span>，最后n-Step\nTD预测的更新公式为：</p>\n<p><span\nclass=\"math display\">\\[V(S_{t})=V(S_{t})+\\alpha\\left[G_{t}^{(n)}-V(S_{t})\n\\right]\\tag{4-3}\\]</span></p>\nn-Step\nTD预测一定程度上可以使得估计的值函数更准确，因此收敛效果会更好，但更新时需要等待的步数增加了。下图是使用n-Step\nTD方法在random walk任务上的RMS error对比。\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/3a775aa18ad1b86a07d3b75d52b1c25c.png?raw=true width=600>\n</div>\n<p></br> n-Step TD只使用了从当前状态开始执行n步未来回报的估计值<span\nclass=\"math inline\">\\(G_{t}^{(n)}\\)</span>，其实为了充分利用中间每个step的信息，也可以使用不同的n对应的<span\nclass=\"math inline\">\\(G_{t}^{(n)}\\)</span>的平均值。比如可以把2-step和4-step的均值作为<span\nclass=\"math inline\">\\(G_{t}\\)</span>的估计值，</p>\n<p><span\nclass=\"math display\">\\[G_{t}^{avg}=\\frac{1}{2}G_{t}^{(2)}+\\frac{1}{2}G_{t}^{(4)}\\]</span></p>\n<p>TD(λ)也可以理解为一种特殊的n-step平均算法，每个n-step的权重为<span\nclass=\"math inline\">\\((1-\\lambda)\\lambda^{(n-1)}\\)</span>，所有权重和仍然为1，因此有：</p>\n<p><span\nclass=\"math display\">\\[G_{t}^{(\\lambda)}=(1-\\lambda)\\sum_{n=1}^{\\infty}\\lambda^{n-1}G_{t}^{(n)}\\tag{4-4}\\]</span></p>\n<p>公式(4-4)表示的是没有终止状态的情况，对于最终存在终止状态的episode任务或截断任务<sup>[注1]</sup>来讲，为了保证所有权重的和为1，最后一个n-step的权重被设置为<span\nclass=\"math inline\">\\(\\lambda^{T-t-1}\\)</span>，其中<span\nclass=\"math inline\">\\(T\\)</span>为episode总步数。</p>\n<p><span\nclass=\"math display\">\\[G_{t}^{(\\lambda)}=(1-\\lambda)\\sum_{n=1}^{T-t-1}\\lambda^{n-1}G_{t}^{(n)}+\\lambda^{T-t-1}G_{t}\\tag{4-5}\\]</span></p>\n<p>当<span\nclass=\"math inline\">\\(\\lambda=1\\)</span>时，这时TD(λ)就相当于MC，而当<span\nclass=\"math inline\">\\(\\lambda=0\\)</span>时，TD(λ)就退化成了TD(0)。</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/294acecc263a9668bd48e3403f9b5225.png?raw=true\" width=540>\n</div>\n<p></br></p>\n<h3 id=\"sarsa\">Sarsa</h3>\n<p>接下来我们考虑一下如何使用TD预测进行策略改进。首先我们知道可以使用TD预测来估计状态值函数，并且可以使用公式(3-2)进行策略改进。但问题来了，公式(3-2)中的<span\nclass=\"math inline\">\\(p(s^{&#39;}\\mid\ns,a)\\)</span>是未知参数，无法直接进行策略改进。回顾一下蒙特卡洛控制方法，TD也可以直接对动作值函数<span\nclass=\"math inline\">\\(q_{\\pi}\\)</span>进行估计。与<span\nclass=\"math inline\">\\(\\upsilon_{\\pi}\\)</span>的更新公式一样，下面是<span\nclass=\"math inline\">\\(q_{\\pi}\\)</span>的更新公式，</p>\n<p><span\nclass=\"math display\">\\[Q(S_t,A_t)=Q(S_t,A_t)+\\alpha[R_{t+1}+\\gamma\nQ(S_{t+1},A_{t+1})-Q(S_t,A_t)]\\tag{4-3}\\]</span></p>\n有了状态值函数，接下来就可以使用公式(3-2)进行策略改进了。在公式(4-3)中，每次非结束状态<span\nclass=\"math inline\">\\(S_t\\)</span>转移到下一个状态时都进行一次值函数的更新，每次更新都只与<span\nclass=\"math inline\">\\((S_t,A_t,R_{t+1},S_{t+1},A_{t+1})\\)</span>有关，因此叫做Sarsa算法。如果状态<span\nclass=\"math inline\">\\(S_{t+1}\\)</span>为终止状态，则<span\nclass=\"math inline\">\\(Q(S_{t+1},A_{t+1})=0\\)</span>。下面是Sarsa <span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>算法的完整过程，由于评估和改进时采用的策略与生成episode的策略是同一个策略，因此Sarsa算法是一种on-policy方法。\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/a8d5cc18d1df07802931d29487b29542.png?raw=true width=600>\n</div>\n<p></br> Sarsa的<span class=\"math inline\">\\(Q\\)</span>值更新公式与<span\nclass=\"math inline\">\\(TD(0)\\)</span>一致，实际上也可以采用<span\nclass=\"math inline\">\\(TD(λ)\\)</span>的形式进行<span\nclass=\"math inline\">\\(Q\\)</span>值更新，这个改进算法就是Sarsa(λ)。关于Sarsa(λ)的具体介绍请参考《Reinforcement\nLearning: An Introduction》一书第七章。</p>\n<h3 id=\"q-learning\">Q-Learning</h3>\n<p>下面介绍的Q学习是一种off-policy方法，并被认为是强化学习算法最重要的突破之一。在Q-learning中，动作值函数的更新完全独立于生成episode的策略，使得学习到的<span\nclass=\"math inline\">\\(Q(S_t,A_t)\\)</span>直接是最优动作值函数<span\nclass=\"math inline\">\\(q_{*}\\)</span>的估计值。</p>\n<p><span\nclass=\"math display\">\\[Q(S_t,A_t)=Q(S_t,A_t)+\\alpha[R_{t+1}+\\gamma\n\\mathop \\max_{a} Q(S_{t+1},a)-Q(S_t,A_t)]\\tag{4-4}\\]</span></p>\n<p>公式(4-4)为Q-learning的单步更新公式，与Sarsa唯一的不同是：类似于动态规划中的值迭代算法，Q学习也是直接使用最优的<span\nclass=\"math inline\">\\(Q(S_{t+1},\nA_{t+1})\\)</span>进行更新，也就相当于策略只采用了最大<span\nclass=\"math inline\">\\(Q\\)</span>值对应的动作。\nQ-learning简化了算法分析和收敛性证明的难度，使得它的收敛性很早就得到了证明。但与前面介绍的蒙特卡洛控制一样，由于每次只选择<span\nclass=\"math inline\">\\(Q\\)</span>值最大的动作，因此这个算法也会导致部分state-action对不会被策略生成，相应的动作值函数也无法得到更新。为了确保能收敛到最优策略，下面的算法在生成episode时同样使用了<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略，但更新时仍然采用确定性策略（即策略只选择<span\nclass=\"math inline\">\\(Q\\)</span>值最大的动作）。</p>\n<div data-align=\"center\">\n<img src=https://github.com/hjchen2/personal/blob/master/blog/强化学习/3e01e229dc9f53393a25ded669fc0971.png?raw=true width=600>\n</div>\n<h2 id=\"dqn\">DQN</h2>\n<h2 id=\"dqn改进算法\">DQN改进算法</h2>\n<h2 id=\"强化学习在内容推荐中的应用\">强化学习在内容推荐中的应用</h2>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>1、Reinforcement Learning: An Introduction, Richard S. Sutton and\nAndrew G. Barto，2012<br />\n2、Playing Atari with Deep Reinforcement Learning，DeepMind\nTechnologies，Arxiv 2013.12<br />\n3、Human-level control through deep reinforcement learning，DeepMind\nTechnologies，Nature 2015.02<br />\n4、DeepMind官网\nhttps://deepmind.com/blog/deep-reinforcement-learning<br />\n5、https://www.nervanasys.com/demystifying-deep-reinforcement-learning<br />\n6、http://www.cnblogs.com/jinxulin/p/3511298.html<br />\n7、Introduction to Reinforcement Learning，David Silver</p>\n<h2 id=\"注释\">注释</h2>\n<p>1、截断任务：在强化学习中，非episode任务由于不存在终止状态，为了便于训练可以将非episode任务截断成episode。</p>"},{"title":"模型压缩之pruning","date":"2018-01-02T14:00:04.000Z","_content":"\n## Regularization of Neural Networks using DropConnect\n\n- DropConnect主要是用来解决全连接过拟合问题的，是Dropout的通用实现。随着神经网络参数量越来越大，过拟合的风险越来越高，之前的一些经验是使用L1/L2以及Dropout。Dropout随机地将激活函数输出置0，导致每次参与训练的参数量变少，由于随机drop的关系，每次训练的网络都可能不一样，因此实际上我们训练的是多个子模型组成的混合模型。\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/0.png)\n\n\n\n- Dropout\n\n  如果考虑激活函数为tanh和relu，则dropout的输出：\n\n  $$r=m*a(Wv)=a(m*(Wv))$$\n\n  inference时混合模型的输出：\n\n  $o=E_{M}[a(M*(Wv))] \\approx a(E_{M}[(M*W)v])=a(pWv)$\n\n  $M$是$m$的repeat得到的矩阵。\n\n\n- DropConnect\n\n  随机地将全连接层的权重值置0，即输出为：\n\n  $$r=a((M*W)v)$$\n\n  $M$是与$W$大小一致的0-1矩阵，并且$M_{ij}$服从Bernoulli(p)分布。\n\n  inference时混合模型的输出：\n\n  $$o=E_{M}[a((M*W)v)] \\approx E_{u}[a(u)] $$\n\n  where $u\\sim N(pWv, p(1-p)(W*W)(v*v))$\n\n  注：对于$u$的分布论文中提到用高斯矩匹配估计，但也可以用中心极限定理进行估计\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/3.png)   \n\n\n训练时的伪代码：\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1.png)\n\ninference时的伪代码：\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/2.png)\n\n- 实验结果\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/4.png)\n\n\n- 总结\n\n  DropConnect的初衷是解决过拟合问题的，DropConnect虽然在训练时可以将稠密矩阵乘转化成稀疏乘的方式，减少计算量，但在inference时还是需要完整的计算一遍，然后再利用正态分布多次采样后计算均值得到下一层的输入，因此inference的计算量反而增加了。论文给出的实验结果表明DropConnect在tanh和relu激活函数时会比dropout带来更低的测试错误率，sigmoid时会比dropout差点。DropConnect给模型压缩提供了一些思路，在训练时我们都倾向于选择更复杂的模型而需要非常大的计算量，DropConnect的做法表明这些复杂的模型实际上有大量的冗余，而去除这些冗余后并不会对模型产生任何伤害，反而会增强模型的泛化能力，因此在模型压缩中，对模型进行剪枝成了一个重要的研究方向。\n\n\n\n##Learning bothWeights and Connections for Efficient Neural Network\n\n- 作者首先关注到神经网络预测时的能耗问题，下面给出了一个45nm的CMOS处理器能耗表。\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/5.png)\n\n内存读取的能量消耗比其他数学指令高出三个数量级，因此论文提出对神经网络进行剪枝以压缩模型大小，减少内存读取消耗并降低计算量。剪枝不仅降低了模型复杂度，也减少了过拟合。除了剪枝，文中也提到可以借鉴HashedNets的方法进行模型参数共享，进一步降低模型大小。\n\n模型剪枝分成三步：\n\n1、正常训练模型，得到每个连接的重要程度（重要程度可以用权值的绝对值表示）\n\n2、删除重要程度低的连接，将稠密网络转换成稀疏网络\n\n3、使用保留下来的连接重训模型\n\n第2步和第3步迭代进行。\n\n![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/6.png)\n\n- 正则化\n\n  关于正则化对剪枝结果的影响，论文给出的结论是：剪枝后重训前L1正则比L2效果好，但重训后L2比L1效果好。\n\n- Dropout  Ratio调整\n\n  Dropout仍然被用来抑制过拟合，但是由于剪枝会减小模型大小，因此重训时Dropout ratio也应该更小。\n\n  $$D_{r}=D_{0}\\sqrt{\\frac{C_{ir}}{C_{io}}}$$\n\n  $$C_{i}=N_{i}N_{i-1}$$\n\n  其中$D_{r}$为重训的ratio，$D_{0}$为原始的ratio，$N_{i}$为第$i$层的神经元个数。\n\n- 重训参数\n\n  由于神经网络的连续层往往保持耦合性，因此重训模型时最好保持连接的权重，而不是重新初始化。并且卷积层和全连接层的剪枝是交替进行的，对fc进行剪枝重训时需要保持conv不变，反之对conv进行剪枝重训时需要保持fc不变。\n\n- 迭代剪枝\n\n  迭代剪枝的方式可以最大程度的压缩模型大小。在不损失效果的前提下，相比单次剪枝，多次迭代的方式可以将AlexNet的压缩率从5X提高到9X。\n\n- 裁剪神经元\n\n  每次剪枝可以将那些没有输入连接或没有输出连接的神经元移除。无输出的神经元对最终模型结果没有任何影响，因此移除也不会对模型效果产生影响，而那些没有输入连接的神经元由于梯度下降和正则化最终也会变成无输出的神经元。\n\n- 实验结果\n\n  文中将裁剪门限设置为一个质量参数乘以这一层权重的标准差，并在LeNet、AlexNet和VGG-16上进行了相关实验，卷积层也可以跟全连接层一样使用相同的剪枝策略，重训模型时会有一次调整学习率的过程，比如LeNet重训时学习率会衰减到原来的1/10，AlexNet会衰减至原来的1/100。\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1-2.png)\n\n  AlexNet各层的压缩情况：![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1-3.png)\n\n  剪枝与其他模型压缩方法的对比：\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/2-2.png)\n\n- 模型保存\n\n  稀疏矩阵在保存时需要同时保存indices，比如按照CSR格式保存时，我们除了保存所有的非零元素外，还需要保存每个元素对应的列号以及每行第一个非零元素在所有元素中的位置。为了压缩保存indices带来的开销，文中提到使用相对indices代替绝对indices，全连接层可以使用5bit来表示相对indices，而卷积层也可以只使用8bit。\n\n- 总结\n\n  由于卷积层本身就是稀疏连接，相比fc对剪枝更敏感，因此剪枝方法对于全连接层的压缩率更高。剪枝只能压缩模型大小，但inference时并不会带来预测速度提升。intel在16年提出另一个剪枝与嫁接相结合的方法[Dynamic Network Surgery for Efficient DNNs](https://arxiv.org/pdf/1608.04493.pdf)，进一步提高了剪枝方法的压缩率和重训收敛速度，此外2017年孙剑等提出了针对卷积层的[Channel Pruning方法](https://arxiv.org/pdf/1707.06168.pdf)，可以结合此处的剪枝方法，应该可以达到更好的压缩效果。\n\n\n##Channel Pruning for Accelerating Very Deep Neural Networks\n","source":"_posts/模型压缩论文阅读记录.md","raw":"---\n\ntitle: 模型压缩之pruning\n\ndate: 2018-01-02 22:00:04\n\ncategory: model compression\n\ntags: [pruning]\n\n---\n\n## Regularization of Neural Networks using DropConnect\n\n- DropConnect主要是用来解决全连接过拟合问题的，是Dropout的通用实现。随着神经网络参数量越来越大，过拟合的风险越来越高，之前的一些经验是使用L1/L2以及Dropout。Dropout随机地将激活函数输出置0，导致每次参与训练的参数量变少，由于随机drop的关系，每次训练的网络都可能不一样，因此实际上我们训练的是多个子模型组成的混合模型。\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/0.png)\n\n\n\n- Dropout\n\n  如果考虑激活函数为tanh和relu，则dropout的输出：\n\n  $$r=m*a(Wv)=a(m*(Wv))$$\n\n  inference时混合模型的输出：\n\n  $o=E_{M}[a(M*(Wv))] \\approx a(E_{M}[(M*W)v])=a(pWv)$\n\n  $M$是$m$的repeat得到的矩阵。\n\n\n- DropConnect\n\n  随机地将全连接层的权重值置0，即输出为：\n\n  $$r=a((M*W)v)$$\n\n  $M$是与$W$大小一致的0-1矩阵，并且$M_{ij}$服从Bernoulli(p)分布。\n\n  inference时混合模型的输出：\n\n  $$o=E_{M}[a((M*W)v)] \\approx E_{u}[a(u)] $$\n\n  where $u\\sim N(pWv, p(1-p)(W*W)(v*v))$\n\n  注：对于$u$的分布论文中提到用高斯矩匹配估计，但也可以用中心极限定理进行估计\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/3.png)   \n\n\n训练时的伪代码：\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1.png)\n\ninference时的伪代码：\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/2.png)\n\n- 实验结果\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/4.png)\n\n\n- 总结\n\n  DropConnect的初衷是解决过拟合问题的，DropConnect虽然在训练时可以将稠密矩阵乘转化成稀疏乘的方式，减少计算量，但在inference时还是需要完整的计算一遍，然后再利用正态分布多次采样后计算均值得到下一层的输入，因此inference的计算量反而增加了。论文给出的实验结果表明DropConnect在tanh和relu激活函数时会比dropout带来更低的测试错误率，sigmoid时会比dropout差点。DropConnect给模型压缩提供了一些思路，在训练时我们都倾向于选择更复杂的模型而需要非常大的计算量，DropConnect的做法表明这些复杂的模型实际上有大量的冗余，而去除这些冗余后并不会对模型产生任何伤害，反而会增强模型的泛化能力，因此在模型压缩中，对模型进行剪枝成了一个重要的研究方向。\n\n\n\n##Learning bothWeights and Connections for Efficient Neural Network\n\n- 作者首先关注到神经网络预测时的能耗问题，下面给出了一个45nm的CMOS处理器能耗表。\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/5.png)\n\n内存读取的能量消耗比其他数学指令高出三个数量级，因此论文提出对神经网络进行剪枝以压缩模型大小，减少内存读取消耗并降低计算量。剪枝不仅降低了模型复杂度，也减少了过拟合。除了剪枝，文中也提到可以借鉴HashedNets的方法进行模型参数共享，进一步降低模型大小。\n\n模型剪枝分成三步：\n\n1、正常训练模型，得到每个连接的重要程度（重要程度可以用权值的绝对值表示）\n\n2、删除重要程度低的连接，将稠密网络转换成稀疏网络\n\n3、使用保留下来的连接重训模型\n\n第2步和第3步迭代进行。\n\n![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/6.png)\n\n- 正则化\n\n  关于正则化对剪枝结果的影响，论文给出的结论是：剪枝后重训前L1正则比L2效果好，但重训后L2比L1效果好。\n\n- Dropout  Ratio调整\n\n  Dropout仍然被用来抑制过拟合，但是由于剪枝会减小模型大小，因此重训时Dropout ratio也应该更小。\n\n  $$D_{r}=D_{0}\\sqrt{\\frac{C_{ir}}{C_{io}}}$$\n\n  $$C_{i}=N_{i}N_{i-1}$$\n\n  其中$D_{r}$为重训的ratio，$D_{0}$为原始的ratio，$N_{i}$为第$i$层的神经元个数。\n\n- 重训参数\n\n  由于神经网络的连续层往往保持耦合性，因此重训模型时最好保持连接的权重，而不是重新初始化。并且卷积层和全连接层的剪枝是交替进行的，对fc进行剪枝重训时需要保持conv不变，反之对conv进行剪枝重训时需要保持fc不变。\n\n- 迭代剪枝\n\n  迭代剪枝的方式可以最大程度的压缩模型大小。在不损失效果的前提下，相比单次剪枝，多次迭代的方式可以将AlexNet的压缩率从5X提高到9X。\n\n- 裁剪神经元\n\n  每次剪枝可以将那些没有输入连接或没有输出连接的神经元移除。无输出的神经元对最终模型结果没有任何影响，因此移除也不会对模型效果产生影响，而那些没有输入连接的神经元由于梯度下降和正则化最终也会变成无输出的神经元。\n\n- 实验结果\n\n  文中将裁剪门限设置为一个质量参数乘以这一层权重的标准差，并在LeNet、AlexNet和VGG-16上进行了相关实验，卷积层也可以跟全连接层一样使用相同的剪枝策略，重训模型时会有一次调整学习率的过程，比如LeNet重训时学习率会衰减到原来的1/10，AlexNet会衰减至原来的1/100。\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1-2.png)\n\n  AlexNet各层的压缩情况：![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1-3.png)\n\n  剪枝与其他模型压缩方法的对比：\n\n  ![](https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/2-2.png)\n\n- 模型保存\n\n  稀疏矩阵在保存时需要同时保存indices，比如按照CSR格式保存时，我们除了保存所有的非零元素外，还需要保存每个元素对应的列号以及每行第一个非零元素在所有元素中的位置。为了压缩保存indices带来的开销，文中提到使用相对indices代替绝对indices，全连接层可以使用5bit来表示相对indices，而卷积层也可以只使用8bit。\n\n- 总结\n\n  由于卷积层本身就是稀疏连接，相比fc对剪枝更敏感，因此剪枝方法对于全连接层的压缩率更高。剪枝只能压缩模型大小，但inference时并不会带来预测速度提升。intel在16年提出另一个剪枝与嫁接相结合的方法[Dynamic Network Surgery for Efficient DNNs](https://arxiv.org/pdf/1608.04493.pdf)，进一步提高了剪枝方法的压缩率和重训收敛速度，此外2017年孙剑等提出了针对卷积层的[Channel Pruning方法](https://arxiv.org/pdf/1707.06168.pdf)，可以结合此处的剪枝方法，应该可以达到更好的压缩效果。\n\n\n##Channel Pruning for Accelerating Very Deep Neural Networks\n","slug":"模型压缩论文阅读记录","published":1,"updated":"2023-01-03T13:54:50.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgavftt000jhbeqfm8r5aqq","content":"<h2\nid=\"regularization-of-neural-networks-using-dropconnect\">Regularization\nof Neural Networks using DropConnect</h2>\n<ul>\n<li>DropConnect主要是用来解决全连接过拟合问题的，是Dropout的通用实现。随着神经网络参数量越来越大，过拟合的风险越来越高，之前的一些经验是使用L1/L2以及Dropout。Dropout随机地将激活函数输出置0，导致每次参与训练的参数量变少，由于随机drop的关系，每次训练的网络都可能不一样，因此实际上我们训练的是多个子模型组成的混合模型。</li>\n</ul>\n<span id=\"more\"></span>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/0.png\" /></p>\n<ul>\n<li><p>Dropout</p>\n<p>如果考虑激活函数为tanh和relu，则dropout的输出：</p>\n<p><span class=\"math display\">\\[r=m*a(Wv)=a(m*(Wv))\\]</span></p>\n<p>inference时混合模型的输出：</p>\n<p><span class=\"math inline\">\\(o=E_{M}[a(M*(Wv))] \\approx\na(E_{M}[(M*W)v])=a(pWv)\\)</span></p>\n<p><span class=\"math inline\">\\(M\\)</span>是<span\nclass=\"math inline\">\\(m\\)</span>的repeat得到的矩阵。</p></li>\n<li><p>DropConnect</p>\n<p>随机地将全连接层的权重值置0，即输出为：</p>\n<p><span class=\"math display\">\\[r=a((M*W)v)\\]</span></p>\n<p><span class=\"math inline\">\\(M\\)</span>是与<span\nclass=\"math inline\">\\(W\\)</span>大小一致的0-1矩阵，并且<span\nclass=\"math inline\">\\(M_{ij}\\)</span>服从Bernoulli(p)分布。</p>\n<p>inference时混合模型的输出：</p>\n<p><span class=\"math display\">\\[o=E_{M}[a((M*W)v)] \\approx E_{u}[a(u)]\n\\]</span></p>\n<p>where <span class=\"math inline\">\\(u\\sim N(pWv,\np(1-p)(W*W)(v*v))\\)</span></p>\n<p>注：对于<span\nclass=\"math inline\">\\(u\\)</span>的分布论文中提到用高斯矩匹配估计，但也可以用中心极限定理进行估计</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/3.png\" /></p></li>\n</ul>\n<p>训练时的伪代码： <img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1.png\" /></p>\n<p>inference时的伪代码： <img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/2.png\" /></p>\n<ul>\n<li><p>实验结果</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/4.png\" /></p></li>\n<li><p>总结</p>\n<p>DropConnect的初衷是解决过拟合问题的，DropConnect虽然在训练时可以将稠密矩阵乘转化成稀疏乘的方式，减少计算量，但在inference时还是需要完整的计算一遍，然后再利用正态分布多次采样后计算均值得到下一层的输入，因此inference的计算量反而增加了。论文给出的实验结果表明DropConnect在tanh和relu激活函数时会比dropout带来更低的测试错误率，sigmoid时会比dropout差点。DropConnect给模型压缩提供了一些思路，在训练时我们都倾向于选择更复杂的模型而需要非常大的计算量，DropConnect的做法表明这些复杂的模型实际上有大量的冗余，而去除这些冗余后并不会对模型产生任何伤害，反而会增强模型的泛化能力，因此在模型压缩中，对模型进行剪枝成了一个重要的研究方向。</p></li>\n</ul>\n<p>##Learning bothWeights and Connections for Efficient Neural\nNetwork</p>\n<ul>\n<li><p>作者首先关注到神经网络预测时的能耗问题，下面给出了一个45nm的CMOS处理器能耗表。</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/5.png\" /></p></li>\n</ul>\n<p>内存读取的能量消耗比其他数学指令高出三个数量级，因此论文提出对神经网络进行剪枝以压缩模型大小，减少内存读取消耗并降低计算量。剪枝不仅降低了模型复杂度，也减少了过拟合。除了剪枝，文中也提到可以借鉴HashedNets的方法进行模型参数共享，进一步降低模型大小。</p>\n<p>模型剪枝分成三步：</p>\n<p>1、正常训练模型，得到每个连接的重要程度（重要程度可以用权值的绝对值表示）</p>\n<p>2、删除重要程度低的连接，将稠密网络转换成稀疏网络</p>\n<p>3、使用保留下来的连接重训模型</p>\n<p>第2步和第3步迭代进行。</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/6.png\" /></p>\n<ul>\n<li><p>正则化</p>\n<p>关于正则化对剪枝结果的影响，论文给出的结论是：剪枝后重训前L1正则比L2效果好，但重训后L2比L1效果好。</p></li>\n<li><p>Dropout Ratio调整</p>\n<p>Dropout仍然被用来抑制过拟合，但是由于剪枝会减小模型大小，因此重训时Dropout\nratio也应该更小。</p>\n<p><span\nclass=\"math display\">\\[D_{r}=D_{0}\\sqrt{\\frac{C_{ir}}{C_{io}}}\\]</span></p>\n<p><span class=\"math display\">\\[C_{i}=N_{i}N_{i-1}\\]</span></p>\n<p>其中<span class=\"math inline\">\\(D_{r}\\)</span>为重训的ratio，<span\nclass=\"math inline\">\\(D_{0}\\)</span>为原始的ratio，<span\nclass=\"math inline\">\\(N_{i}\\)</span>为第<span\nclass=\"math inline\">\\(i\\)</span>层的神经元个数。</p></li>\n<li><p>重训参数</p>\n<p>由于神经网络的连续层往往保持耦合性，因此重训模型时最好保持连接的权重，而不是重新初始化。并且卷积层和全连接层的剪枝是交替进行的，对fc进行剪枝重训时需要保持conv不变，反之对conv进行剪枝重训时需要保持fc不变。</p></li>\n<li><p>迭代剪枝</p>\n<p>迭代剪枝的方式可以最大程度的压缩模型大小。在不损失效果的前提下，相比单次剪枝，多次迭代的方式可以将AlexNet的压缩率从5X提高到9X。</p></li>\n<li><p>裁剪神经元</p>\n<p>每次剪枝可以将那些没有输入连接或没有输出连接的神经元移除。无输出的神经元对最终模型结果没有任何影响，因此移除也不会对模型效果产生影响，而那些没有输入连接的神经元由于梯度下降和正则化最终也会变成无输出的神经元。</p></li>\n<li><p>实验结果</p>\n<p>文中将裁剪门限设置为一个质量参数乘以这一层权重的标准差，并在LeNet、AlexNet和VGG-16上进行了相关实验，卷积层也可以跟全连接层一样使用相同的剪枝策略，重训模型时会有一次调整学习率的过程，比如LeNet重训时学习率会衰减到原来的1/10，AlexNet会衰减至原来的1/100。</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1-2.png\" /></p>\n<p>AlexNet各层的压缩情况：<img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1-3.png\" /></p>\n<p>剪枝与其他模型压缩方法的对比：</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/2-2.png\" /></p></li>\n<li><p>模型保存</p>\n<p>稀疏矩阵在保存时需要同时保存indices，比如按照CSR格式保存时，我们除了保存所有的非零元素外，还需要保存每个元素对应的列号以及每行第一个非零元素在所有元素中的位置。为了压缩保存indices带来的开销，文中提到使用相对indices代替绝对indices，全连接层可以使用5bit来表示相对indices，而卷积层也可以只使用8bit。</p></li>\n<li><p>总结</p>\n<p>由于卷积层本身就是稀疏连接，相比fc对剪枝更敏感，因此剪枝方法对于全连接层的压缩率更高。剪枝只能压缩模型大小，但inference时并不会带来预测速度提升。intel在16年提出另一个剪枝与嫁接相结合的方法<a\nhref=\"https://arxiv.org/pdf/1608.04493.pdf\">Dynamic Network Surgery for\nEfficient\nDNNs</a>，进一步提高了剪枝方法的压缩率和重训收敛速度，此外2017年孙剑等提出了针对卷积层的<a\nhref=\"https://arxiv.org/pdf/1707.06168.pdf\">Channel\nPruning方法</a>，可以结合此处的剪枝方法，应该可以达到更好的压缩效果。</p></li>\n</ul>\n<p>##Channel Pruning for Accelerating Very Deep Neural Networks</p>\n","site":{"data":{}},"excerpt":"<h2\nid=\"regularization-of-neural-networks-using-dropconnect\">Regularization\nof Neural Networks using DropConnect</h2>\n<ul>\n<li>DropConnect主要是用来解决全连接过拟合问题的，是Dropout的通用实现。随着神经网络参数量越来越大，过拟合的风险越来越高，之前的一些经验是使用L1/L2以及Dropout。Dropout随机地将激活函数输出置0，导致每次参与训练的参数量变少，由于随机drop的关系，每次训练的网络都可能不一样，因此实际上我们训练的是多个子模型组成的混合模型。</li>\n</ul>","more":"<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/0.png\" /></p>\n<ul>\n<li><p>Dropout</p>\n<p>如果考虑激活函数为tanh和relu，则dropout的输出：</p>\n<p><span class=\"math display\">\\[r=m*a(Wv)=a(m*(Wv))\\]</span></p>\n<p>inference时混合模型的输出：</p>\n<p><span class=\"math inline\">\\(o=E_{M}[a(M*(Wv))] \\approx\na(E_{M}[(M*W)v])=a(pWv)\\)</span></p>\n<p><span class=\"math inline\">\\(M\\)</span>是<span\nclass=\"math inline\">\\(m\\)</span>的repeat得到的矩阵。</p></li>\n<li><p>DropConnect</p>\n<p>随机地将全连接层的权重值置0，即输出为：</p>\n<p><span class=\"math display\">\\[r=a((M*W)v)\\]</span></p>\n<p><span class=\"math inline\">\\(M\\)</span>是与<span\nclass=\"math inline\">\\(W\\)</span>大小一致的0-1矩阵，并且<span\nclass=\"math inline\">\\(M_{ij}\\)</span>服从Bernoulli(p)分布。</p>\n<p>inference时混合模型的输出：</p>\n<p><span class=\"math display\">\\[o=E_{M}[a((M*W)v)] \\approx E_{u}[a(u)]\n\\]</span></p>\n<p>where <span class=\"math inline\">\\(u\\sim N(pWv,\np(1-p)(W*W)(v*v))\\)</span></p>\n<p>注：对于<span\nclass=\"math inline\">\\(u\\)</span>的分布论文中提到用高斯矩匹配估计，但也可以用中心极限定理进行估计</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/3.png\" /></p></li>\n</ul>\n<p>训练时的伪代码： <img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1.png\" /></p>\n<p>inference时的伪代码： <img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/2.png\" /></p>\n<ul>\n<li><p>实验结果</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/4.png\" /></p></li>\n<li><p>总结</p>\n<p>DropConnect的初衷是解决过拟合问题的，DropConnect虽然在训练时可以将稠密矩阵乘转化成稀疏乘的方式，减少计算量，但在inference时还是需要完整的计算一遍，然后再利用正态分布多次采样后计算均值得到下一层的输入，因此inference的计算量反而增加了。论文给出的实验结果表明DropConnect在tanh和relu激活函数时会比dropout带来更低的测试错误率，sigmoid时会比dropout差点。DropConnect给模型压缩提供了一些思路，在训练时我们都倾向于选择更复杂的模型而需要非常大的计算量，DropConnect的做法表明这些复杂的模型实际上有大量的冗余，而去除这些冗余后并不会对模型产生任何伤害，反而会增强模型的泛化能力，因此在模型压缩中，对模型进行剪枝成了一个重要的研究方向。</p></li>\n</ul>\n<p>##Learning bothWeights and Connections for Efficient Neural\nNetwork</p>\n<ul>\n<li><p>作者首先关注到神经网络预测时的能耗问题，下面给出了一个45nm的CMOS处理器能耗表。</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/5.png\" /></p></li>\n</ul>\n<p>内存读取的能量消耗比其他数学指令高出三个数量级，因此论文提出对神经网络进行剪枝以压缩模型大小，减少内存读取消耗并降低计算量。剪枝不仅降低了模型复杂度，也减少了过拟合。除了剪枝，文中也提到可以借鉴HashedNets的方法进行模型参数共享，进一步降低模型大小。</p>\n<p>模型剪枝分成三步：</p>\n<p>1、正常训练模型，得到每个连接的重要程度（重要程度可以用权值的绝对值表示）</p>\n<p>2、删除重要程度低的连接，将稠密网络转换成稀疏网络</p>\n<p>3、使用保留下来的连接重训模型</p>\n<p>第2步和第3步迭代进行。</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/6.png\" /></p>\n<ul>\n<li><p>正则化</p>\n<p>关于正则化对剪枝结果的影响，论文给出的结论是：剪枝后重训前L1正则比L2效果好，但重训后L2比L1效果好。</p></li>\n<li><p>Dropout Ratio调整</p>\n<p>Dropout仍然被用来抑制过拟合，但是由于剪枝会减小模型大小，因此重训时Dropout\nratio也应该更小。</p>\n<p><span\nclass=\"math display\">\\[D_{r}=D_{0}\\sqrt{\\frac{C_{ir}}{C_{io}}}\\]</span></p>\n<p><span class=\"math display\">\\[C_{i}=N_{i}N_{i-1}\\]</span></p>\n<p>其中<span class=\"math inline\">\\(D_{r}\\)</span>为重训的ratio，<span\nclass=\"math inline\">\\(D_{0}\\)</span>为原始的ratio，<span\nclass=\"math inline\">\\(N_{i}\\)</span>为第<span\nclass=\"math inline\">\\(i\\)</span>层的神经元个数。</p></li>\n<li><p>重训参数</p>\n<p>由于神经网络的连续层往往保持耦合性，因此重训模型时最好保持连接的权重，而不是重新初始化。并且卷积层和全连接层的剪枝是交替进行的，对fc进行剪枝重训时需要保持conv不变，反之对conv进行剪枝重训时需要保持fc不变。</p></li>\n<li><p>迭代剪枝</p>\n<p>迭代剪枝的方式可以最大程度的压缩模型大小。在不损失效果的前提下，相比单次剪枝，多次迭代的方式可以将AlexNet的压缩率从5X提高到9X。</p></li>\n<li><p>裁剪神经元</p>\n<p>每次剪枝可以将那些没有输入连接或没有输出连接的神经元移除。无输出的神经元对最终模型结果没有任何影响，因此移除也不会对模型效果产生影响，而那些没有输入连接的神经元由于梯度下降和正则化最终也会变成无输出的神经元。</p></li>\n<li><p>实验结果</p>\n<p>文中将裁剪门限设置为一个质量参数乘以这一层权重的标准差，并在LeNet、AlexNet和VGG-16上进行了相关实验，卷积层也可以跟全连接层一样使用相同的剪枝策略，重训模型时会有一次调整学习率的过程，比如LeNet重训时学习率会衰减到原来的1/10，AlexNet会衰减至原来的1/100。</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1-2.png\" /></p>\n<p>AlexNet各层的压缩情况：<img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/1-3.png\" /></p>\n<p>剪枝与其他模型压缩方法的对比：</p>\n<p><img\nsrc=\"https://raw.githubusercontent.com/hjchen2/personal/master/blog/pruning/2-2.png\" /></p></li>\n<li><p>模型保存</p>\n<p>稀疏矩阵在保存时需要同时保存indices，比如按照CSR格式保存时，我们除了保存所有的非零元素外，还需要保存每个元素对应的列号以及每行第一个非零元素在所有元素中的位置。为了压缩保存indices带来的开销，文中提到使用相对indices代替绝对indices，全连接层可以使用5bit来表示相对indices，而卷积层也可以只使用8bit。</p></li>\n<li><p>总结</p>\n<p>由于卷积层本身就是稀疏连接，相比fc对剪枝更敏感，因此剪枝方法对于全连接层的压缩率更高。剪枝只能压缩模型大小，但inference时并不会带来预测速度提升。intel在16年提出另一个剪枝与嫁接相结合的方法<a\nhref=\"https://arxiv.org/pdf/1608.04493.pdf\">Dynamic Network Surgery for\nEfficient\nDNNs</a>，进一步提高了剪枝方法的压缩率和重训收敛速度，此外2017年孙剑等提出了针对卷积层的<a\nhref=\"https://arxiv.org/pdf/1707.06168.pdf\">Channel\nPruning方法</a>，可以结合此处的剪枝方法，应该可以达到更好的压缩效果。</p></li>\n</ul>\n<p>##Channel Pruning for Accelerating Very Deep Neural Networks</p>"},{"title":"混合精度训练","date":"2018-02-03T04:00:04.000Z","_content":"\n\n\n## MIXED PRECISION TRAINING\n\n[https://arxiv.org/pdf/1710.03740.pdf](https://email.baidu.com/OWA/redir.aspx?C=G_TpaBQZHjfotfty5PDuHfO3av_KUOGPcZOg_60U2vdUx9QS42vVCA..&URL=https%3a%2f%2farxiv.org%2fpdf%2f1710.03740.pdf)\n\n### 论文概述\n\nnvidia的Pascal和Volta系列显卡除了支持标准的单精度计算外，也支持了低精度的计算，比如最新的Tesla V100硬件支持了FP16的计算加速，P4和P40支持INT8的计算加速，而且低精度计算的峰值要远高于单精浮点的计算峰值。\n\n<!-- more -->\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/95247900845ca0aa285aea86b971c6ec.png?raw=true'>\n\n\n\n为了加速训练过程以及减少显存开销，baidu Research和nvidia在这篇论文中合作提出了一种FP16和FP32混合精度训练的方法，并且在CNN分类和检测、语音识别和语言模型任务上进行了验证，实验过程中使用的GPU就是Tesla V100。\n\n训练过程中每层的权重都存成FP32格式（Mater-Weights），每次训练时都会将FP32的权重降精度至FP16（ a master copy），前向输出和后向梯度都使用FP16进行计算，更新时将FP16的梯度累加到FP32的Mater-Weight上。\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/b89a595f09deb2caf14d44176f931440.png?raw=true'>\n\n### 混合精度的必要性\n\n由于FP16所能表示的subnormal最小正数是$2^{−24}$ ≈ $5.96 × 10^{−8}$（[Half-precision floating-point format](https://en.wikipedia.org/wiki/Half-precision_floating-point_format)），也就是说在区间（$-2^{-24}, 2^{-24}$）的数（或者说指数位小于-24的数）使用FP16表示时都会变成0。在一个普通话识别的模型训练中，有将近5%的权重梯度的指数位小于-24，如果更新时也用FP16计算，那么这些数在乘以学习率后都将变成0，从而对最终模型效果产生负面影响，使用混合精度训练的方式可以避免这种问题。\n\n### Loss scaling\n\n混合精度训练可以解决权重更新量很小的问题，但无法解决梯度本身很小的问题。在一些网络中（比如SSD），梯度大部分都在FP16的表示范围之外，因此需要将梯度平移到FP16的表示范围内 。\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/fc960bb10d950d111404cda831aa5cbe.png?raw=true'>\n\n平移实际上就是对梯度值乘以一个系数（等于$2^{n}$，$n$为平移的位数），但另一种简单高效的方法是直接在前向时就将loss乘以scale，这样在后向传导时所有的梯度都会被乘以相同的scale。权重更新时需要将移位后的梯度除以scale后，再更新到权重上。\n\n论文中提到他们在实验过程中使用的scale是8~32K，最终取得了与FP32一致的收敛结果。对于scale的选择，论文没有统一的方法，只是提到scale并没有下界，只要选择的scale不会在后向计算时导致溢出就行。\n\n### 实验结果\n\n- 图像分类\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/a9166bfb03d36772c83f4aa56e591374.png?raw=true'>\n\n- 物体检测\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/3dbc1922becd3b150d50bc71aacecb1e.png?raw=true'>\n\n- 语音识别\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/0369372f891c65571c845b04960aafda.png?raw=true'>\n\n- 机器翻译\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/237914e80a50fe0f2cac573c36733e5c.png?raw=true'>\n\n- 语言模型\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/f1c1f41006c8f637c29208ac8652310b.png?raw=true'>\n\n  ​\n\n## MIXED PRECISION TRAINING OF CONVOLUTIONAL NEURAL NETWORKS USING INTEGER OPERATIONS\n\n[https://openreview.net/forum?id=H135uzZ0-](https://email.baidu.com/OWA/redir.aspx?C=a0s4Pl45ENd9uqHgfl_L2eKY-IGy51CKRbN_JHdP0YhUx9QS42vVCA..&URL=https%3a%2f%2fopenreview.net%2fforum%3fid%3dH135uzZ0-)\n\n### 论文概述\n\n半精度（16bit）分为半精度浮点（FP16）和半精度定点（INT16），FP16和INT16提供不同的精度和表示范围。INT16相比FP16的动态范围低，但精度更高，因此INT16相比FP16会带来更低的精度误差。\n\n现在深度学习领域公认的数据类型是单精度浮点（float），半精和单精除了在直观感觉上的数据类型不同之外，在计算（algorithmic）和语义（semantic）上也会有很多的不同，比如说FP16的乘加操作得到的结果是FP32。因此在讨论半精度训练时，对于整个tensor的表达、乘加操作、低精度转换、缩放和规整方法和溢出处理都是需要同时考虑的。\n\nintel的这篇论文主要受到之前flexpoint和混合精度训练的启发，从而提出了一种共享指数位的动态定点表达（dynamic fixed point representation）方法，使用INT16和float混合精度训练，在完全不进行任何调参的情况下，在多个CNN的模型上取得了当前所有低精度训练方法中最好的效果。\n\n这篇论文主要涉及的技术点有：\n\n- DFP：INT16的Tensor共享指数位，扩充INT16的动态表示范围。\n- instruction：两个INT16进行乘法，结果存为INT32的指令。\n- down-convert：基于最大值的低精度转换策略，使用nearest、stochastic和biased rounding三种不同的rounding方法。\n- overflow management：将局部的INT32结果累加到FP32，防止累加时溢出。\n\n\n### DFP（Dynamic Fixed Point）\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/f54c9019a7174299761d48094d1f0dab.png?raw=true'>\n\n一个DFP tensor由一个定点的tensor和该tensor共享的指数组成，更通用的表示形式为DFP-P = $<I, E_{s}>$，P表示定点tensor $I$的位宽，$E_{s}$表示共享指数位。标准单精使用的是8bit的指数位，在该论文中使用的DFP-16共享指数位也是8bit。\n\n- DFP-16和fp32的数据转换\n\n  共享指数位需要根据tensor中的绝对值最大的数和定点化的位宽来确定，计算公式如下：\n\n  $$E_{s} = E_{fmax} - (P - 2)$$\n\n  $E_{s}$表示DFP-P的共享指数，$E_{fmax}$表示原始fp32 tensor中绝对值最大的数对应的指数$E_{fmax} = E(max_{\\forall f \\in F} |f|)$\n\n  因此fp32的tensor与DFP的tensor有以下关系：\n\n  $$\\forall i_{n} \\in I, \\ \\ \\ f_{n} = i_{n} \\times 2^{E_{s}}, \\ \\ \\ where f_{n} \\in F$$\n\n  也就是说$i_{n} = rounding(\\frac{f_{n}}{2^{E_{s}}})$，这本质上与loss scaling思想是一样的，用平移的思想来解决动态范围不够的问题。\n\n- DFP-16 tensor的乘加运算规则\n\n    1、两个DFP-16 tensor相乘，结果存为DFP-32。\n\n    $$i_{ab} = i_{a} \\times i_{b} , \\ \\ \\ E_{s}^{ab} = E_{s}^{a} + E_{s}^{b}$$\n\n\n    2、两个DFP-16 tensor相加，结果存为DFP-32。\n\n    $$i_{ab} = \\left\\{\\begin{aligned} i_{a} + (i_{b} >> (E_{s}^{a} - E_{s}^{b})) \\ \\ \\ when E_{s}^{a} > E_{s}^{b} \\\\ i_{b}+(i_{a} >> (E_{s}^{b}-E_{s}^{a})) \\ \\ \\ when E_{s}^{a} < E_{s}^{b} \\end{aligned}\\right.$$\n\n    $$E_{s}^{a+b} = max(E_{s}^{a}, E_{s}^{b})$$\n\n\n    3、两个DFP-32 tensor相加，结果保存为fp32。\n\n- DFP-32和DFP-16的数据转换\n\n  $$R_{s} = P - LZC(max_{\\forall i_{ab} \\in I^{32}}|i_{ab}|)$$\n\n  $$i_{ab}^{d} = i_{ab} >> R_{s} , \\ \\ \\ E_{s}^{ab} += R_{s}$$\n\n### DFP混合精度训练\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/9b304e74b8dbc9ec6324c56d05b85f24.png?raw=true'>\n\n### 指令实现\n\nintel的VNNI指令集中有一条DFP-16乘加的指令QVNNI16，这条指令的第一个操作数是DFP-16内存指针，第二个操作数是4个512位的向量寄存器（每个寄存器可以存储32个DFP-16），结果是一个512位的向量寄存器（该寄存器能存储16个DFP-32）。\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/4a18c89da9676673a73c899987564e10.png?raw=true'>\n\n上面的QVNNI16指令集实际上对mem输入做了两路并行展开，vinp2中一个寄存器支持同时对输入feature map的两个channel进行计算。在论文中，卷积层输入的格式为（N，C/16，H，W，16），权重的格式为（C/16，K/16，KH，KW，8c，16k，2c），C表示输入feature map的通道数，K表示输出通道数，KH和KW分别表示卷积核的height和width。\n\n卷积计算过程伪代码：\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/2f5405a955c03cd522b5b1f17e7300cd.png?raw=true'>\n\n每次对输入的ICBLK个通道进行计算，ICBLK个通道又会分成（ICBLK/16）组，每组计算16个通道，由于QVNNI指令每次只能对输入的8个通道进行计算，因此每组调用2次QVNNI16指令，计算结果vout会转换成FP32后与output累加。\n\n### 实验结果\n\nbaseline和DFP-16的实验均在intel最新的Knights-Mill CPU上进行，DFP-16相比FP32训练加速1.8X。\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/55d321517c2de03fe92f7c32aff1d87a.png?raw=true'>\n\n### ABS_MAX量化方案\n\n\n\n### DFP与ABS_MAX量化的区别\n\n\n\n","source":"_posts/混合精度训练.md","raw":"---\ntitle: 混合精度训练\n\ndate: 2018-02-03 12:00:04\n\ncategory: low bitwidth\n\ntags: [int16, fp16, 混合精度训练, loss scaling, QVNNI16]\n\n---\n\n\n\n## MIXED PRECISION TRAINING\n\n[https://arxiv.org/pdf/1710.03740.pdf](https://email.baidu.com/OWA/redir.aspx?C=G_TpaBQZHjfotfty5PDuHfO3av_KUOGPcZOg_60U2vdUx9QS42vVCA..&URL=https%3a%2f%2farxiv.org%2fpdf%2f1710.03740.pdf)\n\n### 论文概述\n\nnvidia的Pascal和Volta系列显卡除了支持标准的单精度计算外，也支持了低精度的计算，比如最新的Tesla V100硬件支持了FP16的计算加速，P4和P40支持INT8的计算加速，而且低精度计算的峰值要远高于单精浮点的计算峰值。\n\n<!-- more -->\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/95247900845ca0aa285aea86b971c6ec.png?raw=true'>\n\n\n\n为了加速训练过程以及减少显存开销，baidu Research和nvidia在这篇论文中合作提出了一种FP16和FP32混合精度训练的方法，并且在CNN分类和检测、语音识别和语言模型任务上进行了验证，实验过程中使用的GPU就是Tesla V100。\n\n训练过程中每层的权重都存成FP32格式（Mater-Weights），每次训练时都会将FP32的权重降精度至FP16（ a master copy），前向输出和后向梯度都使用FP16进行计算，更新时将FP16的梯度累加到FP32的Mater-Weight上。\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/b89a595f09deb2caf14d44176f931440.png?raw=true'>\n\n### 混合精度的必要性\n\n由于FP16所能表示的subnormal最小正数是$2^{−24}$ ≈ $5.96 × 10^{−8}$（[Half-precision floating-point format](https://en.wikipedia.org/wiki/Half-precision_floating-point_format)），也就是说在区间（$-2^{-24}, 2^{-24}$）的数（或者说指数位小于-24的数）使用FP16表示时都会变成0。在一个普通话识别的模型训练中，有将近5%的权重梯度的指数位小于-24，如果更新时也用FP16计算，那么这些数在乘以学习率后都将变成0，从而对最终模型效果产生负面影响，使用混合精度训练的方式可以避免这种问题。\n\n### Loss scaling\n\n混合精度训练可以解决权重更新量很小的问题，但无法解决梯度本身很小的问题。在一些网络中（比如SSD），梯度大部分都在FP16的表示范围之外，因此需要将梯度平移到FP16的表示范围内 。\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/fc960bb10d950d111404cda831aa5cbe.png?raw=true'>\n\n平移实际上就是对梯度值乘以一个系数（等于$2^{n}$，$n$为平移的位数），但另一种简单高效的方法是直接在前向时就将loss乘以scale，这样在后向传导时所有的梯度都会被乘以相同的scale。权重更新时需要将移位后的梯度除以scale后，再更新到权重上。\n\n论文中提到他们在实验过程中使用的scale是8~32K，最终取得了与FP32一致的收敛结果。对于scale的选择，论文没有统一的方法，只是提到scale并没有下界，只要选择的scale不会在后向计算时导致溢出就行。\n\n### 实验结果\n\n- 图像分类\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/a9166bfb03d36772c83f4aa56e591374.png?raw=true'>\n\n- 物体检测\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/3dbc1922becd3b150d50bc71aacecb1e.png?raw=true'>\n\n- 语音识别\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/0369372f891c65571c845b04960aafda.png?raw=true'>\n\n- 机器翻译\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/237914e80a50fe0f2cac573c36733e5c.png?raw=true'>\n\n- 语言模型\n\n  <img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/f1c1f41006c8f637c29208ac8652310b.png?raw=true'>\n\n  ​\n\n## MIXED PRECISION TRAINING OF CONVOLUTIONAL NEURAL NETWORKS USING INTEGER OPERATIONS\n\n[https://openreview.net/forum?id=H135uzZ0-](https://email.baidu.com/OWA/redir.aspx?C=a0s4Pl45ENd9uqHgfl_L2eKY-IGy51CKRbN_JHdP0YhUx9QS42vVCA..&URL=https%3a%2f%2fopenreview.net%2fforum%3fid%3dH135uzZ0-)\n\n### 论文概述\n\n半精度（16bit）分为半精度浮点（FP16）和半精度定点（INT16），FP16和INT16提供不同的精度和表示范围。INT16相比FP16的动态范围低，但精度更高，因此INT16相比FP16会带来更低的精度误差。\n\n现在深度学习领域公认的数据类型是单精度浮点（float），半精和单精除了在直观感觉上的数据类型不同之外，在计算（algorithmic）和语义（semantic）上也会有很多的不同，比如说FP16的乘加操作得到的结果是FP32。因此在讨论半精度训练时，对于整个tensor的表达、乘加操作、低精度转换、缩放和规整方法和溢出处理都是需要同时考虑的。\n\nintel的这篇论文主要受到之前flexpoint和混合精度训练的启发，从而提出了一种共享指数位的动态定点表达（dynamic fixed point representation）方法，使用INT16和float混合精度训练，在完全不进行任何调参的情况下，在多个CNN的模型上取得了当前所有低精度训练方法中最好的效果。\n\n这篇论文主要涉及的技术点有：\n\n- DFP：INT16的Tensor共享指数位，扩充INT16的动态表示范围。\n- instruction：两个INT16进行乘法，结果存为INT32的指令。\n- down-convert：基于最大值的低精度转换策略，使用nearest、stochastic和biased rounding三种不同的rounding方法。\n- overflow management：将局部的INT32结果累加到FP32，防止累加时溢出。\n\n\n### DFP（Dynamic Fixed Point）\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/f54c9019a7174299761d48094d1f0dab.png?raw=true'>\n\n一个DFP tensor由一个定点的tensor和该tensor共享的指数组成，更通用的表示形式为DFP-P = $<I, E_{s}>$，P表示定点tensor $I$的位宽，$E_{s}$表示共享指数位。标准单精使用的是8bit的指数位，在该论文中使用的DFP-16共享指数位也是8bit。\n\n- DFP-16和fp32的数据转换\n\n  共享指数位需要根据tensor中的绝对值最大的数和定点化的位宽来确定，计算公式如下：\n\n  $$E_{s} = E_{fmax} - (P - 2)$$\n\n  $E_{s}$表示DFP-P的共享指数，$E_{fmax}$表示原始fp32 tensor中绝对值最大的数对应的指数$E_{fmax} = E(max_{\\forall f \\in F} |f|)$\n\n  因此fp32的tensor与DFP的tensor有以下关系：\n\n  $$\\forall i_{n} \\in I, \\ \\ \\ f_{n} = i_{n} \\times 2^{E_{s}}, \\ \\ \\ where f_{n} \\in F$$\n\n  也就是说$i_{n} = rounding(\\frac{f_{n}}{2^{E_{s}}})$，这本质上与loss scaling思想是一样的，用平移的思想来解决动态范围不够的问题。\n\n- DFP-16 tensor的乘加运算规则\n\n    1、两个DFP-16 tensor相乘，结果存为DFP-32。\n\n    $$i_{ab} = i_{a} \\times i_{b} , \\ \\ \\ E_{s}^{ab} = E_{s}^{a} + E_{s}^{b}$$\n\n\n    2、两个DFP-16 tensor相加，结果存为DFP-32。\n\n    $$i_{ab} = \\left\\{\\begin{aligned} i_{a} + (i_{b} >> (E_{s}^{a} - E_{s}^{b})) \\ \\ \\ when E_{s}^{a} > E_{s}^{b} \\\\ i_{b}+(i_{a} >> (E_{s}^{b}-E_{s}^{a})) \\ \\ \\ when E_{s}^{a} < E_{s}^{b} \\end{aligned}\\right.$$\n\n    $$E_{s}^{a+b} = max(E_{s}^{a}, E_{s}^{b})$$\n\n\n    3、两个DFP-32 tensor相加，结果保存为fp32。\n\n- DFP-32和DFP-16的数据转换\n\n  $$R_{s} = P - LZC(max_{\\forall i_{ab} \\in I^{32}}|i_{ab}|)$$\n\n  $$i_{ab}^{d} = i_{ab} >> R_{s} , \\ \\ \\ E_{s}^{ab} += R_{s}$$\n\n### DFP混合精度训练\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/9b304e74b8dbc9ec6324c56d05b85f24.png?raw=true'>\n\n### 指令实现\n\nintel的VNNI指令集中有一条DFP-16乘加的指令QVNNI16，这条指令的第一个操作数是DFP-16内存指针，第二个操作数是4个512位的向量寄存器（每个寄存器可以存储32个DFP-16），结果是一个512位的向量寄存器（该寄存器能存储16个DFP-32）。\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/4a18c89da9676673a73c899987564e10.png?raw=true'>\n\n上面的QVNNI16指令集实际上对mem输入做了两路并行展开，vinp2中一个寄存器支持同时对输入feature map的两个channel进行计算。在论文中，卷积层输入的格式为（N，C/16，H，W，16），权重的格式为（C/16，K/16，KH，KW，8c，16k，2c），C表示输入feature map的通道数，K表示输出通道数，KH和KW分别表示卷积核的height和width。\n\n卷积计算过程伪代码：\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/2f5405a955c03cd522b5b1f17e7300cd.png?raw=true'>\n\n每次对输入的ICBLK个通道进行计算，ICBLK个通道又会分成（ICBLK/16）组，每组计算16个通道，由于QVNNI指令每次只能对输入的8个通道进行计算，因此每组调用2次QVNNI16指令，计算结果vout会转换成FP32后与output累加。\n\n### 实验结果\n\nbaseline和DFP-16的实验均在intel最新的Knights-Mill CPU上进行，DFP-16相比FP32训练加速1.8X。\n\n<img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/55d321517c2de03fe92f7c32aff1d87a.png?raw=true'>\n\n### ABS_MAX量化方案\n\n\n\n### DFP与ABS_MAX量化的区别\n\n\n\n","slug":"混合精度训练","published":1,"updated":"2023-01-03T13:54:04.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgavftv000nhbeqeoh4hj46","content":"<h2 id=\"mixed-precision-training\">MIXED PRECISION TRAINING</h2>\n<p><a\nhref=\"https://email.baidu.com/OWA/redir.aspx?C=G_TpaBQZHjfotfty5PDuHfO3av_KUOGPcZOg_60U2vdUx9QS42vVCA..&amp;URL=https%3a%2f%2farxiv.org%2fpdf%2f1710.03740.pdf\">https://arxiv.org/pdf/1710.03740.pdf</a></p>\n<h3 id=\"论文概述\">论文概述</h3>\n<p>nvidia的Pascal和Volta系列显卡除了支持标准的单精度计算外，也支持了低精度的计算，比如最新的Tesla\nV100硬件支持了FP16的计算加速，P4和P40支持INT8的计算加速，而且低精度计算的峰值要远高于单精浮点的计算峰值。</p>\n<span id=\"more\"></span>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/95247900845ca0aa285aea86b971c6ec.png?raw=true'></p>\n<p>为了加速训练过程以及减少显存开销，baidu\nResearch和nvidia在这篇论文中合作提出了一种FP16和FP32混合精度训练的方法，并且在CNN分类和检测、语音识别和语言模型任务上进行了验证，实验过程中使用的GPU就是Tesla\nV100。</p>\n<p>训练过程中每层的权重都存成FP32格式（Mater-Weights），每次训练时都会将FP32的权重降精度至FP16（\na master\ncopy），前向输出和后向梯度都使用FP16进行计算，更新时将FP16的梯度累加到FP32的Mater-Weight上。</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/b89a595f09deb2caf14d44176f931440.png?raw=true'></p>\n<h3 id=\"混合精度的必要性\">混合精度的必要性</h3>\n<p>由于FP16所能表示的subnormal最小正数是<span\nclass=\"math inline\">\\(2^{−24}\\)</span> ≈ <span\nclass=\"math inline\">\\(5.96 × 10^{−8}\\)</span>（<a\nhref=\"https://en.wikipedia.org/wiki/Half-precision_floating-point_format\">Half-precision\nfloating-point format</a>），也就是说在区间（<span\nclass=\"math inline\">\\(-2^{-24},\n2^{-24}\\)</span>）的数（或者说指数位小于-24的数）使用FP16表示时都会变成0。在一个普通话识别的模型训练中，有将近5%的权重梯度的指数位小于-24，如果更新时也用FP16计算，那么这些数在乘以学习率后都将变成0，从而对最终模型效果产生负面影响，使用混合精度训练的方式可以避免这种问题。</p>\n<h3 id=\"loss-scaling\">Loss scaling</h3>\n<p>混合精度训练可以解决权重更新量很小的问题，但无法解决梯度本身很小的问题。在一些网络中（比如SSD），梯度大部分都在FP16的表示范围之外，因此需要将梯度平移到FP16的表示范围内\n。</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/fc960bb10d950d111404cda831aa5cbe.png?raw=true'></p>\n<p>平移实际上就是对梯度值乘以一个系数（等于<span\nclass=\"math inline\">\\(2^{n}\\)</span>，<span\nclass=\"math inline\">\\(n\\)</span>为平移的位数），但另一种简单高效的方法是直接在前向时就将loss乘以scale，这样在后向传导时所有的梯度都会被乘以相同的scale。权重更新时需要将移位后的梯度除以scale后，再更新到权重上。</p>\n<p>论文中提到他们在实验过程中使用的scale是8~32K，最终取得了与FP32一致的收敛结果。对于scale的选择，论文没有统一的方法，只是提到scale并没有下界，只要选择的scale不会在后向计算时导致溢出就行。</p>\n<h3 id=\"实验结果\">实验结果</h3>\n<ul>\n<li><p>图像分类</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/a9166bfb03d36772c83f4aa56e591374.png?raw=true'></p></li>\n<li><p>物体检测</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/3dbc1922becd3b150d50bc71aacecb1e.png?raw=true'></p></li>\n<li><p>语音识别</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/0369372f891c65571c845b04960aafda.png?raw=true'></p></li>\n<li><p>机器翻译</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/237914e80a50fe0f2cac573c36733e5c.png?raw=true'></p></li>\n<li><p>语言模型</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/f1c1f41006c8f637c29208ac8652310b.png?raw=true'></p>\n<p>​</p></li>\n</ul>\n<h2\nid=\"mixed-precision-training-of-convolutional-neural-networks-using-integer-operations\">MIXED\nPRECISION TRAINING OF CONVOLUTIONAL NEURAL NETWORKS USING INTEGER\nOPERATIONS</h2>\n<p><a\nhref=\"https://email.baidu.com/OWA/redir.aspx?C=a0s4Pl45ENd9uqHgfl_L2eKY-IGy51CKRbN_JHdP0YhUx9QS42vVCA..&amp;URL=https%3a%2f%2fopenreview.net%2fforum%3fid%3dH135uzZ0-\">https://openreview.net/forum?id=H135uzZ0-</a></p>\n<h3 id=\"论文概述-1\">论文概述</h3>\n<p>半精度（16bit）分为半精度浮点（FP16）和半精度定点（INT16），FP16和INT16提供不同的精度和表示范围。INT16相比FP16的动态范围低，但精度更高，因此INT16相比FP16会带来更低的精度误差。</p>\n<p>现在深度学习领域公认的数据类型是单精度浮点（float），半精和单精除了在直观感觉上的数据类型不同之外，在计算（algorithmic）和语义（semantic）上也会有很多的不同，比如说FP16的乘加操作得到的结果是FP32。因此在讨论半精度训练时，对于整个tensor的表达、乘加操作、低精度转换、缩放和规整方法和溢出处理都是需要同时考虑的。</p>\n<p>intel的这篇论文主要受到之前flexpoint和混合精度训练的启发，从而提出了一种共享指数位的动态定点表达（dynamic\nfixed point\nrepresentation）方法，使用INT16和float混合精度训练，在完全不进行任何调参的情况下，在多个CNN的模型上取得了当前所有低精度训练方法中最好的效果。</p>\n<p>这篇论文主要涉及的技术点有：</p>\n<ul>\n<li>DFP：INT16的Tensor共享指数位，扩充INT16的动态表示范围。</li>\n<li>instruction：两个INT16进行乘法，结果存为INT32的指令。</li>\n<li>down-convert：基于最大值的低精度转换策略，使用nearest、stochastic和biased\nrounding三种不同的rounding方法。</li>\n<li>overflow\nmanagement：将局部的INT32结果累加到FP32，防止累加时溢出。</li>\n</ul>\n<h3 id=\"dfpdynamic-fixed-point\">DFP（Dynamic Fixed Point）</h3>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/f54c9019a7174299761d48094d1f0dab.png?raw=true'></p>\n<p>一个DFP\ntensor由一个定点的tensor和该tensor共享的指数组成，更通用的表示形式为DFP-P\n= <span class=\"math inline\">\\(&lt;I, E_{s}&gt;\\)</span>，P表示定点tensor\n<span class=\"math inline\">\\(I\\)</span>的位宽，<span\nclass=\"math inline\">\\(E_{s}\\)</span>表示共享指数位。标准单精使用的是8bit的指数位，在该论文中使用的DFP-16共享指数位也是8bit。</p>\n<ul>\n<li><p>DFP-16和fp32的数据转换</p>\n<p>共享指数位需要根据tensor中的绝对值最大的数和定点化的位宽来确定，计算公式如下：</p>\n<p><span class=\"math display\">\\[E_{s} = E_{fmax} - (P - 2)\\]</span></p>\n<p><span class=\"math inline\">\\(E_{s}\\)</span>表示DFP-P的共享指数，<span\nclass=\"math inline\">\\(E_{fmax}\\)</span>表示原始fp32\ntensor中绝对值最大的数对应的指数<span class=\"math inline\">\\(E_{fmax} =\nE(max_{\\forall f \\in F} |f|)\\)</span></p>\n<p>因此fp32的tensor与DFP的tensor有以下关系：</p>\n<p><span class=\"math display\">\\[\\forall i_{n} \\in I, \\ \\ \\ f_{n} = i_{n}\n\\times 2^{E_{s}}, \\ \\ \\ where f_{n} \\in F\\]</span></p>\n<p>也就是说<span class=\"math inline\">\\(i_{n} =\nrounding(\\frac{f_{n}}{2^{E_{s}}})\\)</span>，这本质上与loss\nscaling思想是一样的，用平移的思想来解决动态范围不够的问题。</p></li>\n<li><p>DFP-16 tensor的乘加运算规则</p>\n<p>1、两个DFP-16 tensor相乘，结果存为DFP-32。</p>\n<p><span class=\"math display\">\\[i_{ab} = i_{a} \\times i_{b} , \\ \\ \\\nE_{s}^{ab} = E_{s}^{a} + E_{s}^{b}\\]</span></p>\n<p>2、两个DFP-16 tensor相加，结果存为DFP-32。</p>\n<p><span class=\"math display\">\\[i_{ab} = \\left\\{\\begin{aligned} i_{a} +\n(i_{b} &gt;&gt; (E_{s}^{a} - E_{s}^{b})) \\ \\ \\ when E_{s}^{a} &gt;\nE_{s}^{b} \\\\ i_{b}+(i_{a} &gt;&gt; (E_{s}^{b}-E_{s}^{a})) \\ \\ \\ when\nE_{s}^{a} &lt; E_{s}^{b} \\end{aligned}\\right.\\]</span></p>\n<p><span class=\"math display\">\\[E_{s}^{a+b} = max(E_{s}^{a},\nE_{s}^{b})\\]</span></p>\n<p>3、两个DFP-32 tensor相加，结果保存为fp32。</p></li>\n<li><p>DFP-32和DFP-16的数据转换</p>\n<p><span class=\"math display\">\\[R_{s} = P - LZC(max_{\\forall i_{ab} \\in\nI^{32}}|i_{ab}|)\\]</span></p>\n<p><span class=\"math display\">\\[i_{ab}^{d} = i_{ab} &gt;&gt; R_{s} , \\ \\\n\\ E_{s}^{ab} += R_{s}\\]</span></p></li>\n</ul>\n<h3 id=\"dfp混合精度训练\">DFP混合精度训练</h3>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/9b304e74b8dbc9ec6324c56d05b85f24.png?raw=true'></p>\n<h3 id=\"指令实现\">指令实现</h3>\n<p>intel的VNNI指令集中有一条DFP-16乘加的指令QVNNI16，这条指令的第一个操作数是DFP-16内存指针，第二个操作数是4个512位的向量寄存器（每个寄存器可以存储32个DFP-16），结果是一个512位的向量寄存器（该寄存器能存储16个DFP-32）。</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/4a18c89da9676673a73c899987564e10.png?raw=true'></p>\n<p>上面的QVNNI16指令集实际上对mem输入做了两路并行展开，vinp2中一个寄存器支持同时对输入feature\nmap的两个channel进行计算。在论文中，卷积层输入的格式为（N，C/16，H，W，16），权重的格式为（C/16，K/16，KH，KW，8c，16k，2c），C表示输入feature\nmap的通道数，K表示输出通道数，KH和KW分别表示卷积核的height和width。</p>\n<p>卷积计算过程伪代码：</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/2f5405a955c03cd522b5b1f17e7300cd.png?raw=true'></p>\n<p>每次对输入的ICBLK个通道进行计算，ICBLK个通道又会分成（ICBLK/16）组，每组计算16个通道，由于QVNNI指令每次只能对输入的8个通道进行计算，因此每组调用2次QVNNI16指令，计算结果vout会转换成FP32后与output累加。</p>\n<h3 id=\"实验结果-1\">实验结果</h3>\n<p>baseline和DFP-16的实验均在intel最新的Knights-Mill\nCPU上进行，DFP-16相比FP32训练加速1.8X。</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/55d321517c2de03fe92f7c32aff1d87a.png?raw=true'></p>\n<h3 id=\"abs_max量化方案\">ABS_MAX量化方案</h3>\n<h3 id=\"dfp与abs_max量化的区别\">DFP与ABS_MAX量化的区别</h3>\n","site":{"data":{}},"excerpt":"<h2 id=\"mixed-precision-training\">MIXED PRECISION TRAINING</h2>\n<p><a\nhref=\"https://email.baidu.com/OWA/redir.aspx?C=G_TpaBQZHjfotfty5PDuHfO3av_KUOGPcZOg_60U2vdUx9QS42vVCA..&amp;URL=https%3a%2f%2farxiv.org%2fpdf%2f1710.03740.pdf\">https://arxiv.org/pdf/1710.03740.pdf</a></p>\n<h3 id=\"论文概述\">论文概述</h3>\n<p>nvidia的Pascal和Volta系列显卡除了支持标准的单精度计算外，也支持了低精度的计算，比如最新的Tesla\nV100硬件支持了FP16的计算加速，P4和P40支持INT8的计算加速，而且低精度计算的峰值要远高于单精浮点的计算峰值。</p>","more":"<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/95247900845ca0aa285aea86b971c6ec.png?raw=true'></p>\n<p>为了加速训练过程以及减少显存开销，baidu\nResearch和nvidia在这篇论文中合作提出了一种FP16和FP32混合精度训练的方法，并且在CNN分类和检测、语音识别和语言模型任务上进行了验证，实验过程中使用的GPU就是Tesla\nV100。</p>\n<p>训练过程中每层的权重都存成FP32格式（Mater-Weights），每次训练时都会将FP32的权重降精度至FP16（\na master\ncopy），前向输出和后向梯度都使用FP16进行计算，更新时将FP16的梯度累加到FP32的Mater-Weight上。</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/b89a595f09deb2caf14d44176f931440.png?raw=true'></p>\n<h3 id=\"混合精度的必要性\">混合精度的必要性</h3>\n<p>由于FP16所能表示的subnormal最小正数是<span\nclass=\"math inline\">\\(2^{−24}\\)</span> ≈ <span\nclass=\"math inline\">\\(5.96 × 10^{−8}\\)</span>（<a\nhref=\"https://en.wikipedia.org/wiki/Half-precision_floating-point_format\">Half-precision\nfloating-point format</a>），也就是说在区间（<span\nclass=\"math inline\">\\(-2^{-24},\n2^{-24}\\)</span>）的数（或者说指数位小于-24的数）使用FP16表示时都会变成0。在一个普通话识别的模型训练中，有将近5%的权重梯度的指数位小于-24，如果更新时也用FP16计算，那么这些数在乘以学习率后都将变成0，从而对最终模型效果产生负面影响，使用混合精度训练的方式可以避免这种问题。</p>\n<h3 id=\"loss-scaling\">Loss scaling</h3>\n<p>混合精度训练可以解决权重更新量很小的问题，但无法解决梯度本身很小的问题。在一些网络中（比如SSD），梯度大部分都在FP16的表示范围之外，因此需要将梯度平移到FP16的表示范围内\n。</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/fc960bb10d950d111404cda831aa5cbe.png?raw=true'></p>\n<p>平移实际上就是对梯度值乘以一个系数（等于<span\nclass=\"math inline\">\\(2^{n}\\)</span>，<span\nclass=\"math inline\">\\(n\\)</span>为平移的位数），但另一种简单高效的方法是直接在前向时就将loss乘以scale，这样在后向传导时所有的梯度都会被乘以相同的scale。权重更新时需要将移位后的梯度除以scale后，再更新到权重上。</p>\n<p>论文中提到他们在实验过程中使用的scale是8~32K，最终取得了与FP32一致的收敛结果。对于scale的选择，论文没有统一的方法，只是提到scale并没有下界，只要选择的scale不会在后向计算时导致溢出就行。</p>\n<h3 id=\"实验结果\">实验结果</h3>\n<ul>\n<li><p>图像分类</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/a9166bfb03d36772c83f4aa56e591374.png?raw=true'></p></li>\n<li><p>物体检测</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/3dbc1922becd3b150d50bc71aacecb1e.png?raw=true'></p></li>\n<li><p>语音识别</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/0369372f891c65571c845b04960aafda.png?raw=true'></p></li>\n<li><p>机器翻译</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/237914e80a50fe0f2cac573c36733e5c.png?raw=true'></p></li>\n<li><p>语言模型</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/f1c1f41006c8f637c29208ac8652310b.png?raw=true'></p>\n<p>​</p></li>\n</ul>\n<h2\nid=\"mixed-precision-training-of-convolutional-neural-networks-using-integer-operations\">MIXED\nPRECISION TRAINING OF CONVOLUTIONAL NEURAL NETWORKS USING INTEGER\nOPERATIONS</h2>\n<p><a\nhref=\"https://email.baidu.com/OWA/redir.aspx?C=a0s4Pl45ENd9uqHgfl_L2eKY-IGy51CKRbN_JHdP0YhUx9QS42vVCA..&amp;URL=https%3a%2f%2fopenreview.net%2fforum%3fid%3dH135uzZ0-\">https://openreview.net/forum?id=H135uzZ0-</a></p>\n<h3 id=\"论文概述-1\">论文概述</h3>\n<p>半精度（16bit）分为半精度浮点（FP16）和半精度定点（INT16），FP16和INT16提供不同的精度和表示范围。INT16相比FP16的动态范围低，但精度更高，因此INT16相比FP16会带来更低的精度误差。</p>\n<p>现在深度学习领域公认的数据类型是单精度浮点（float），半精和单精除了在直观感觉上的数据类型不同之外，在计算（algorithmic）和语义（semantic）上也会有很多的不同，比如说FP16的乘加操作得到的结果是FP32。因此在讨论半精度训练时，对于整个tensor的表达、乘加操作、低精度转换、缩放和规整方法和溢出处理都是需要同时考虑的。</p>\n<p>intel的这篇论文主要受到之前flexpoint和混合精度训练的启发，从而提出了一种共享指数位的动态定点表达（dynamic\nfixed point\nrepresentation）方法，使用INT16和float混合精度训练，在完全不进行任何调参的情况下，在多个CNN的模型上取得了当前所有低精度训练方法中最好的效果。</p>\n<p>这篇论文主要涉及的技术点有：</p>\n<ul>\n<li>DFP：INT16的Tensor共享指数位，扩充INT16的动态表示范围。</li>\n<li>instruction：两个INT16进行乘法，结果存为INT32的指令。</li>\n<li>down-convert：基于最大值的低精度转换策略，使用nearest、stochastic和biased\nrounding三种不同的rounding方法。</li>\n<li>overflow\nmanagement：将局部的INT32结果累加到FP32，防止累加时溢出。</li>\n</ul>\n<h3 id=\"dfpdynamic-fixed-point\">DFP（Dynamic Fixed Point）</h3>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/f54c9019a7174299761d48094d1f0dab.png?raw=true'></p>\n<p>一个DFP\ntensor由一个定点的tensor和该tensor共享的指数组成，更通用的表示形式为DFP-P\n= <span class=\"math inline\">\\(&lt;I, E_{s}&gt;\\)</span>，P表示定点tensor\n<span class=\"math inline\">\\(I\\)</span>的位宽，<span\nclass=\"math inline\">\\(E_{s}\\)</span>表示共享指数位。标准单精使用的是8bit的指数位，在该论文中使用的DFP-16共享指数位也是8bit。</p>\n<ul>\n<li><p>DFP-16和fp32的数据转换</p>\n<p>共享指数位需要根据tensor中的绝对值最大的数和定点化的位宽来确定，计算公式如下：</p>\n<p><span class=\"math display\">\\[E_{s} = E_{fmax} - (P - 2)\\]</span></p>\n<p><span class=\"math inline\">\\(E_{s}\\)</span>表示DFP-P的共享指数，<span\nclass=\"math inline\">\\(E_{fmax}\\)</span>表示原始fp32\ntensor中绝对值最大的数对应的指数<span class=\"math inline\">\\(E_{fmax} =\nE(max_{\\forall f \\in F} |f|)\\)</span></p>\n<p>因此fp32的tensor与DFP的tensor有以下关系：</p>\n<p><span class=\"math display\">\\[\\forall i_{n} \\in I, \\ \\ \\ f_{n} = i_{n}\n\\times 2^{E_{s}}, \\ \\ \\ where f_{n} \\in F\\]</span></p>\n<p>也就是说<span class=\"math inline\">\\(i_{n} =\nrounding(\\frac{f_{n}}{2^{E_{s}}})\\)</span>，这本质上与loss\nscaling思想是一样的，用平移的思想来解决动态范围不够的问题。</p></li>\n<li><p>DFP-16 tensor的乘加运算规则</p>\n<p>1、两个DFP-16 tensor相乘，结果存为DFP-32。</p>\n<p><span class=\"math display\">\\[i_{ab} = i_{a} \\times i_{b} , \\ \\ \\\nE_{s}^{ab} = E_{s}^{a} + E_{s}^{b}\\]</span></p>\n<p>2、两个DFP-16 tensor相加，结果存为DFP-32。</p>\n<p><span class=\"math display\">\\[i_{ab} = \\left\\{\\begin{aligned} i_{a} +\n(i_{b} &gt;&gt; (E_{s}^{a} - E_{s}^{b})) \\ \\ \\ when E_{s}^{a} &gt;\nE_{s}^{b} \\\\ i_{b}+(i_{a} &gt;&gt; (E_{s}^{b}-E_{s}^{a})) \\ \\ \\ when\nE_{s}^{a} &lt; E_{s}^{b} \\end{aligned}\\right.\\]</span></p>\n<p><span class=\"math display\">\\[E_{s}^{a+b} = max(E_{s}^{a},\nE_{s}^{b})\\]</span></p>\n<p>3、两个DFP-32 tensor相加，结果保存为fp32。</p></li>\n<li><p>DFP-32和DFP-16的数据转换</p>\n<p><span class=\"math display\">\\[R_{s} = P - LZC(max_{\\forall i_{ab} \\in\nI^{32}}|i_{ab}|)\\]</span></p>\n<p><span class=\"math display\">\\[i_{ab}^{d} = i_{ab} &gt;&gt; R_{s} , \\ \\\n\\ E_{s}^{ab} += R_{s}\\]</span></p></li>\n</ul>\n<h3 id=\"dfp混合精度训练\">DFP混合精度训练</h3>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/9b304e74b8dbc9ec6324c56d05b85f24.png?raw=true'></p>\n<h3 id=\"指令实现\">指令实现</h3>\n<p>intel的VNNI指令集中有一条DFP-16乘加的指令QVNNI16，这条指令的第一个操作数是DFP-16内存指针，第二个操作数是4个512位的向量寄存器（每个寄存器可以存储32个DFP-16），结果是一个512位的向量寄存器（该寄存器能存储16个DFP-32）。</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/4a18c89da9676673a73c899987564e10.png?raw=true'></p>\n<p>上面的QVNNI16指令集实际上对mem输入做了两路并行展开，vinp2中一个寄存器支持同时对输入feature\nmap的两个channel进行计算。在论文中，卷积层输入的格式为（N，C/16，H，W，16），权重的格式为（C/16，K/16，KH，KW，8c，16k，2c），C表示输入feature\nmap的通道数，K表示输出通道数，KH和KW分别表示卷积核的height和width。</p>\n<p>卷积计算过程伪代码：</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/2f5405a955c03cd522b5b1f17e7300cd.png?raw=true'></p>\n<p>每次对输入的ICBLK个通道进行计算，ICBLK个通道又会分成（ICBLK/16）组，每组计算16个通道，由于QVNNI指令每次只能对输入的8个通道进行计算，因此每组调用2次QVNNI16指令，计算结果vout会转换成FP32后与output累加。</p>\n<h3 id=\"实验结果-1\">实验结果</h3>\n<p>baseline和DFP-16的实验均在intel最新的Knights-Mill\nCPU上进行，DFP-16相比FP32训练加速1.8X。</p>\n<p><img src='https://github.com/hjchen2/personal/blob/master/blog/mixed-precision/55d321517c2de03fe92f7c32aff1d87a.png?raw=true'></p>\n<h3 id=\"abs_max量化方案\">ABS_MAX量化方案</h3>\n<h3 id=\"dfp与abs_max量化的区别\">DFP与ABS_MAX量化的区别</h3>"},{"title":"强化学习（二）","date":"2017-04-25T04:31:08.000Z","_content":"\n## DQN\n\n前面我们讲到TD算法结合了动态规划和蒙特卡洛算法的优点，不依赖具体的环境模型，并且更新时采用滑动平均的方式，因此单步就能更新，而不需要生成整个episode，在非episode情况下仍然适用。TD算法又分为on policy的sarsa算法和off policy的Q learning算法，其中Q learning算法直接使用下一状态的最大动作值函数进行更新，加快了算法收敛速度，因此Q learning算法在实际应用中更加普遍。\n\n<!-- more -->\n\n\n### Q learning例子\n\n我们用一个例子来说明Q learning算法的过程。下图是一个二叉树表示的路径规划问题，每一个节点代表环境中的一个状态，叶子节点表示终止状态，每个非叶子节点都可以选择向上或向下的动作，然后转移到下一个节点，并获得相应的得分。\n\n</div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/9930b76dc4a4c37e188ea6363fe6603b.png?raw=true\" width=600></div>\n</br>\n首先初始化所有状态动作对的动作值函数：$Q(S_{i},a)=0, \\forall i\\in[1，6],a\\in[上，下]$，并且初始化$\\epsilon = 0.1，\\alpha = 0.1$。    \n\n- 随机选择一个初始状态$S$，假设为$S_0$   \n  根据$\\epsilon-greedy$策略选择一个动作，假设为上，转移到状态$S_1$，那么更新$Q(S_0,上)=Q(S_0,上)+\\alpha\\cdot(R_{1}+\\max_aQ(S_1,a)-Q(S_0,上))=0+0.1\\cdot(10+0-0)=1$，接下来继续根据$\\epsilon-greedy$策略选择下一个动作，比如下，并且转移到终止状态$S_4$，因此$Q(S_1,下)=Q(S_0,下)+\\alpha\\cdot(R_{2}+\\max_aQ(S_4,a)-Q(S_1,下))=0+0.1\\cdot(100+0-0)=10$。\n- 随机选择一个初始状态$S$，假设为$S_2$   \n  根据$\\epsilon-greedy$策略选择一个动作，假设为上，转移到终止状态$S_5$，则更新$Q(S_2,上)=0+0.1\\cdot（100+0-0）=10$\n- 随机选择一个初始状态$S$，假设为$S_0$   \n  根据$\\epsilon-greedy$策略选择一个动作，假设为上，转移到状态$S_1$，则更新$Q(S_0,上)=1+0.1\\cdot(10+10-1)=2.9$，选择下一个动作，比如上，则$Q(S_1,上)=0+0.1\\cdot(50+0-0)=5$\n- 随机选择一个初始状态$S$，假设为$S_0$  \n  根据$\\epsilon-greedy$策略选择一个动作，假设为上，转移到状态$S_1$，则更新$Q(S_0,上)=2.9+0.1\\cdot(10+10-2.9)=4.61$，选择下一个动作，比如下，则$Q(S_1,下)=10+0.1\\cdot(100+0-10)=19$\n- …   \n\n下面是该例子的python实现：\n\n```python\n\"\"\"\nauthor: Houjiang Chen\n\"\"\"\nimport random\n\nclass q_learning(object):\n    def __init__(self, states, actions):\n        self.states = states\n        self.actions = actions\n        self.eps = 0.1\n        self.alpha = 0.1\n        self.q_table = [[0 for j in range(actions)] for i in range(states)]\n\n    def get_action(self, current_state):\n        max_action = self.q_table[current_state].index(max(self.q_table[current_state]))\n        if random.uniform(0, 1) > self.eps:\n            return max_action\n        else:\n            rest = [i for i in range(len(self.q_table[current_state])) if i != max_action]\n            index = random.randint(0, len(rest) - 1)\n            return rest[index]\n\n    def update(self, current_state, action, next_state, reward, final):\n        if final != 1:\n            reward = reward + max(self.q_table[next_state])\n        self.q_table[current_state][action] += self.alpha * (reward - self.q_table[current_state][action])\n        \n        \nclass environment(object):\n    def __init__(self):\n        self.level = 2\n        self.actions = 2\n        self.states = self.actions ** (self.level + 1) - 1\n        self.final_states = self.actions ** self.level\n        self.reward = {0 : [10, -10], 1 : [50, 100], 2 : [100, 150]}\n\n    def next(self, current_state, action):\n        \"\"\"action: 0 or 1\n           return: next_state, reward, is_final\n        \"\"\"\n        next = 2 * current_state + (action + 1)\n        if next >= self.states - self.final_states:\n            return None, self.reward[current_state][action], 1\n        else:\n            return next, self.reward[current_state][action], 0\n\n    def reset(self):\n        return random.randint(0, self.states - self.final_states - 1)\n    \n\nenv = environment()\nagent = q_learning(env.states, env.actions)\n\nepisode = 0\nwhile episode < 100000:\n    episode += 1\n    print \"episode: %d\" % episode\n    current_state = env.reset()\n    while True:\n        action = agent.get_action(current_state)\n        next_state, reward, final = env.next(current_state, action)\n        agent.update(current_state, action, next_state, reward, final)\n        if final:\n            break\n        current_state = next_state\n\nprint agent.q_table\n \n```\n\n最终收敛结果为:\n\n```python\n[[109.99999999999989, 139.99999999999977], \n[49.99999999999997, 99.99999999999994], \n[99.99999999999994, 149.9999999999999], \n[0, 0], [0, 0], [0, 0], [0, 0]]\n```\n\n### 函数逼近\n\n上面的例子中非终止状态数只有3个，每个非终止状态对应的动作只有2个，因此状态动作对总共有6个，使用表格存储完全没有问题，但实际上我们需要解决的并不是一个如此简单的问题。比如在【Playing Atari with Deep Reinforcement Learning】中DeepMind就使用Q learning使得agent玩Atari 2600游戏的水平超越了人类水平。在Atari 2600游戏中，每个游戏画面都是一个状态，如果每个画面都是像素为84\\*84的256灰度图像，那么将会产生$256^{84\\cdot84}$个状态，用表格进行存储将会变得非常不现实。为了解决状态数爆炸的问题，通常可以使用函数逼近的方法。下面有几种函数表示的方式：\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/30EFF3D4-0562-4544-BFF9-D43B3EC7AFF7.png?raw=true\"></div>\n\n</br>\n\n并且逼近函数的形式可以采用：\n\n- Linear combinations of features\n- Neural network\n- Decision tree\n- Nearest neighbour\n- Fourier / wavelet bases\n- ...\n\n下面我们研究的DQN（Deep Q Network）就是采用Deep neural network进行动作值函数逼近的一种方法，结构如下。\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/8e238f9d9836b789276e0e58d4aa1e34.png?raw=true\" width=400></div>\n\n</br>\n\n为推导方便，假设中间的Network为一层的全连接，即$\\hat{V}(s, a)=x(S)^{T}w=\\sum_{j=1}^{n}{x_{j}(S)w_{j}}​$，代价函数选择最小均方误差：$J(w)=\\frac{1}{2}(V(s,a)-\\hat{V}(s,a))^2​$，采用随机梯度下降算法进行优化。\n\n$$\\begin{split}\\frac{\\partial{J(w)}}{\\partial{w}}&=\\left(V(s,a)-\\hat{V}(s,a)\\right)\\frac{\\partial{\\hat{V}(s,a)}} {\\partial{w}} \\\\ &=\\left(V(s,a)-\\hat{V}(s,a)\\right)x(S) \\end{split}\\tag{1-1}$$\n\n$$\\begin{split}w^k&=w^{k-1}+\\eta \\Delta(w)\\\\&=w^{k-1}-\\eta \\frac{\\partial{J(w)}}{\\partial{w}}\\\\&=w^{k-1}-\\eta \\left(V(s,a)-\\hat{V}(s,a;w^{k})\\right)x(S)\\end{split}\\tag{1-2}$$\n\n由于我们并没有动作值函数的真实值，因此与Q learning类似，$V(s,a,)$可以使用下一个状态的动作值函数进行估计，即$V(s,a)=V(s,a;w^{k-1})=r+\\gamma \\max_{a^{'}}V(s^{'},a^{'};w^{k-1})$。\n\n整个训练过程仍然与Q learning一样，采用$\\epsilon-greedy$策略选择动作，并按照公式(1-2)更新权重$w$，实际上也就更新了策略的动作值函数。使用值函数逼近的方法不需要枚举每个状态动作对，突破了状态数的限制，使得Q learning在一些复杂任务上得到广泛应用，但仍然没有解决动作数爆炸或者连续动作的问题。\n\n### DQN\nDQN最先出现于DeepMind发表的【Playing Atari with Deep Reinforcement Learning】论文中，由于需要直接输入图像画面，因此论文中使用CNN来表示Q函数，下面简单剖析一下该论文。\n\n使用的是典型的CNN，其结构为：\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/93F5C516-8E53-4F89-B03E-3EDD95DF1C76.png?raw=true\"></div>\n</br>\n与一般的CNN有所不同的是，没有pooling层，因为我们这里不是做图像分类，pooling层带来的旋转和数值不变性对分类是有作用的，但在这个任务中对物体的具体位置是非常敏感的，因此移除了pooling层。\n\nAtari原始的游戏帧为210\u0002\\*160像素的RGB图像，由于该任务对画面色彩不敏感，为了减少计算开销，将游戏帧预处理成84\\*84的灰度图像。但为了获得动态特征，最终是将前3帧图像与当前帧stack到一起组成一个4\\*84\\*84的图像作为CNN的输入，输出为每个动作对应的Q值。\n\n### 经验回放\n现在我们知道可以使用Q learning去估计每个状态的未来回报的期望，并且可以使用CNN去逼近动作值函数，也就是可以使用DQN去解决一个复杂的MDP任务。但在实际应用时会出现更新波动较大，导致收敛非常慢的问题，DeepMind因此使用了一个经验回放（Experience Replay）机制，就是将每步的经验数据$<s,a,r,s^{'}>$存放在回放内存中，更新时都从回放内存中随机采样一个batch的数据进行更新。\n\n经验回放机制相比标准的DQN有两个好处：首先每一步的经验数据会被保存起来，更新时可以多次使用到经验数据，使得数据利用更高效；此外直接从连续的样本中学习是低效的，因为一个episode内样本具有很强的相关性，随机挑选样本打破了这种相关性，因此减小了更新时的变化，使得更新更加稳定（注：因为同一次实验过程的样本相关性很强，不同实验之间的相关性就显得相对比较小，如果使用连续的样本进行训练，在切换到下一次实验的样本时会导致模型更新不稳定）。\n\n由于内存大小限制，回放内存不可能将所有的经验数据都保存起来，因此只会保留最新的N组经验数据，比较久远的数据就会被遗忘。\n\n\n### 训练\nDeepMind使用DQN对 ATARI中七个游戏进行了实验，由于每个游戏的得分尺度不一致，因此他们将得分分为正回报、负回报和无回报，正回报得分为1，负回报得分为-1，无回报得分为0。\n\n使用 RMSProp算法进行优化，batch size为32，采用$\\epsilon-greedy$行动策略，前一百万帧的$\\epsilon$从1线性减少到0.1，最后固定为0.1。总共训练了一千万帧，并且使用了一百万大小的回放内存。\n\n训练过程伪代码：\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/1E5C7D95-519A-4B54-BF09-C27A163D12C8.png?raw=true\" width=600></div>\n\n\n\n## Gym使用\n\n### Gym简介\n\n目前强化学习的研究主要由DeepMind和OpenAI两家在主导，去年底到今年初DeepMind和OpenAI相继开源了自家的3D learning environment平台DeepMind Lab和Universe。DeepMind Lab目前给出的文档和例子都比较少，使用也稍显复杂，所以暂时可以不考虑使用。Universe包含了1000+的游戏环境，并且将程序打包在docker环境中运行，提供与Gym一致的接口。Universe的环境由一个client和一个remote组成，client是一个VNCenv，主要负责接收agent的动作，传递回报和管理本地episode的状态，remote是指在docker环境中运行的程序，remote可以运行在本地、远程服务器或在cloud上。client和remote通过VNC远程桌面系统进行交互，通过WebSocket传递回报、诊断和控制信息。\n\n由于Universe环境提供Gym接口，而Gym是OpenAI去年4月份发布的一套开发和比较强化学习算法的toolkit。Gym本身是可以独立于Universe使用的，并且Universe和Gym中agent代码基本没有什么区别。我们下面就单独讲讲Gym接口和如何使用Gym训练自己的agent。\n\nGym目前提供python接口，并支持任何的计算框架，比如tensorflow、theano等。强化学习解决的是agent和环境交互的任务，agent根据当前环境状态做出某个动作，然后观察下一个状态和回报，环境根据agent的动作转移到下一个状态，并发送回报。Gym提供的实际上是环境这个角色，每个Gym环境都提供一致的接口。\n\n\n\n### 创建一个Gym环境\n\n创建一个环境时只需要指定环境id，比如agent需要玩Atari Breakout-v0这个游戏，可以如下创建一个Breakout-v0的环境。\n\n```python\nimport gym\nenv = gym.make('Breakout-v0')\n```\n\n### step \n\n输入agent的动作，返回4个值，分别为：\n\n- observation：表示agent观察到的下一个状态，比如在一些游戏中，observation为RGB的图像\n- reward：表示执行输入的动作后得到的回报值\n- done：表示返回的observation是不是结束状态\n- info：调试信息，一般没什么用处\n\n```python\nnext_state, reward, terminal, _ = env.step(action)\n```\n\n### reset\n\n在开始一个新的episode时，Gym环境都要reset，获得一个初始状态。\n\n```python\ninit_state = env.reset()\n```\n\n### render\n\nrender是Gym用来渲染环境状态的函数，当调用该函数时会出现一个动图框。一般agent执行一个动作，环境都要渲染一次，这样就可以实时看到agent的执行情况了。\n\n```python\nenv.render()\n```\n\n### Spaces\n\nGym环境有两个space属性，一个是action_space，一个是observation_space，分别表示该Gym环境下合法的动作和状态。action_space是Gym中的一个Discrete对象，Discrete对象有一个成员n，表示合法的动作数，比如Discrete(2)表示有两个合法动作，编号从0开始，因此两个动作编号为0和1。observation_space是Gym中的一个Box对象，Box的shape表示observation的数据组织方式，比如Box(210, 160, 3)表示合法的observation是一个210\\*160\\*3的数组，而Box(4,)表示observation是一个大小为4的向量。\n\n```python\nobservation_space = env.observation_space # observation_space: Discrete(6)\naction_space = env.action_space # action_space: Box(210, 160, 3)\n```\n\n\n\n### Breakout-v0例子\n\n采用了github上Flood Sung的DQN实现，感谢Flood Sung大神的无私贡献。\n\n```python\n# -----------------------------\n# File: Deep Q-Learning Algorithm\n# Author: Flood Sung\n# Date: 2016.3.21\n# -----------------------------\n\nimport tensorflow as tf\nimport numpy as np\nimport random\nfrom collections import deque\n\n# Hyper Parameters:\nFRAME_PER_ACTION = 1\nGAMMA = 0.99 # decay rate of past observations\nOBSERVE = 100. # timesteps to observe before training\nEXPLORE = 200000. # frames over which to anneal epsilon\nFINAL_EPSILON = 0#0.001 # final value of epsilon\nINITIAL_EPSILON = 0#0.01 # starting value of epsilon\nREPLAY_MEMORY = 50000 # number of previous transitions to remember\nBATCH_SIZE = 32 # size of minibatch\nUPDATE_TIME = 100\n\nclass BrainDQN:\n\tdef __init__(self,actions):\n\t\t# init replay memory\n\t\tself.replayMemory = deque()\n\t\t# init some parameters\n\t\tself.timeStep = 0\n\t\tself.epsilon = INITIAL_EPSILON\n\t\tself.actions = actions\n\t\t# init Q network\n\t\tself.stateInput,self.QValue,self.W_conv1,self.b_conv1,self.W_conv2,self.b_conv2,self.W_conv3,self.b_conv3,self.W_fc1,self.b_fc1,self.W_fc2,self.b_fc2 = self.createQNetwork()\n\n\t\t# init Target Q Network\n\t\tself.stateInputT,self.QValueT,self.W_conv1T,self.b_conv1T,self.W_conv2T,self.b_conv2T,self.W_conv3T,self.b_conv3T,self.W_fc1T,self.b_fc1T,self.W_fc2T,self.b_fc2T = self.createQNetwork()\n\n\t\tself.copyTargetQNetworkOperation = [self.W_conv1T.assign(self.W_conv1),self.b_conv1T.assign(self.b_conv1),self.W_conv2T.assign(self.W_conv2),self.b_conv2T.assign(self.b_conv2),self.W_conv3T.assign(self.W_conv3),self.b_conv3T.assign(self.b_conv3),self.W_fc1T.assign(self.W_fc1),self.b_fc1T.assign(self.b_fc1),self.W_fc2T.assign(self.W_fc2),self.b_fc2T.assign(self.b_fc2)]\n\n\t\tself.createTrainingMethod()\n\n\t\t# saving and loading networks\n\t\tself.saver = tf.train.Saver()\n\t\tself.session = tf.InteractiveSession()\n\t\tself.session.run(tf.initialize_all_variables())\n\t\tcheckpoint = tf.train.get_checkpoint_state(\"saved_networks\")\n\t\tif checkpoint and checkpoint.model_checkpoint_path:\n\t\t\t\tself.saver.restore(self.session, checkpoint.model_checkpoint_path)\n\t\t\t\tprint \"Successfully loaded:\", checkpoint.model_checkpoint_path\n\t\telse:\n\t\t\t\tprint \"Could not find old network weights\"\n\n\n\tdef createQNetwork(self):\n\t\t# network weights\n\t\tW_conv1 = self.weight_variable([8,8,4,32])\n\t\tb_conv1 = self.bias_variable([32])\n\n\t\tW_conv2 = self.weight_variable([4,4,32,64])\n\t\tb_conv2 = self.bias_variable([64])\n\n\t\tW_conv3 = self.weight_variable([3,3,64,64])\n\t\tb_conv3 = self.bias_variable([64])\n\n\t\tW_fc1 = self.weight_variable([1600,512])\n\t\tb_fc1 = self.bias_variable([512])\n\n\t\tW_fc2 = self.weight_variable([512,self.actions])\n\t\tb_fc2 = self.bias_variable([self.actions])\n\n\t\t# input layer\n\n\t\tstateInput = tf.placeholder(\"float\",[None,80,80,4])\n\n\t\t# hidden layers\n\t\th_conv1 = tf.nn.relu(self.conv2d(stateInput,W_conv1,4) + b_conv1)\n\t\th_pool1 = self.max_pool_2x2(h_conv1)\n\n\t\th_conv2 = tf.nn.relu(self.conv2d(h_pool1,W_conv2,2) + b_conv2)\n\n\t\th_conv3 = tf.nn.relu(self.conv2d(h_conv2,W_conv3,1) + b_conv3)\n\n\t\th_conv3_flat = tf.reshape(h_conv3,[-1,1600])\n\t\th_fc1 = tf.nn.relu(tf.matmul(h_conv3_flat,W_fc1) + b_fc1)\n\n\t\t# Q Value layer\n\t\tQValue = tf.matmul(h_fc1,W_fc2) + b_fc2\n\n\t\treturn stateInput,QValue,W_conv1,b_conv1,W_conv2,b_conv2,W_conv3,b_conv3,W_fc1,b_fc1,W_fc2,b_fc2\n\n\tdef copyTargetQNetwork(self):\n\t\tself.session.run(self.copyTargetQNetworkOperation)\n\n\tdef createTrainingMethod(self):\n\t\tself.actionInput = tf.placeholder(\"float\",[None,self.actions])\n\t\tself.yInput = tf.placeholder(\"float\", [None])\n\t\tQ_Action = tf.reduce_sum(tf.mul(self.QValue, self.actionInput), reduction_indices = 1)\n\t\tself.cost = tf.reduce_mean(tf.square(self.yInput - Q_Action))\n\t\tself.trainStep = tf.train.AdamOptimizer(1e-6).minimize(self.cost)\n\n\n\tdef trainQNetwork(self):\n\t\t# Step 1: obtain random minibatch from replay memory\n\t\tminibatch = random.sample(self.replayMemory,BATCH_SIZE)\n\t\tstate_batch = [data[0] for data in minibatch]\n\t\taction_batch = [data[1] for data in minibatch]\n\t\treward_batch = [data[2] for data in minibatch]\n\t\tnextState_batch = [data[3] for data in minibatch]\n\n\t\t# Step 2: calculate y\n\t\ty_batch = []\n\t\tQValue_batch = self.QValueT.eval(feed_dict={self.stateInputT:nextState_batch})\n\t\tfor i in range(0,BATCH_SIZE):\n\t\t\tterminal = minibatch[i][4]\n\t\t\tif terminal:\n\t\t\t\ty_batch.append(reward_batch[i])\n\t\t\telse:\n\t\t\t\ty_batch.append(reward_batch[i] + GAMMA * np.max(QValue_batch[i]))\n\n\t\tself.trainStep.run(feed_dict={\n\t\t\tself.yInput : y_batch,\n\t\t\tself.actionInput : action_batch,\n\t\t\tself.stateInput : state_batch\n\t\t\t})\n\n\t\t# save network every 100000 iteration\n\t\tif self.timeStep % 10000 == 0:\n\t\t\tself.saver.save(self.session, 'saved_networks/' + 'network' + '-dqn', global_step = self.timeStep)\n\n\t\tif self.timeStep % UPDATE_TIME == 0:\n\t\t\tself.copyTargetQNetwork()\n\n\n\tdef setPerception(self,nextObservation,action,reward,terminal):\n\t\t#newState = np.append(nextObservation,self.currentState[:,:,1:],axis = 2)\n\t\tnewState = np.append(self.currentState[:,:,1:],nextObservation,axis = 2)\n\t\tself.replayMemory.append((self.currentState,action,reward,newState,terminal))\n\t\tif len(self.replayMemory) > REPLAY_MEMORY:\n\t\t\tself.replayMemory.popleft()\n\t\tif self.timeStep > OBSERVE:\n\t\t\t# Train the network\n\t\t\tself.trainQNetwork()\n\n\t\t# print info\n\t\tstate = \"\"\n\t\tif self.timeStep <= OBSERVE:\n\t\t\tstate = \"observe\"\n\t\telif self.timeStep > OBSERVE and self.timeStep <= OBSERVE + EXPLORE:\n\t\t\tstate = \"explore\"\n\t\telse:\n\t\t\tstate = \"train\"\n\n\t\tprint \"TIMESTEP\", self.timeStep, \"/ STATE\", state, \\\n            \"/ EPSILON\", self.epsilon\n\n\t\tself.currentState = newState\n\t\tself.timeStep += 1\n\n\tdef getAction(self):\n\t\tQValue = self.QValue.eval(feed_dict= {self.stateInput:[self.currentState]})[0]\n\t\taction = np.zeros(self.actions)\n\t\taction_index = 0\n\t\tif self.timeStep % FRAME_PER_ACTION == 0:\n\t\t\tif random.random() <= self.epsilon:\n\t\t\t\taction_index = random.randrange(self.actions)\n\t\t\t\taction[action_index] = 1\n\t\t\telse:\n\t\t\t\taction_index = np.argmax(QValue)\n\t\t\t\taction[action_index] = 1\n\t\telse:\n\t\t\taction[0] = 1 # do nothing\n\n\t\t# change episilon\n\t\tif self.epsilon > FINAL_EPSILON and self.timeStep > OBSERVE:\n\t\t\tself.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON)/EXPLORE\n\n\t\treturn action\n\n\tdef setInitState(self,observation):\n\t\tself.currentState = np.stack((observation, observation, observation, observation), axis = 2)\n\n\tdef weight_variable(self,shape):\n\t\tinitial = tf.truncated_normal(shape, stddev = 0.01)\n\t\treturn tf.Variable(initial)\n\n\tdef bias_variable(self,shape):\n\t\tinitial = tf.constant(0.01, shape = shape)\n\t\treturn tf.Variable(initial)\n\n\tdef conv2d(self,x, W, stride):\n\t\treturn tf.nn.conv2d(x, W, strides = [1, stride, stride, 1], padding = \"SAME\")\n\n\tdef max_pool_2x2(self,x):\n\t\treturn tf.nn.max_pool(x, ksize = [1, 2, 2, 1], strides = [1, 2, 2, 1], padding = \"SAME\")\n```\n\n\n\n下面是使用上面的DQN让agent玩Gym的Breakout-v0游戏。\n\n```python\n# -------------------------\n# Project: Deep Q-Learning on Breakout-v0\n# Author: Houjiang Chen\n# Date: 2017.4.25\n# -------------------------\n\nimport cv2\nimport gym\nfrom BrainDQN_Nature import BrainDQN\nimport numpy as np\n\n# preprocess raw image to 80*80 gray image\ndef preprocess(observation):\n    observation = cv2.cvtColor(cv2.resize(observation, (80, 80)), cv2.COLOR_BGR2GRAY)\n    #ret, observation = cv2.threshold(observation, 1, 255, cv2.THRESH_BINARY)\n    return np.reshape(observation, (80, 80, 1))\n\ndef play():\n    env = gym.make('Breakout-v0')\n    actions = env.action_space.n\n\n    # init BrainDQN\n    brain = BrainDQN(actions)\n\n    while 1:\n        state = env.reset()\n        state = cv2.cvtColor(cv2.resize(state, (80, 80)), cv2.COLOR_BGR2GRAY)\n        #ret, state = cv2.threshold(state, 1, 255, cv2.THRESH_BINARY)\n        brain.setInitState(state)\n        while 1:\n            action = brain.getAction()\n            state, reward, terminal, _ = env.step(np.argmax(action))\n            env.render()\n            if terminal:\n                break\n            state = preprocess(state)\n            brain.setPerception(state, action, reward, terminal)\n\n\ndef main():\n    play()\n\nif __name__ == '__main__':\n    main()\n```\n\n\n\n## 参考资料\n1、Reinforcement Learning: An Introduction, Richard S. Sutton and Andrew G. Barto，2012   \n2、Playing Atari with Deep Reinforcement Learning，DeepMind Technologies，Arxiv 2013.12   \n3、Human-level control through deep reinforcement learning，DeepMind Technologies，Nature 2015.02   \n4、DeepMind官网 https://deepmind.com/blog/deep-reinforcement-learning   \n5、https://www.nervanasys.com/demystifying-deep-reinforcement-learning   \n6、http://www.cnblogs.com/jinxulin/p/3511298.html   \n7、Introduction to Reinforcement Learning，David Silver   \n","source":"_posts/强化学习（二）.md","raw":"---\ntitle: 强化学习（二）\ndate: 2017-04-25 12:31:08\ncategory: reinforcement learning\ntags: [reinforcement learning, machine learning]\n---\n\n## DQN\n\n前面我们讲到TD算法结合了动态规划和蒙特卡洛算法的优点，不依赖具体的环境模型，并且更新时采用滑动平均的方式，因此单步就能更新，而不需要生成整个episode，在非episode情况下仍然适用。TD算法又分为on policy的sarsa算法和off policy的Q learning算法，其中Q learning算法直接使用下一状态的最大动作值函数进行更新，加快了算法收敛速度，因此Q learning算法在实际应用中更加普遍。\n\n<!-- more -->\n\n\n### Q learning例子\n\n我们用一个例子来说明Q learning算法的过程。下图是一个二叉树表示的路径规划问题，每一个节点代表环境中的一个状态，叶子节点表示终止状态，每个非叶子节点都可以选择向上或向下的动作，然后转移到下一个节点，并获得相应的得分。\n\n</div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/9930b76dc4a4c37e188ea6363fe6603b.png?raw=true\" width=600></div>\n</br>\n首先初始化所有状态动作对的动作值函数：$Q(S_{i},a)=0, \\forall i\\in[1，6],a\\in[上，下]$，并且初始化$\\epsilon = 0.1，\\alpha = 0.1$。    \n\n- 随机选择一个初始状态$S$，假设为$S_0$   \n  根据$\\epsilon-greedy$策略选择一个动作，假设为上，转移到状态$S_1$，那么更新$Q(S_0,上)=Q(S_0,上)+\\alpha\\cdot(R_{1}+\\max_aQ(S_1,a)-Q(S_0,上))=0+0.1\\cdot(10+0-0)=1$，接下来继续根据$\\epsilon-greedy$策略选择下一个动作，比如下，并且转移到终止状态$S_4$，因此$Q(S_1,下)=Q(S_0,下)+\\alpha\\cdot(R_{2}+\\max_aQ(S_4,a)-Q(S_1,下))=0+0.1\\cdot(100+0-0)=10$。\n- 随机选择一个初始状态$S$，假设为$S_2$   \n  根据$\\epsilon-greedy$策略选择一个动作，假设为上，转移到终止状态$S_5$，则更新$Q(S_2,上)=0+0.1\\cdot（100+0-0）=10$\n- 随机选择一个初始状态$S$，假设为$S_0$   \n  根据$\\epsilon-greedy$策略选择一个动作，假设为上，转移到状态$S_1$，则更新$Q(S_0,上)=1+0.1\\cdot(10+10-1)=2.9$，选择下一个动作，比如上，则$Q(S_1,上)=0+0.1\\cdot(50+0-0)=5$\n- 随机选择一个初始状态$S$，假设为$S_0$  \n  根据$\\epsilon-greedy$策略选择一个动作，假设为上，转移到状态$S_1$，则更新$Q(S_0,上)=2.9+0.1\\cdot(10+10-2.9)=4.61$，选择下一个动作，比如下，则$Q(S_1,下)=10+0.1\\cdot(100+0-10)=19$\n- …   \n\n下面是该例子的python实现：\n\n```python\n\"\"\"\nauthor: Houjiang Chen\n\"\"\"\nimport random\n\nclass q_learning(object):\n    def __init__(self, states, actions):\n        self.states = states\n        self.actions = actions\n        self.eps = 0.1\n        self.alpha = 0.1\n        self.q_table = [[0 for j in range(actions)] for i in range(states)]\n\n    def get_action(self, current_state):\n        max_action = self.q_table[current_state].index(max(self.q_table[current_state]))\n        if random.uniform(0, 1) > self.eps:\n            return max_action\n        else:\n            rest = [i for i in range(len(self.q_table[current_state])) if i != max_action]\n            index = random.randint(0, len(rest) - 1)\n            return rest[index]\n\n    def update(self, current_state, action, next_state, reward, final):\n        if final != 1:\n            reward = reward + max(self.q_table[next_state])\n        self.q_table[current_state][action] += self.alpha * (reward - self.q_table[current_state][action])\n        \n        \nclass environment(object):\n    def __init__(self):\n        self.level = 2\n        self.actions = 2\n        self.states = self.actions ** (self.level + 1) - 1\n        self.final_states = self.actions ** self.level\n        self.reward = {0 : [10, -10], 1 : [50, 100], 2 : [100, 150]}\n\n    def next(self, current_state, action):\n        \"\"\"action: 0 or 1\n           return: next_state, reward, is_final\n        \"\"\"\n        next = 2 * current_state + (action + 1)\n        if next >= self.states - self.final_states:\n            return None, self.reward[current_state][action], 1\n        else:\n            return next, self.reward[current_state][action], 0\n\n    def reset(self):\n        return random.randint(0, self.states - self.final_states - 1)\n    \n\nenv = environment()\nagent = q_learning(env.states, env.actions)\n\nepisode = 0\nwhile episode < 100000:\n    episode += 1\n    print \"episode: %d\" % episode\n    current_state = env.reset()\n    while True:\n        action = agent.get_action(current_state)\n        next_state, reward, final = env.next(current_state, action)\n        agent.update(current_state, action, next_state, reward, final)\n        if final:\n            break\n        current_state = next_state\n\nprint agent.q_table\n \n```\n\n最终收敛结果为:\n\n```python\n[[109.99999999999989, 139.99999999999977], \n[49.99999999999997, 99.99999999999994], \n[99.99999999999994, 149.9999999999999], \n[0, 0], [0, 0], [0, 0], [0, 0]]\n```\n\n### 函数逼近\n\n上面的例子中非终止状态数只有3个，每个非终止状态对应的动作只有2个，因此状态动作对总共有6个，使用表格存储完全没有问题，但实际上我们需要解决的并不是一个如此简单的问题。比如在【Playing Atari with Deep Reinforcement Learning】中DeepMind就使用Q learning使得agent玩Atari 2600游戏的水平超越了人类水平。在Atari 2600游戏中，每个游戏画面都是一个状态，如果每个画面都是像素为84\\*84的256灰度图像，那么将会产生$256^{84\\cdot84}$个状态，用表格进行存储将会变得非常不现实。为了解决状态数爆炸的问题，通常可以使用函数逼近的方法。下面有几种函数表示的方式：\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/30EFF3D4-0562-4544-BFF9-D43B3EC7AFF7.png?raw=true\"></div>\n\n</br>\n\n并且逼近函数的形式可以采用：\n\n- Linear combinations of features\n- Neural network\n- Decision tree\n- Nearest neighbour\n- Fourier / wavelet bases\n- ...\n\n下面我们研究的DQN（Deep Q Network）就是采用Deep neural network进行动作值函数逼近的一种方法，结构如下。\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/8e238f9d9836b789276e0e58d4aa1e34.png?raw=true\" width=400></div>\n\n</br>\n\n为推导方便，假设中间的Network为一层的全连接，即$\\hat{V}(s, a)=x(S)^{T}w=\\sum_{j=1}^{n}{x_{j}(S)w_{j}}​$，代价函数选择最小均方误差：$J(w)=\\frac{1}{2}(V(s,a)-\\hat{V}(s,a))^2​$，采用随机梯度下降算法进行优化。\n\n$$\\begin{split}\\frac{\\partial{J(w)}}{\\partial{w}}&=\\left(V(s,a)-\\hat{V}(s,a)\\right)\\frac{\\partial{\\hat{V}(s,a)}} {\\partial{w}} \\\\ &=\\left(V(s,a)-\\hat{V}(s,a)\\right)x(S) \\end{split}\\tag{1-1}$$\n\n$$\\begin{split}w^k&=w^{k-1}+\\eta \\Delta(w)\\\\&=w^{k-1}-\\eta \\frac{\\partial{J(w)}}{\\partial{w}}\\\\&=w^{k-1}-\\eta \\left(V(s,a)-\\hat{V}(s,a;w^{k})\\right)x(S)\\end{split}\\tag{1-2}$$\n\n由于我们并没有动作值函数的真实值，因此与Q learning类似，$V(s,a,)$可以使用下一个状态的动作值函数进行估计，即$V(s,a)=V(s,a;w^{k-1})=r+\\gamma \\max_{a^{'}}V(s^{'},a^{'};w^{k-1})$。\n\n整个训练过程仍然与Q learning一样，采用$\\epsilon-greedy$策略选择动作，并按照公式(1-2)更新权重$w$，实际上也就更新了策略的动作值函数。使用值函数逼近的方法不需要枚举每个状态动作对，突破了状态数的限制，使得Q learning在一些复杂任务上得到广泛应用，但仍然没有解决动作数爆炸或者连续动作的问题。\n\n### DQN\nDQN最先出现于DeepMind发表的【Playing Atari with Deep Reinforcement Learning】论文中，由于需要直接输入图像画面，因此论文中使用CNN来表示Q函数，下面简单剖析一下该论文。\n\n使用的是典型的CNN，其结构为：\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/93F5C516-8E53-4F89-B03E-3EDD95DF1C76.png?raw=true\"></div>\n</br>\n与一般的CNN有所不同的是，没有pooling层，因为我们这里不是做图像分类，pooling层带来的旋转和数值不变性对分类是有作用的，但在这个任务中对物体的具体位置是非常敏感的，因此移除了pooling层。\n\nAtari原始的游戏帧为210\u0002\\*160像素的RGB图像，由于该任务对画面色彩不敏感，为了减少计算开销，将游戏帧预处理成84\\*84的灰度图像。但为了获得动态特征，最终是将前3帧图像与当前帧stack到一起组成一个4\\*84\\*84的图像作为CNN的输入，输出为每个动作对应的Q值。\n\n### 经验回放\n现在我们知道可以使用Q learning去估计每个状态的未来回报的期望，并且可以使用CNN去逼近动作值函数，也就是可以使用DQN去解决一个复杂的MDP任务。但在实际应用时会出现更新波动较大，导致收敛非常慢的问题，DeepMind因此使用了一个经验回放（Experience Replay）机制，就是将每步的经验数据$<s,a,r,s^{'}>$存放在回放内存中，更新时都从回放内存中随机采样一个batch的数据进行更新。\n\n经验回放机制相比标准的DQN有两个好处：首先每一步的经验数据会被保存起来，更新时可以多次使用到经验数据，使得数据利用更高效；此外直接从连续的样本中学习是低效的，因为一个episode内样本具有很强的相关性，随机挑选样本打破了这种相关性，因此减小了更新时的变化，使得更新更加稳定（注：因为同一次实验过程的样本相关性很强，不同实验之间的相关性就显得相对比较小，如果使用连续的样本进行训练，在切换到下一次实验的样本时会导致模型更新不稳定）。\n\n由于内存大小限制，回放内存不可能将所有的经验数据都保存起来，因此只会保留最新的N组经验数据，比较久远的数据就会被遗忘。\n\n\n### 训练\nDeepMind使用DQN对 ATARI中七个游戏进行了实验，由于每个游戏的得分尺度不一致，因此他们将得分分为正回报、负回报和无回报，正回报得分为1，负回报得分为-1，无回报得分为0。\n\n使用 RMSProp算法进行优化，batch size为32，采用$\\epsilon-greedy$行动策略，前一百万帧的$\\epsilon$从1线性减少到0.1，最后固定为0.1。总共训练了一千万帧，并且使用了一百万大小的回放内存。\n\n训练过程伪代码：\n\n<div align='center'><img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/1E5C7D95-519A-4B54-BF09-C27A163D12C8.png?raw=true\" width=600></div>\n\n\n\n## Gym使用\n\n### Gym简介\n\n目前强化学习的研究主要由DeepMind和OpenAI两家在主导，去年底到今年初DeepMind和OpenAI相继开源了自家的3D learning environment平台DeepMind Lab和Universe。DeepMind Lab目前给出的文档和例子都比较少，使用也稍显复杂，所以暂时可以不考虑使用。Universe包含了1000+的游戏环境，并且将程序打包在docker环境中运行，提供与Gym一致的接口。Universe的环境由一个client和一个remote组成，client是一个VNCenv，主要负责接收agent的动作，传递回报和管理本地episode的状态，remote是指在docker环境中运行的程序，remote可以运行在本地、远程服务器或在cloud上。client和remote通过VNC远程桌面系统进行交互，通过WebSocket传递回报、诊断和控制信息。\n\n由于Universe环境提供Gym接口，而Gym是OpenAI去年4月份发布的一套开发和比较强化学习算法的toolkit。Gym本身是可以独立于Universe使用的，并且Universe和Gym中agent代码基本没有什么区别。我们下面就单独讲讲Gym接口和如何使用Gym训练自己的agent。\n\nGym目前提供python接口，并支持任何的计算框架，比如tensorflow、theano等。强化学习解决的是agent和环境交互的任务，agent根据当前环境状态做出某个动作，然后观察下一个状态和回报，环境根据agent的动作转移到下一个状态，并发送回报。Gym提供的实际上是环境这个角色，每个Gym环境都提供一致的接口。\n\n\n\n### 创建一个Gym环境\n\n创建一个环境时只需要指定环境id，比如agent需要玩Atari Breakout-v0这个游戏，可以如下创建一个Breakout-v0的环境。\n\n```python\nimport gym\nenv = gym.make('Breakout-v0')\n```\n\n### step \n\n输入agent的动作，返回4个值，分别为：\n\n- observation：表示agent观察到的下一个状态，比如在一些游戏中，observation为RGB的图像\n- reward：表示执行输入的动作后得到的回报值\n- done：表示返回的observation是不是结束状态\n- info：调试信息，一般没什么用处\n\n```python\nnext_state, reward, terminal, _ = env.step(action)\n```\n\n### reset\n\n在开始一个新的episode时，Gym环境都要reset，获得一个初始状态。\n\n```python\ninit_state = env.reset()\n```\n\n### render\n\nrender是Gym用来渲染环境状态的函数，当调用该函数时会出现一个动图框。一般agent执行一个动作，环境都要渲染一次，这样就可以实时看到agent的执行情况了。\n\n```python\nenv.render()\n```\n\n### Spaces\n\nGym环境有两个space属性，一个是action_space，一个是observation_space，分别表示该Gym环境下合法的动作和状态。action_space是Gym中的一个Discrete对象，Discrete对象有一个成员n，表示合法的动作数，比如Discrete(2)表示有两个合法动作，编号从0开始，因此两个动作编号为0和1。observation_space是Gym中的一个Box对象，Box的shape表示observation的数据组织方式，比如Box(210, 160, 3)表示合法的observation是一个210\\*160\\*3的数组，而Box(4,)表示observation是一个大小为4的向量。\n\n```python\nobservation_space = env.observation_space # observation_space: Discrete(6)\naction_space = env.action_space # action_space: Box(210, 160, 3)\n```\n\n\n\n### Breakout-v0例子\n\n采用了github上Flood Sung的DQN实现，感谢Flood Sung大神的无私贡献。\n\n```python\n# -----------------------------\n# File: Deep Q-Learning Algorithm\n# Author: Flood Sung\n# Date: 2016.3.21\n# -----------------------------\n\nimport tensorflow as tf\nimport numpy as np\nimport random\nfrom collections import deque\n\n# Hyper Parameters:\nFRAME_PER_ACTION = 1\nGAMMA = 0.99 # decay rate of past observations\nOBSERVE = 100. # timesteps to observe before training\nEXPLORE = 200000. # frames over which to anneal epsilon\nFINAL_EPSILON = 0#0.001 # final value of epsilon\nINITIAL_EPSILON = 0#0.01 # starting value of epsilon\nREPLAY_MEMORY = 50000 # number of previous transitions to remember\nBATCH_SIZE = 32 # size of minibatch\nUPDATE_TIME = 100\n\nclass BrainDQN:\n\tdef __init__(self,actions):\n\t\t# init replay memory\n\t\tself.replayMemory = deque()\n\t\t# init some parameters\n\t\tself.timeStep = 0\n\t\tself.epsilon = INITIAL_EPSILON\n\t\tself.actions = actions\n\t\t# init Q network\n\t\tself.stateInput,self.QValue,self.W_conv1,self.b_conv1,self.W_conv2,self.b_conv2,self.W_conv3,self.b_conv3,self.W_fc1,self.b_fc1,self.W_fc2,self.b_fc2 = self.createQNetwork()\n\n\t\t# init Target Q Network\n\t\tself.stateInputT,self.QValueT,self.W_conv1T,self.b_conv1T,self.W_conv2T,self.b_conv2T,self.W_conv3T,self.b_conv3T,self.W_fc1T,self.b_fc1T,self.W_fc2T,self.b_fc2T = self.createQNetwork()\n\n\t\tself.copyTargetQNetworkOperation = [self.W_conv1T.assign(self.W_conv1),self.b_conv1T.assign(self.b_conv1),self.W_conv2T.assign(self.W_conv2),self.b_conv2T.assign(self.b_conv2),self.W_conv3T.assign(self.W_conv3),self.b_conv3T.assign(self.b_conv3),self.W_fc1T.assign(self.W_fc1),self.b_fc1T.assign(self.b_fc1),self.W_fc2T.assign(self.W_fc2),self.b_fc2T.assign(self.b_fc2)]\n\n\t\tself.createTrainingMethod()\n\n\t\t# saving and loading networks\n\t\tself.saver = tf.train.Saver()\n\t\tself.session = tf.InteractiveSession()\n\t\tself.session.run(tf.initialize_all_variables())\n\t\tcheckpoint = tf.train.get_checkpoint_state(\"saved_networks\")\n\t\tif checkpoint and checkpoint.model_checkpoint_path:\n\t\t\t\tself.saver.restore(self.session, checkpoint.model_checkpoint_path)\n\t\t\t\tprint \"Successfully loaded:\", checkpoint.model_checkpoint_path\n\t\telse:\n\t\t\t\tprint \"Could not find old network weights\"\n\n\n\tdef createQNetwork(self):\n\t\t# network weights\n\t\tW_conv1 = self.weight_variable([8,8,4,32])\n\t\tb_conv1 = self.bias_variable([32])\n\n\t\tW_conv2 = self.weight_variable([4,4,32,64])\n\t\tb_conv2 = self.bias_variable([64])\n\n\t\tW_conv3 = self.weight_variable([3,3,64,64])\n\t\tb_conv3 = self.bias_variable([64])\n\n\t\tW_fc1 = self.weight_variable([1600,512])\n\t\tb_fc1 = self.bias_variable([512])\n\n\t\tW_fc2 = self.weight_variable([512,self.actions])\n\t\tb_fc2 = self.bias_variable([self.actions])\n\n\t\t# input layer\n\n\t\tstateInput = tf.placeholder(\"float\",[None,80,80,4])\n\n\t\t# hidden layers\n\t\th_conv1 = tf.nn.relu(self.conv2d(stateInput,W_conv1,4) + b_conv1)\n\t\th_pool1 = self.max_pool_2x2(h_conv1)\n\n\t\th_conv2 = tf.nn.relu(self.conv2d(h_pool1,W_conv2,2) + b_conv2)\n\n\t\th_conv3 = tf.nn.relu(self.conv2d(h_conv2,W_conv3,1) + b_conv3)\n\n\t\th_conv3_flat = tf.reshape(h_conv3,[-1,1600])\n\t\th_fc1 = tf.nn.relu(tf.matmul(h_conv3_flat,W_fc1) + b_fc1)\n\n\t\t# Q Value layer\n\t\tQValue = tf.matmul(h_fc1,W_fc2) + b_fc2\n\n\t\treturn stateInput,QValue,W_conv1,b_conv1,W_conv2,b_conv2,W_conv3,b_conv3,W_fc1,b_fc1,W_fc2,b_fc2\n\n\tdef copyTargetQNetwork(self):\n\t\tself.session.run(self.copyTargetQNetworkOperation)\n\n\tdef createTrainingMethod(self):\n\t\tself.actionInput = tf.placeholder(\"float\",[None,self.actions])\n\t\tself.yInput = tf.placeholder(\"float\", [None])\n\t\tQ_Action = tf.reduce_sum(tf.mul(self.QValue, self.actionInput), reduction_indices = 1)\n\t\tself.cost = tf.reduce_mean(tf.square(self.yInput - Q_Action))\n\t\tself.trainStep = tf.train.AdamOptimizer(1e-6).minimize(self.cost)\n\n\n\tdef trainQNetwork(self):\n\t\t# Step 1: obtain random minibatch from replay memory\n\t\tminibatch = random.sample(self.replayMemory,BATCH_SIZE)\n\t\tstate_batch = [data[0] for data in minibatch]\n\t\taction_batch = [data[1] for data in minibatch]\n\t\treward_batch = [data[2] for data in minibatch]\n\t\tnextState_batch = [data[3] for data in minibatch]\n\n\t\t# Step 2: calculate y\n\t\ty_batch = []\n\t\tQValue_batch = self.QValueT.eval(feed_dict={self.stateInputT:nextState_batch})\n\t\tfor i in range(0,BATCH_SIZE):\n\t\t\tterminal = minibatch[i][4]\n\t\t\tif terminal:\n\t\t\t\ty_batch.append(reward_batch[i])\n\t\t\telse:\n\t\t\t\ty_batch.append(reward_batch[i] + GAMMA * np.max(QValue_batch[i]))\n\n\t\tself.trainStep.run(feed_dict={\n\t\t\tself.yInput : y_batch,\n\t\t\tself.actionInput : action_batch,\n\t\t\tself.stateInput : state_batch\n\t\t\t})\n\n\t\t# save network every 100000 iteration\n\t\tif self.timeStep % 10000 == 0:\n\t\t\tself.saver.save(self.session, 'saved_networks/' + 'network' + '-dqn', global_step = self.timeStep)\n\n\t\tif self.timeStep % UPDATE_TIME == 0:\n\t\t\tself.copyTargetQNetwork()\n\n\n\tdef setPerception(self,nextObservation,action,reward,terminal):\n\t\t#newState = np.append(nextObservation,self.currentState[:,:,1:],axis = 2)\n\t\tnewState = np.append(self.currentState[:,:,1:],nextObservation,axis = 2)\n\t\tself.replayMemory.append((self.currentState,action,reward,newState,terminal))\n\t\tif len(self.replayMemory) > REPLAY_MEMORY:\n\t\t\tself.replayMemory.popleft()\n\t\tif self.timeStep > OBSERVE:\n\t\t\t# Train the network\n\t\t\tself.trainQNetwork()\n\n\t\t# print info\n\t\tstate = \"\"\n\t\tif self.timeStep <= OBSERVE:\n\t\t\tstate = \"observe\"\n\t\telif self.timeStep > OBSERVE and self.timeStep <= OBSERVE + EXPLORE:\n\t\t\tstate = \"explore\"\n\t\telse:\n\t\t\tstate = \"train\"\n\n\t\tprint \"TIMESTEP\", self.timeStep, \"/ STATE\", state, \\\n            \"/ EPSILON\", self.epsilon\n\n\t\tself.currentState = newState\n\t\tself.timeStep += 1\n\n\tdef getAction(self):\n\t\tQValue = self.QValue.eval(feed_dict= {self.stateInput:[self.currentState]})[0]\n\t\taction = np.zeros(self.actions)\n\t\taction_index = 0\n\t\tif self.timeStep % FRAME_PER_ACTION == 0:\n\t\t\tif random.random() <= self.epsilon:\n\t\t\t\taction_index = random.randrange(self.actions)\n\t\t\t\taction[action_index] = 1\n\t\t\telse:\n\t\t\t\taction_index = np.argmax(QValue)\n\t\t\t\taction[action_index] = 1\n\t\telse:\n\t\t\taction[0] = 1 # do nothing\n\n\t\t# change episilon\n\t\tif self.epsilon > FINAL_EPSILON and self.timeStep > OBSERVE:\n\t\t\tself.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON)/EXPLORE\n\n\t\treturn action\n\n\tdef setInitState(self,observation):\n\t\tself.currentState = np.stack((observation, observation, observation, observation), axis = 2)\n\n\tdef weight_variable(self,shape):\n\t\tinitial = tf.truncated_normal(shape, stddev = 0.01)\n\t\treturn tf.Variable(initial)\n\n\tdef bias_variable(self,shape):\n\t\tinitial = tf.constant(0.01, shape = shape)\n\t\treturn tf.Variable(initial)\n\n\tdef conv2d(self,x, W, stride):\n\t\treturn tf.nn.conv2d(x, W, strides = [1, stride, stride, 1], padding = \"SAME\")\n\n\tdef max_pool_2x2(self,x):\n\t\treturn tf.nn.max_pool(x, ksize = [1, 2, 2, 1], strides = [1, 2, 2, 1], padding = \"SAME\")\n```\n\n\n\n下面是使用上面的DQN让agent玩Gym的Breakout-v0游戏。\n\n```python\n# -------------------------\n# Project: Deep Q-Learning on Breakout-v0\n# Author: Houjiang Chen\n# Date: 2017.4.25\n# -------------------------\n\nimport cv2\nimport gym\nfrom BrainDQN_Nature import BrainDQN\nimport numpy as np\n\n# preprocess raw image to 80*80 gray image\ndef preprocess(observation):\n    observation = cv2.cvtColor(cv2.resize(observation, (80, 80)), cv2.COLOR_BGR2GRAY)\n    #ret, observation = cv2.threshold(observation, 1, 255, cv2.THRESH_BINARY)\n    return np.reshape(observation, (80, 80, 1))\n\ndef play():\n    env = gym.make('Breakout-v0')\n    actions = env.action_space.n\n\n    # init BrainDQN\n    brain = BrainDQN(actions)\n\n    while 1:\n        state = env.reset()\n        state = cv2.cvtColor(cv2.resize(state, (80, 80)), cv2.COLOR_BGR2GRAY)\n        #ret, state = cv2.threshold(state, 1, 255, cv2.THRESH_BINARY)\n        brain.setInitState(state)\n        while 1:\n            action = brain.getAction()\n            state, reward, terminal, _ = env.step(np.argmax(action))\n            env.render()\n            if terminal:\n                break\n            state = preprocess(state)\n            brain.setPerception(state, action, reward, terminal)\n\n\ndef main():\n    play()\n\nif __name__ == '__main__':\n    main()\n```\n\n\n\n## 参考资料\n1、Reinforcement Learning: An Introduction, Richard S. Sutton and Andrew G. Barto，2012   \n2、Playing Atari with Deep Reinforcement Learning，DeepMind Technologies，Arxiv 2013.12   \n3、Human-level control through deep reinforcement learning，DeepMind Technologies，Nature 2015.02   \n4、DeepMind官网 https://deepmind.com/blog/deep-reinforcement-learning   \n5、https://www.nervanasys.com/demystifying-deep-reinforcement-learning   \n6、http://www.cnblogs.com/jinxulin/p/3511298.html   \n7、Introduction to Reinforcement Learning，David Silver   \n","slug":"强化学习（二）","published":1,"updated":"2023-01-03T14:06:33.028Z","_id":"clcgavftw000phbeq2ygb1akb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"dqn\">DQN</h2>\n<p>前面我们讲到TD算法结合了动态规划和蒙特卡洛算法的优点，不依赖具体的环境模型，并且更新时采用滑动平均的方式，因此单步就能更新，而不需要生成整个episode，在非episode情况下仍然适用。TD算法又分为on\npolicy的sarsa算法和off policy的Q learning算法，其中Q\nlearning算法直接使用下一状态的最大动作值函数进行更新，加快了算法收敛速度，因此Q\nlearning算法在实际应用中更加普遍。</p>\n<span id=\"more\"></span>\n<h3 id=\"q-learning例子\">Q learning例子</h3>\n<p>我们用一个例子来说明Q\nlearning算法的过程。下图是一个二叉树表示的路径规划问题，每一个节点代表环境中的一个状态，叶子节点表示终止状态，每个非叶子节点都可以选择向上或向下的动作，然后转移到下一个节点，并获得相应的得分。</p>\n</div align='center'>\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/9930b76dc4a4c37e188ea6363fe6603b.png?raw=true\" width=600>\n</div>\n<p></br> 首先初始化所有状态动作对的动作值函数：<span\nclass=\"math inline\">\\(Q(S_{i},a)=0, \\forall\ni\\in[1，6],a\\in[上，下]\\)</span>，并且初始化<span\nclass=\"math inline\">\\(\\epsilon = 0.1，\\alpha = 0.1\\)</span>。</p>\n<ul>\n<li>随机选择一个初始状态<span\nclass=\"math inline\">\\(S\\)</span>，假设为<span\nclass=\"math inline\">\\(S_0\\)</span><br />\n根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择一个动作，假设为上，转移到状态<span\nclass=\"math inline\">\\(S_1\\)</span>，那么更新<span\nclass=\"math inline\">\\(Q(S_0,上)=Q(S_0,上)+\\alpha\\cdot(R_{1}+\\max_aQ(S_1,a)-Q(S_0,上))=0+0.1\\cdot(10+0-0)=1\\)</span>，接下来继续根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择下一个动作，比如下，并且转移到终止状态<span\nclass=\"math inline\">\\(S_4\\)</span>，因此<span\nclass=\"math inline\">\\(Q(S_1,下)=Q(S_0,下)+\\alpha\\cdot(R_{2}+\\max_aQ(S_4,a)-Q(S_1,下))=0+0.1\\cdot(100+0-0)=10\\)</span>。</li>\n<li>随机选择一个初始状态<span\nclass=\"math inline\">\\(S\\)</span>，假设为<span\nclass=\"math inline\">\\(S_2\\)</span><br />\n根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择一个动作，假设为上，转移到终止状态<span\nclass=\"math inline\">\\(S_5\\)</span>，则更新<span\nclass=\"math inline\">\\(Q(S_2,上)=0+0.1\\cdot（100+0-0）=10\\)</span></li>\n<li>随机选择一个初始状态<span\nclass=\"math inline\">\\(S\\)</span>，假设为<span\nclass=\"math inline\">\\(S_0\\)</span><br />\n根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择一个动作，假设为上，转移到状态<span\nclass=\"math inline\">\\(S_1\\)</span>，则更新<span\nclass=\"math inline\">\\(Q(S_0,上)=1+0.1\\cdot(10+10-1)=2.9\\)</span>，选择下一个动作，比如上，则<span\nclass=\"math inline\">\\(Q(S_1,上)=0+0.1\\cdot(50+0-0)=5\\)</span></li>\n<li>随机选择一个初始状态<span\nclass=\"math inline\">\\(S\\)</span>，假设为<span\nclass=\"math inline\">\\(S_0\\)</span><br />\n根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择一个动作，假设为上，转移到状态<span\nclass=\"math inline\">\\(S_1\\)</span>，则更新<span\nclass=\"math inline\">\\(Q(S_0,上)=2.9+0.1\\cdot(10+10-2.9)=4.61\\)</span>，选择下一个动作，比如下，则<span\nclass=\"math inline\">\\(Q(S_1,下)=10+0.1\\cdot(100+0-10)=19\\)</span></li>\n<li>…</li>\n</ul>\n<p>下面是该例子的python实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">author: Houjiang Chen</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">q_learning</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, states, actions</span>):</span><br><span class=\"line\">        self.states = states</span><br><span class=\"line\">        self.actions = actions</span><br><span class=\"line\">        self.eps = <span class=\"number\">0.1</span></span><br><span class=\"line\">        self.alpha = <span class=\"number\">0.1</span></span><br><span class=\"line\">        self.q_table = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(actions)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(states)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_action</span>(<span class=\"params\">self, current_state</span>):</span><br><span class=\"line\">        max_action = self.q_table[current_state].index(<span class=\"built_in\">max</span>(self.q_table[current_state]))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random.uniform(<span class=\"number\">0</span>, <span class=\"number\">1</span>) &gt; self.eps:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> max_action</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            rest = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(self.q_table[current_state])) <span class=\"keyword\">if</span> i != max_action]</span><br><span class=\"line\">            index = random.randint(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(rest) - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rest[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">update</span>(<span class=\"params\">self, current_state, action, next_state, reward, final</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> final != <span class=\"number\">1</span>:</span><br><span class=\"line\">            reward = reward + <span class=\"built_in\">max</span>(self.q_table[next_state])</span><br><span class=\"line\">        self.q_table[current_state][action] += self.alpha * (reward - self.q_table[current_state][action])</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">environment</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.level = <span class=\"number\">2</span></span><br><span class=\"line\">        self.actions = <span class=\"number\">2</span></span><br><span class=\"line\">        self.states = self.actions ** (self.level + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        self.final_states = self.actions ** self.level</span><br><span class=\"line\">        self.reward = &#123;<span class=\"number\">0</span> : [<span class=\"number\">10</span>, -<span class=\"number\">10</span>], <span class=\"number\">1</span> : [<span class=\"number\">50</span>, <span class=\"number\">100</span>], <span class=\"number\">2</span> : [<span class=\"number\">100</span>, <span class=\"number\">150</span>]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next</span>(<span class=\"params\">self, current_state, action</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;action: 0 or 1</span></span><br><span class=\"line\"><span class=\"string\">           return: next_state, reward, is_final</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">next</span> = <span class=\"number\">2</span> * current_state + (action + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">next</span> &gt;= self.states - self.final_states:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span>, self.reward[current_state][action], <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>, self.reward[current_state][action], <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">reset</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.randint(<span class=\"number\">0</span>, self.states - self.final_states - <span class=\"number\">1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">env = environment()</span><br><span class=\"line\">agent = q_learning(env.states, env.actions)</span><br><span class=\"line\"></span><br><span class=\"line\">episode = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> episode &lt; <span class=\"number\">100000</span>:</span><br><span class=\"line\">    episode += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">&quot;episode: %d&quot;</span> % episode</span><br><span class=\"line\">    current_state = env.reset()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        action = agent.get_action(current_state)</span><br><span class=\"line\">        next_state, reward, final = env.<span class=\"built_in\">next</span>(current_state, action)</span><br><span class=\"line\">        agent.update(current_state, action, next_state, reward, final)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> final:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        current_state = next_state</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> agent.q_table</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>最终收敛结果为:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"number\">109.99999999999989</span>, <span class=\"number\">139.99999999999977</span>], </span><br><span class=\"line\">[<span class=\"number\">49.99999999999997</span>, <span class=\"number\">99.99999999999994</span>], </span><br><span class=\"line\">[<span class=\"number\">99.99999999999994</span>, <span class=\"number\">149.9999999999999</span>], </span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数逼近\">函数逼近</h3>\n<p>上面的例子中非终止状态数只有3个，每个非终止状态对应的动作只有2个，因此状态动作对总共有6个，使用表格存储完全没有问题，但实际上我们需要解决的并不是一个如此简单的问题。比如在【Playing\nAtari with Deep Reinforcement Learning】中DeepMind就使用Q\nlearning使得agent玩Atari 2600游戏的水平超越了人类水平。在Atari\n2600游戏中，每个游戏画面都是一个状态，如果每个画面都是像素为84*84的256灰度图像，那么将会产生<span\nclass=\"math inline\">\\(256^{84\\cdot84}\\)</span>个状态，用表格进行存储将会变得非常不现实。为了解决状态数爆炸的问题，通常可以使用函数逼近的方法。下面有几种函数表示的方式：</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/30EFF3D4-0562-4544-BFF9-D43B3EC7AFF7.png?raw=true\">\n</div>\n<p></br></p>\n<p>并且逼近函数的形式可以采用：</p>\n<ul>\n<li>Linear combinations of features</li>\n<li>Neural network</li>\n<li>Decision tree</li>\n<li>Nearest neighbour</li>\n<li>Fourier / wavelet bases</li>\n<li>...</li>\n</ul>\n<p>下面我们研究的DQN（Deep Q Network）就是采用Deep neural\nnetwork进行动作值函数逼近的一种方法，结构如下。</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/8e238f9d9836b789276e0e58d4aa1e34.png?raw=true\" width=400>\n</div>\n<p></br></p>\n<p>为推导方便，假设中间的Network为一层的全连接，即<span\nclass=\"math inline\">\\(\\hat{V}(s,\na)=x(S)^{T}w=\\sum_{j=1}^{n}{x_{j}(S)w_{j}}​\\)</span>，代价函数选择最小均方误差：<span\nclass=\"math inline\">\\(J(w)=\\frac{1}{2}(V(s,a)-\\hat{V}(s,a))^2​\\)</span>，采用随机梯度下降算法进行优化。</p>\n<p><span\nclass=\"math display\">\\[\\begin{split}\\frac{\\partial{J(w)}}{\\partial{w}}&amp;=\\left(V(s,a)-\\hat{V}(s,a)\\right)\\frac{\\partial{\\hat{V}(s,a)}}\n{\\partial{w}} \\\\ &amp;=\\left(V(s,a)-\\hat{V}(s,a)\\right)x(S)\n\\end{split}\\tag{1-1}\\]</span></p>\n<p><span class=\"math display\">\\[\\begin{split}w^k&amp;=w^{k-1}+\\eta\n\\Delta(w)\\\\&amp;=w^{k-1}-\\eta\n\\frac{\\partial{J(w)}}{\\partial{w}}\\\\&amp;=w^{k-1}-\\eta\n\\left(V(s,a)-\\hat{V}(s,a;w^{k})\\right)x(S)\\end{split}\\tag{1-2}\\]</span></p>\n<p>由于我们并没有动作值函数的真实值，因此与Q learning类似，<span\nclass=\"math inline\">\\(V(s,a,)\\)</span>可以使用下一个状态的动作值函数进行估计，即<span\nclass=\"math inline\">\\(V(s,a)=V(s,a;w^{k-1})=r+\\gamma\n\\max_{a^{&#39;}}V(s^{&#39;},a^{&#39;};w^{k-1})\\)</span>。</p>\n<p>整个训练过程仍然与Q learning一样，采用<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择动作，并按照公式(1-2)更新权重<span\nclass=\"math inline\">\\(w\\)</span>，实际上也就更新了策略的动作值函数。使用值函数逼近的方法不需要枚举每个状态动作对，突破了状态数的限制，使得Q\nlearning在一些复杂任务上得到广泛应用，但仍然没有解决动作数爆炸或者连续动作的问题。</p>\n<h3 id=\"dqn-1\">DQN</h3>\n<p>DQN最先出现于DeepMind发表的【Playing Atari with Deep Reinforcement\nLearning】论文中，由于需要直接输入图像画面，因此论文中使用CNN来表示Q函数，下面简单剖析一下该论文。</p>\n<p>使用的是典型的CNN，其结构为：</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/93F5C516-8E53-4F89-B03E-3EDD95DF1C76.png?raw=true\">\n</div>\n<p></br>\n与一般的CNN有所不同的是，没有pooling层，因为我们这里不是做图像分类，pooling层带来的旋转和数值不变性对分类是有作用的，但在这个任务中对物体的具体位置是非常敏感的，因此移除了pooling层。</p>\n<p>Atari原始的游戏帧为210\u0002*160像素的RGB图像，由于该任务对画面色彩不敏感，为了减少计算开销，将游戏帧预处理成84*84的灰度图像。但为了获得动态特征，最终是将前3帧图像与当前帧stack到一起组成一个4*84*84的图像作为CNN的输入，输出为每个动作对应的Q值。</p>\n<h3 id=\"经验回放\">经验回放</h3>\n<p>现在我们知道可以使用Q\nlearning去估计每个状态的未来回报的期望，并且可以使用CNN去逼近动作值函数，也就是可以使用DQN去解决一个复杂的MDP任务。但在实际应用时会出现更新波动较大，导致收敛非常慢的问题，DeepMind因此使用了一个经验回放（Experience\nReplay）机制，就是将每步的经验数据<span\nclass=\"math inline\">\\(&lt;s,a,r,s^{&#39;}&gt;\\)</span>存放在回放内存中，更新时都从回放内存中随机采样一个batch的数据进行更新。</p>\n<p>经验回放机制相比标准的DQN有两个好处：首先每一步的经验数据会被保存起来，更新时可以多次使用到经验数据，使得数据利用更高效；此外直接从连续的样本中学习是低效的，因为一个episode内样本具有很强的相关性，随机挑选样本打破了这种相关性，因此减小了更新时的变化，使得更新更加稳定（注：因为同一次实验过程的样本相关性很强，不同实验之间的相关性就显得相对比较小，如果使用连续的样本进行训练，在切换到下一次实验的样本时会导致模型更新不稳定）。</p>\n<p>由于内存大小限制，回放内存不可能将所有的经验数据都保存起来，因此只会保留最新的N组经验数据，比较久远的数据就会被遗忘。</p>\n<h3 id=\"训练\">训练</h3>\n<p>DeepMind使用DQN对\nATARI中七个游戏进行了实验，由于每个游戏的得分尺度不一致，因此他们将得分分为正回报、负回报和无回报，正回报得分为1，负回报得分为-1，无回报得分为0。</p>\n<p>使用 RMSProp算法进行优化，batch size为32，采用<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>行动策略，前一百万帧的<span\nclass=\"math inline\">\\(\\epsilon\\)</span>从1线性减少到0.1，最后固定为0.1。总共训练了一千万帧，并且使用了一百万大小的回放内存。</p>\n<p>训练过程伪代码：</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/1E5C7D95-519A-4B54-BF09-C27A163D12C8.png?raw=true\" width=600>\n</div>\n<h2 id=\"gym使用\">Gym使用</h2>\n<h3 id=\"gym简介\">Gym简介</h3>\n<p>目前强化学习的研究主要由DeepMind和OpenAI两家在主导，去年底到今年初DeepMind和OpenAI相继开源了自家的3D\nlearning environment平台DeepMind Lab和Universe。DeepMind\nLab目前给出的文档和例子都比较少，使用也稍显复杂，所以暂时可以不考虑使用。Universe包含了1000+的游戏环境，并且将程序打包在docker环境中运行，提供与Gym一致的接口。Universe的环境由一个client和一个remote组成，client是一个VNCenv，主要负责接收agent的动作，传递回报和管理本地episode的状态，remote是指在docker环境中运行的程序，remote可以运行在本地、远程服务器或在cloud上。client和remote通过VNC远程桌面系统进行交互，通过WebSocket传递回报、诊断和控制信息。</p>\n<p>由于Universe环境提供Gym接口，而Gym是OpenAI去年4月份发布的一套开发和比较强化学习算法的toolkit。Gym本身是可以独立于Universe使用的，并且Universe和Gym中agent代码基本没有什么区别。我们下面就单独讲讲Gym接口和如何使用Gym训练自己的agent。</p>\n<p>Gym目前提供python接口，并支持任何的计算框架，比如tensorflow、theano等。强化学习解决的是agent和环境交互的任务，agent根据当前环境状态做出某个动作，然后观察下一个状态和回报，环境根据agent的动作转移到下一个状态，并发送回报。Gym提供的实际上是环境这个角色，每个Gym环境都提供一致的接口。</p>\n<h3 id=\"创建一个gym环境\">创建一个Gym环境</h3>\n<p>创建一个环境时只需要指定环境id，比如agent需要玩Atari\nBreakout-v0这个游戏，可以如下创建一个Breakout-v0的环境。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gym</span><br><span class=\"line\">env = gym.make(<span class=\"string\">&#x27;Breakout-v0&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"step\">step</h3>\n<p>输入agent的动作，返回4个值，分别为：</p>\n<ul>\n<li>observation：表示agent观察到的下一个状态，比如在一些游戏中，observation为RGB的图像</li>\n<li>reward：表示执行输入的动作后得到的回报值</li>\n<li>done：表示返回的observation是不是结束状态</li>\n<li>info：调试信息，一般没什么用处</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next_state, reward, terminal, _ = env.step(action)</span><br></pre></td></tr></table></figure>\n<h3 id=\"reset\">reset</h3>\n<p>在开始一个新的episode时，Gym环境都要reset，获得一个初始状态。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_state = env.reset()</span><br></pre></td></tr></table></figure>\n<h3 id=\"render\">render</h3>\n<p>render是Gym用来渲染环境状态的函数，当调用该函数时会出现一个动图框。一般agent执行一个动作，环境都要渲染一次，这样就可以实时看到agent的执行情况了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env.render()</span><br></pre></td></tr></table></figure>\n<h3 id=\"spaces\">Spaces</h3>\n<p>Gym环境有两个space属性，一个是action_space，一个是observation_space，分别表示该Gym环境下合法的动作和状态。action_space是Gym中的一个Discrete对象，Discrete对象有一个成员n，表示合法的动作数，比如Discrete(2)表示有两个合法动作，编号从0开始，因此两个动作编号为0和1。observation_space是Gym中的一个Box对象，Box的shape表示observation的数据组织方式，比如Box(210,\n160,\n3)表示合法的observation是一个210*160*3的数组，而Box(4,)表示observation是一个大小为4的向量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">observation_space = env.observation_space <span class=\"comment\"># observation_space: Discrete(6)</span></span><br><span class=\"line\">action_space = env.action_space <span class=\"comment\"># action_space: Box(210, 160, 3)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"breakout-v0例子\">Breakout-v0例子</h3>\n<p>采用了github上Flood Sung的DQN实现，感谢Flood Sung大神的无私贡献。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -----------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># File: Deep Q-Learning Algorithm</span></span><br><span class=\"line\"><span class=\"comment\"># Author: Flood Sung</span></span><br><span class=\"line\"><span class=\"comment\"># Date: 2016.3.21</span></span><br><span class=\"line\"><span class=\"comment\"># -----------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Hyper Parameters:</span></span><br><span class=\"line\">FRAME_PER_ACTION = <span class=\"number\">1</span></span><br><span class=\"line\">GAMMA = <span class=\"number\">0.99</span> <span class=\"comment\"># decay rate of past observations</span></span><br><span class=\"line\">OBSERVE = <span class=\"number\">100.</span> <span class=\"comment\"># timesteps to observe before training</span></span><br><span class=\"line\">EXPLORE = <span class=\"number\">200000.</span> <span class=\"comment\"># frames over which to anneal epsilon</span></span><br><span class=\"line\">FINAL_EPSILON = <span class=\"number\">0</span><span class=\"comment\">#0.001 # final value of epsilon</span></span><br><span class=\"line\">INITIAL_EPSILON = <span class=\"number\">0</span><span class=\"comment\">#0.01 # starting value of epsilon</span></span><br><span class=\"line\">REPLAY_MEMORY = <span class=\"number\">50000</span> <span class=\"comment\"># number of previous transitions to remember</span></span><br><span class=\"line\">BATCH_SIZE = <span class=\"number\">32</span> <span class=\"comment\"># size of minibatch</span></span><br><span class=\"line\">UPDATE_TIME = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BrainDQN</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,actions</span>):</span><br><span class=\"line\">\t\t<span class=\"comment\"># init replay memory</span></span><br><span class=\"line\">\t\tself.replayMemory = deque()</span><br><span class=\"line\">\t\t<span class=\"comment\"># init some parameters</span></span><br><span class=\"line\">\t\tself.timeStep = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tself.epsilon = INITIAL_EPSILON</span><br><span class=\"line\">\t\tself.actions = actions</span><br><span class=\"line\">\t\t<span class=\"comment\"># init Q network</span></span><br><span class=\"line\">\t\tself.stateInput,self.QValue,self.W_conv1,self.b_conv1,self.W_conv2,self.b_conv2,self.W_conv3,self.b_conv3,self.W_fc1,self.b_fc1,self.W_fc2,self.b_fc2 = self.createQNetwork()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># init Target Q Network</span></span><br><span class=\"line\">\t\tself.stateInputT,self.QValueT,self.W_conv1T,self.b_conv1T,self.W_conv2T,self.b_conv2T,self.W_conv3T,self.b_conv3T,self.W_fc1T,self.b_fc1T,self.W_fc2T,self.b_fc2T = self.createQNetwork()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.copyTargetQNetworkOperation = [self.W_conv1T.assign(self.W_conv1),self.b_conv1T.assign(self.b_conv1),self.W_conv2T.assign(self.W_conv2),self.b_conv2T.assign(self.b_conv2),self.W_conv3T.assign(self.W_conv3),self.b_conv3T.assign(self.b_conv3),self.W_fc1T.assign(self.W_fc1),self.b_fc1T.assign(self.b_fc1),self.W_fc2T.assign(self.W_fc2),self.b_fc2T.assign(self.b_fc2)]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.createTrainingMethod()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># saving and loading networks</span></span><br><span class=\"line\">\t\tself.saver = tf.train.Saver()</span><br><span class=\"line\">\t\tself.session = tf.InteractiveSession()</span><br><span class=\"line\">\t\tself.session.run(tf.initialize_all_variables())</span><br><span class=\"line\">\t\tcheckpoint = tf.train.get_checkpoint_state(<span class=\"string\">&quot;saved_networks&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> checkpoint <span class=\"keyword\">and</span> checkpoint.model_checkpoint_path:</span><br><span class=\"line\">\t\t\t\tself.saver.restore(self.session, checkpoint.model_checkpoint_path)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">print</span> <span class=\"string\">&quot;Successfully loaded:&quot;</span>, checkpoint.model_checkpoint_path</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">print</span> <span class=\"string\">&quot;Could not find old network weights&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">createQNetwork</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\t<span class=\"comment\"># network weights</span></span><br><span class=\"line\">\t\tW_conv1 = self.weight_variable([<span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">32</span>])</span><br><span class=\"line\">\t\tb_conv1 = self.bias_variable([<span class=\"number\">32</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tW_conv2 = self.weight_variable([<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">32</span>,<span class=\"number\">64</span>])</span><br><span class=\"line\">\t\tb_conv2 = self.bias_variable([<span class=\"number\">64</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tW_conv3 = self.weight_variable([<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">64</span>,<span class=\"number\">64</span>])</span><br><span class=\"line\">\t\tb_conv3 = self.bias_variable([<span class=\"number\">64</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tW_fc1 = self.weight_variable([<span class=\"number\">1600</span>,<span class=\"number\">512</span>])</span><br><span class=\"line\">\t\tb_fc1 = self.bias_variable([<span class=\"number\">512</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tW_fc2 = self.weight_variable([<span class=\"number\">512</span>,self.actions])</span><br><span class=\"line\">\t\tb_fc2 = self.bias_variable([self.actions])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># input layer</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tstateInput = tf.placeholder(<span class=\"string\">&quot;float&quot;</span>,[<span class=\"literal\">None</span>,<span class=\"number\">80</span>,<span class=\"number\">80</span>,<span class=\"number\">4</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># hidden layers</span></span><br><span class=\"line\">\t\th_conv1 = tf.nn.relu(self.conv2d(stateInput,W_conv1,<span class=\"number\">4</span>) + b_conv1)</span><br><span class=\"line\">\t\th_pool1 = self.max_pool_2x2(h_conv1)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\th_conv2 = tf.nn.relu(self.conv2d(h_pool1,W_conv2,<span class=\"number\">2</span>) + b_conv2)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\th_conv3 = tf.nn.relu(self.conv2d(h_conv2,W_conv3,<span class=\"number\">1</span>) + b_conv3)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\th_conv3_flat = tf.reshape(h_conv3,[-<span class=\"number\">1</span>,<span class=\"number\">1600</span>])</span><br><span class=\"line\">\t\th_fc1 = tf.nn.relu(tf.matmul(h_conv3_flat,W_fc1) + b_fc1)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># Q Value layer</span></span><br><span class=\"line\">\t\tQValue = tf.matmul(h_fc1,W_fc2) + b_fc2</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> stateInput,QValue,W_conv1,b_conv1,W_conv2,b_conv2,W_conv3,b_conv3,W_fc1,b_fc1,W_fc2,b_fc2</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">copyTargetQNetwork</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\tself.session.run(self.copyTargetQNetworkOperation)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">createTrainingMethod</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\tself.actionInput = tf.placeholder(<span class=\"string\">&quot;float&quot;</span>,[<span class=\"literal\">None</span>,self.actions])</span><br><span class=\"line\">\t\tself.yInput = tf.placeholder(<span class=\"string\">&quot;float&quot;</span>, [<span class=\"literal\">None</span>])</span><br><span class=\"line\">\t\tQ_Action = tf.reduce_sum(tf.mul(self.QValue, self.actionInput), reduction_indices = <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tself.cost = tf.reduce_mean(tf.square(self.yInput - Q_Action))</span><br><span class=\"line\">\t\tself.trainStep = tf.train.AdamOptimizer(<span class=\"number\">1e-6</span>).minimize(self.cost)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">trainQNetwork</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\t<span class=\"comment\"># Step 1: obtain random minibatch from replay memory</span></span><br><span class=\"line\">\t\tminibatch = random.sample(self.replayMemory,BATCH_SIZE)</span><br><span class=\"line\">\t\tstate_batch = [data[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> minibatch]</span><br><span class=\"line\">\t\taction_batch = [data[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> minibatch]</span><br><span class=\"line\">\t\treward_batch = [data[<span class=\"number\">2</span>] <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> minibatch]</span><br><span class=\"line\">\t\tnextState_batch = [data[<span class=\"number\">3</span>] <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> minibatch]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># Step 2: calculate y</span></span><br><span class=\"line\">\t\ty_batch = []</span><br><span class=\"line\">\t\tQValue_batch = self.QValueT.<span class=\"built_in\">eval</span>(feed_dict=&#123;self.stateInputT:nextState_batch&#125;)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>,BATCH_SIZE):</span><br><span class=\"line\">\t\t\tterminal = minibatch[i][<span class=\"number\">4</span>]</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> terminal:</span><br><span class=\"line\">\t\t\t\ty_batch.append(reward_batch[i])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\ty_batch.append(reward_batch[i] + GAMMA * np.<span class=\"built_in\">max</span>(QValue_batch[i]))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.trainStep.run(feed_dict=&#123;</span><br><span class=\"line\">\t\t\tself.yInput : y_batch,</span><br><span class=\"line\">\t\t\tself.actionInput : action_batch,</span><br><span class=\"line\">\t\t\tself.stateInput : state_batch</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># save network every 100000 iteration</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep % <span class=\"number\">10000</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\tself.saver.save(self.session, <span class=\"string\">&#x27;saved_networks/&#x27;</span> + <span class=\"string\">&#x27;network&#x27;</span> + <span class=\"string\">&#x27;-dqn&#x27;</span>, global_step = self.timeStep)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep % UPDATE_TIME == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\tself.copyTargetQNetwork()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">setPerception</span>(<span class=\"params\">self,nextObservation,action,reward,terminal</span>):</span><br><span class=\"line\">\t\t<span class=\"comment\">#newState = np.append(nextObservation,self.currentState[:,:,1:],axis = 2)</span></span><br><span class=\"line\">\t\tnewState = np.append(self.currentState[:,:,<span class=\"number\">1</span>:],nextObservation,axis = <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\tself.replayMemory.append((self.currentState,action,reward,newState,terminal))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(self.replayMemory) &gt; REPLAY_MEMORY:</span><br><span class=\"line\">\t\t\tself.replayMemory.popleft()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep &gt; OBSERVE:</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># Train the network</span></span><br><span class=\"line\">\t\t\tself.trainQNetwork()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># print info</span></span><br><span class=\"line\">\t\tstate = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep &lt;= OBSERVE:</span><br><span class=\"line\">\t\t\tstate = <span class=\"string\">&quot;observe&quot;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">elif</span> self.timeStep &gt; OBSERVE <span class=\"keyword\">and</span> self.timeStep &lt;= OBSERVE + EXPLORE:</span><br><span class=\"line\">\t\t\tstate = <span class=\"string\">&quot;explore&quot;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\tstate = <span class=\"string\">&quot;train&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span> <span class=\"string\">&quot;TIMESTEP&quot;</span>, self.timeStep, <span class=\"string\">&quot;/ STATE&quot;</span>, state, \\</span><br><span class=\"line\">            <span class=\"string\">&quot;/ EPSILON&quot;</span>, self.epsilon</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.currentState = newState</span><br><span class=\"line\">\t\tself.timeStep += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">getAction</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\tQValue = self.QValue.<span class=\"built_in\">eval</span>(feed_dict= &#123;self.stateInput:[self.currentState]&#125;)[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\taction = np.zeros(self.actions)</span><br><span class=\"line\">\t\taction_index = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep % FRAME_PER_ACTION == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> random.random() &lt;= self.epsilon:</span><br><span class=\"line\">\t\t\t\taction_index = random.randrange(self.actions)</span><br><span class=\"line\">\t\t\t\taction[action_index] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\taction_index = np.argmax(QValue)</span><br><span class=\"line\">\t\t\t\taction[action_index] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\taction[<span class=\"number\">0</span>] = <span class=\"number\">1</span> <span class=\"comment\"># do nothing</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># change episilon</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.epsilon &gt; FINAL_EPSILON <span class=\"keyword\">and</span> self.timeStep &gt; OBSERVE:</span><br><span class=\"line\">\t\t\tself.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON)/EXPLORE</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> action</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">setInitState</span>(<span class=\"params\">self,observation</span>):</span><br><span class=\"line\">\t\tself.currentState = np.stack((observation, observation, observation, observation), axis = <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">weight_variable</span>(<span class=\"params\">self,shape</span>):</span><br><span class=\"line\">\t\tinitial = tf.truncated_normal(shape, stddev = <span class=\"number\">0.01</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tf.Variable(initial)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">bias_variable</span>(<span class=\"params\">self,shape</span>):</span><br><span class=\"line\">\t\tinitial = tf.constant(<span class=\"number\">0.01</span>, shape = shape)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tf.Variable(initial)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">conv2d</span>(<span class=\"params\">self,x, W, stride</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tf.nn.conv2d(x, W, strides = [<span class=\"number\">1</span>, stride, stride, <span class=\"number\">1</span>], padding = <span class=\"string\">&quot;SAME&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">max_pool_2x2</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tf.nn.max_pool(x, ksize = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>], strides = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>], padding = <span class=\"string\">&quot;SAME&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>下面是使用上面的DQN让agent玩Gym的Breakout-v0游戏。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Project: Deep Q-Learning on Breakout-v0</span></span><br><span class=\"line\"><span class=\"comment\"># Author: Houjiang Chen</span></span><br><span class=\"line\"><span class=\"comment\"># Date: 2017.4.25</span></span><br><span class=\"line\"><span class=\"comment\"># -------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> gym</span><br><span class=\"line\"><span class=\"keyword\">from</span> BrainDQN_Nature <span class=\"keyword\">import</span> BrainDQN</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># preprocess raw image to 80*80 gray image</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">preprocess</span>(<span class=\"params\">observation</span>):</span><br><span class=\"line\">    observation = cv2.cvtColor(cv2.resize(observation, (<span class=\"number\">80</span>, <span class=\"number\">80</span>)), cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    <span class=\"comment\">#ret, observation = cv2.threshold(observation, 1, 255, cv2.THRESH_BINARY)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.reshape(observation, (<span class=\"number\">80</span>, <span class=\"number\">80</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play</span>():</span><br><span class=\"line\">    env = gym.make(<span class=\"string\">&#x27;Breakout-v0&#x27;</span>)</span><br><span class=\"line\">    actions = env.action_space.n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># init BrainDQN</span></span><br><span class=\"line\">    brain = BrainDQN(actions)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        state = env.reset()</span><br><span class=\"line\">        state = cv2.cvtColor(cv2.resize(state, (<span class=\"number\">80</span>, <span class=\"number\">80</span>)), cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">        <span class=\"comment\">#ret, state = cv2.threshold(state, 1, 255, cv2.THRESH_BINARY)</span></span><br><span class=\"line\">        brain.setInitState(state)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            action = brain.getAction()</span><br><span class=\"line\">            state, reward, terminal, _ = env.step(np.argmax(action))</span><br><span class=\"line\">            env.render()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> terminal:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            state = preprocess(state)</span><br><span class=\"line\">            brain.setPerception(state, action, reward, terminal)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    play()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>1、Reinforcement Learning: An Introduction, Richard S. Sutton and\nAndrew G. Barto，2012<br />\n2、Playing Atari with Deep Reinforcement Learning，DeepMind\nTechnologies，Arxiv 2013.12<br />\n3、Human-level control through deep reinforcement learning，DeepMind\nTechnologies，Nature 2015.02<br />\n4、DeepMind官网\nhttps://deepmind.com/blog/deep-reinforcement-learning<br />\n5、https://www.nervanasys.com/demystifying-deep-reinforcement-learning<br />\n6、http://www.cnblogs.com/jinxulin/p/3511298.html<br />\n7、Introduction to Reinforcement Learning，David Silver</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"dqn\">DQN</h2>\n<p>前面我们讲到TD算法结合了动态规划和蒙特卡洛算法的优点，不依赖具体的环境模型，并且更新时采用滑动平均的方式，因此单步就能更新，而不需要生成整个episode，在非episode情况下仍然适用。TD算法又分为on\npolicy的sarsa算法和off policy的Q learning算法，其中Q\nlearning算法直接使用下一状态的最大动作值函数进行更新，加快了算法收敛速度，因此Q\nlearning算法在实际应用中更加普遍。</p>","more":"<h3 id=\"q-learning例子\">Q learning例子</h3>\n<p>我们用一个例子来说明Q\nlearning算法的过程。下图是一个二叉树表示的路径规划问题，每一个节点代表环境中的一个状态，叶子节点表示终止状态，每个非叶子节点都可以选择向上或向下的动作，然后转移到下一个节点，并获得相应的得分。</p>\n</div align='center'>\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/9930b76dc4a4c37e188ea6363fe6603b.png?raw=true\" width=600>\n</div>\n<p></br> 首先初始化所有状态动作对的动作值函数：<span\nclass=\"math inline\">\\(Q(S_{i},a)=0, \\forall\ni\\in[1，6],a\\in[上，下]\\)</span>，并且初始化<span\nclass=\"math inline\">\\(\\epsilon = 0.1，\\alpha = 0.1\\)</span>。</p>\n<ul>\n<li>随机选择一个初始状态<span\nclass=\"math inline\">\\(S\\)</span>，假设为<span\nclass=\"math inline\">\\(S_0\\)</span><br />\n根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择一个动作，假设为上，转移到状态<span\nclass=\"math inline\">\\(S_1\\)</span>，那么更新<span\nclass=\"math inline\">\\(Q(S_0,上)=Q(S_0,上)+\\alpha\\cdot(R_{1}+\\max_aQ(S_1,a)-Q(S_0,上))=0+0.1\\cdot(10+0-0)=1\\)</span>，接下来继续根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择下一个动作，比如下，并且转移到终止状态<span\nclass=\"math inline\">\\(S_4\\)</span>，因此<span\nclass=\"math inline\">\\(Q(S_1,下)=Q(S_0,下)+\\alpha\\cdot(R_{2}+\\max_aQ(S_4,a)-Q(S_1,下))=0+0.1\\cdot(100+0-0)=10\\)</span>。</li>\n<li>随机选择一个初始状态<span\nclass=\"math inline\">\\(S\\)</span>，假设为<span\nclass=\"math inline\">\\(S_2\\)</span><br />\n根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择一个动作，假设为上，转移到终止状态<span\nclass=\"math inline\">\\(S_5\\)</span>，则更新<span\nclass=\"math inline\">\\(Q(S_2,上)=0+0.1\\cdot（100+0-0）=10\\)</span></li>\n<li>随机选择一个初始状态<span\nclass=\"math inline\">\\(S\\)</span>，假设为<span\nclass=\"math inline\">\\(S_0\\)</span><br />\n根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择一个动作，假设为上，转移到状态<span\nclass=\"math inline\">\\(S_1\\)</span>，则更新<span\nclass=\"math inline\">\\(Q(S_0,上)=1+0.1\\cdot(10+10-1)=2.9\\)</span>，选择下一个动作，比如上，则<span\nclass=\"math inline\">\\(Q(S_1,上)=0+0.1\\cdot(50+0-0)=5\\)</span></li>\n<li>随机选择一个初始状态<span\nclass=\"math inline\">\\(S\\)</span>，假设为<span\nclass=\"math inline\">\\(S_0\\)</span><br />\n根据<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择一个动作，假设为上，转移到状态<span\nclass=\"math inline\">\\(S_1\\)</span>，则更新<span\nclass=\"math inline\">\\(Q(S_0,上)=2.9+0.1\\cdot(10+10-2.9)=4.61\\)</span>，选择下一个动作，比如下，则<span\nclass=\"math inline\">\\(Q(S_1,下)=10+0.1\\cdot(100+0-10)=19\\)</span></li>\n<li>…</li>\n</ul>\n<p>下面是该例子的python实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">author: Houjiang Chen</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">q_learning</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, states, actions</span>):</span><br><span class=\"line\">        self.states = states</span><br><span class=\"line\">        self.actions = actions</span><br><span class=\"line\">        self.eps = <span class=\"number\">0.1</span></span><br><span class=\"line\">        self.alpha = <span class=\"number\">0.1</span></span><br><span class=\"line\">        self.q_table = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(actions)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(states)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_action</span>(<span class=\"params\">self, current_state</span>):</span><br><span class=\"line\">        max_action = self.q_table[current_state].index(<span class=\"built_in\">max</span>(self.q_table[current_state]))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> random.uniform(<span class=\"number\">0</span>, <span class=\"number\">1</span>) &gt; self.eps:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> max_action</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            rest = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(self.q_table[current_state])) <span class=\"keyword\">if</span> i != max_action]</span><br><span class=\"line\">            index = random.randint(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(rest) - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rest[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">update</span>(<span class=\"params\">self, current_state, action, next_state, reward, final</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> final != <span class=\"number\">1</span>:</span><br><span class=\"line\">            reward = reward + <span class=\"built_in\">max</span>(self.q_table[next_state])</span><br><span class=\"line\">        self.q_table[current_state][action] += self.alpha * (reward - self.q_table[current_state][action])</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">environment</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.level = <span class=\"number\">2</span></span><br><span class=\"line\">        self.actions = <span class=\"number\">2</span></span><br><span class=\"line\">        self.states = self.actions ** (self.level + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        self.final_states = self.actions ** self.level</span><br><span class=\"line\">        self.reward = &#123;<span class=\"number\">0</span> : [<span class=\"number\">10</span>, -<span class=\"number\">10</span>], <span class=\"number\">1</span> : [<span class=\"number\">50</span>, <span class=\"number\">100</span>], <span class=\"number\">2</span> : [<span class=\"number\">100</span>, <span class=\"number\">150</span>]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next</span>(<span class=\"params\">self, current_state, action</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;action: 0 or 1</span></span><br><span class=\"line\"><span class=\"string\">           return: next_state, reward, is_final</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">next</span> = <span class=\"number\">2</span> * current_state + (action + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">next</span> &gt;= self.states - self.final_states:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span>, self.reward[current_state][action], <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>, self.reward[current_state][action], <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">reset</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> random.randint(<span class=\"number\">0</span>, self.states - self.final_states - <span class=\"number\">1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">env = environment()</span><br><span class=\"line\">agent = q_learning(env.states, env.actions)</span><br><span class=\"line\"></span><br><span class=\"line\">episode = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> episode &lt; <span class=\"number\">100000</span>:</span><br><span class=\"line\">    episode += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">&quot;episode: %d&quot;</span> % episode</span><br><span class=\"line\">    current_state = env.reset()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        action = agent.get_action(current_state)</span><br><span class=\"line\">        next_state, reward, final = env.<span class=\"built_in\">next</span>(current_state, action)</span><br><span class=\"line\">        agent.update(current_state, action, next_state, reward, final)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> final:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        current_state = next_state</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> agent.q_table</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>最终收敛结果为:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"number\">109.99999999999989</span>, <span class=\"number\">139.99999999999977</span>], </span><br><span class=\"line\">[<span class=\"number\">49.99999999999997</span>, <span class=\"number\">99.99999999999994</span>], </span><br><span class=\"line\">[<span class=\"number\">99.99999999999994</span>, <span class=\"number\">149.9999999999999</span>], </span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">0</span>]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数逼近\">函数逼近</h3>\n<p>上面的例子中非终止状态数只有3个，每个非终止状态对应的动作只有2个，因此状态动作对总共有6个，使用表格存储完全没有问题，但实际上我们需要解决的并不是一个如此简单的问题。比如在【Playing\nAtari with Deep Reinforcement Learning】中DeepMind就使用Q\nlearning使得agent玩Atari 2600游戏的水平超越了人类水平。在Atari\n2600游戏中，每个游戏画面都是一个状态，如果每个画面都是像素为84*84的256灰度图像，那么将会产生<span\nclass=\"math inline\">\\(256^{84\\cdot84}\\)</span>个状态，用表格进行存储将会变得非常不现实。为了解决状态数爆炸的问题，通常可以使用函数逼近的方法。下面有几种函数表示的方式：</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/30EFF3D4-0562-4544-BFF9-D43B3EC7AFF7.png?raw=true\">\n</div>\n<p></br></p>\n<p>并且逼近函数的形式可以采用：</p>\n<ul>\n<li>Linear combinations of features</li>\n<li>Neural network</li>\n<li>Decision tree</li>\n<li>Nearest neighbour</li>\n<li>Fourier / wavelet bases</li>\n<li>...</li>\n</ul>\n<p>下面我们研究的DQN（Deep Q Network）就是采用Deep neural\nnetwork进行动作值函数逼近的一种方法，结构如下。</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/8e238f9d9836b789276e0e58d4aa1e34.png?raw=true\" width=400>\n</div>\n<p></br></p>\n<p>为推导方便，假设中间的Network为一层的全连接，即<span\nclass=\"math inline\">\\(\\hat{V}(s,\na)=x(S)^{T}w=\\sum_{j=1}^{n}{x_{j}(S)w_{j}}​\\)</span>，代价函数选择最小均方误差：<span\nclass=\"math inline\">\\(J(w)=\\frac{1}{2}(V(s,a)-\\hat{V}(s,a))^2​\\)</span>，采用随机梯度下降算法进行优化。</p>\n<p><span\nclass=\"math display\">\\[\\begin{split}\\frac{\\partial{J(w)}}{\\partial{w}}&amp;=\\left(V(s,a)-\\hat{V}(s,a)\\right)\\frac{\\partial{\\hat{V}(s,a)}}\n{\\partial{w}} \\\\ &amp;=\\left(V(s,a)-\\hat{V}(s,a)\\right)x(S)\n\\end{split}\\tag{1-1}\\]</span></p>\n<p><span class=\"math display\">\\[\\begin{split}w^k&amp;=w^{k-1}+\\eta\n\\Delta(w)\\\\&amp;=w^{k-1}-\\eta\n\\frac{\\partial{J(w)}}{\\partial{w}}\\\\&amp;=w^{k-1}-\\eta\n\\left(V(s,a)-\\hat{V}(s,a;w^{k})\\right)x(S)\\end{split}\\tag{1-2}\\]</span></p>\n<p>由于我们并没有动作值函数的真实值，因此与Q learning类似，<span\nclass=\"math inline\">\\(V(s,a,)\\)</span>可以使用下一个状态的动作值函数进行估计，即<span\nclass=\"math inline\">\\(V(s,a)=V(s,a;w^{k-1})=r+\\gamma\n\\max_{a^{&#39;}}V(s^{&#39;},a^{&#39;};w^{k-1})\\)</span>。</p>\n<p>整个训练过程仍然与Q learning一样，采用<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>策略选择动作，并按照公式(1-2)更新权重<span\nclass=\"math inline\">\\(w\\)</span>，实际上也就更新了策略的动作值函数。使用值函数逼近的方法不需要枚举每个状态动作对，突破了状态数的限制，使得Q\nlearning在一些复杂任务上得到广泛应用，但仍然没有解决动作数爆炸或者连续动作的问题。</p>\n<h3 id=\"dqn-1\">DQN</h3>\n<p>DQN最先出现于DeepMind发表的【Playing Atari with Deep Reinforcement\nLearning】论文中，由于需要直接输入图像画面，因此论文中使用CNN来表示Q函数，下面简单剖析一下该论文。</p>\n<p>使用的是典型的CNN，其结构为：</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/93F5C516-8E53-4F89-B03E-3EDD95DF1C76.png?raw=true\">\n</div>\n<p></br>\n与一般的CNN有所不同的是，没有pooling层，因为我们这里不是做图像分类，pooling层带来的旋转和数值不变性对分类是有作用的，但在这个任务中对物体的具体位置是非常敏感的，因此移除了pooling层。</p>\n<p>Atari原始的游戏帧为210\u0002*160像素的RGB图像，由于该任务对画面色彩不敏感，为了减少计算开销，将游戏帧预处理成84*84的灰度图像。但为了获得动态特征，最终是将前3帧图像与当前帧stack到一起组成一个4*84*84的图像作为CNN的输入，输出为每个动作对应的Q值。</p>\n<h3 id=\"经验回放\">经验回放</h3>\n<p>现在我们知道可以使用Q\nlearning去估计每个状态的未来回报的期望，并且可以使用CNN去逼近动作值函数，也就是可以使用DQN去解决一个复杂的MDP任务。但在实际应用时会出现更新波动较大，导致收敛非常慢的问题，DeepMind因此使用了一个经验回放（Experience\nReplay）机制，就是将每步的经验数据<span\nclass=\"math inline\">\\(&lt;s,a,r,s^{&#39;}&gt;\\)</span>存放在回放内存中，更新时都从回放内存中随机采样一个batch的数据进行更新。</p>\n<p>经验回放机制相比标准的DQN有两个好处：首先每一步的经验数据会被保存起来，更新时可以多次使用到经验数据，使得数据利用更高效；此外直接从连续的样本中学习是低效的，因为一个episode内样本具有很强的相关性，随机挑选样本打破了这种相关性，因此减小了更新时的变化，使得更新更加稳定（注：因为同一次实验过程的样本相关性很强，不同实验之间的相关性就显得相对比较小，如果使用连续的样本进行训练，在切换到下一次实验的样本时会导致模型更新不稳定）。</p>\n<p>由于内存大小限制，回放内存不可能将所有的经验数据都保存起来，因此只会保留最新的N组经验数据，比较久远的数据就会被遗忘。</p>\n<h3 id=\"训练\">训练</h3>\n<p>DeepMind使用DQN对\nATARI中七个游戏进行了实验，由于每个游戏的得分尺度不一致，因此他们将得分分为正回报、负回报和无回报，正回报得分为1，负回报得分为-1，无回报得分为0。</p>\n<p>使用 RMSProp算法进行优化，batch size为32，采用<span\nclass=\"math inline\">\\(\\epsilon-greedy\\)</span>行动策略，前一百万帧的<span\nclass=\"math inline\">\\(\\epsilon\\)</span>从1线性减少到0.1，最后固定为0.1。总共训练了一千万帧，并且使用了一百万大小的回放内存。</p>\n<p>训练过程伪代码：</p>\n<div data-align=\"center\">\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/pictures/1E5C7D95-519A-4B54-BF09-C27A163D12C8.png?raw=true\" width=600>\n</div>\n<h2 id=\"gym使用\">Gym使用</h2>\n<h3 id=\"gym简介\">Gym简介</h3>\n<p>目前强化学习的研究主要由DeepMind和OpenAI两家在主导，去年底到今年初DeepMind和OpenAI相继开源了自家的3D\nlearning environment平台DeepMind Lab和Universe。DeepMind\nLab目前给出的文档和例子都比较少，使用也稍显复杂，所以暂时可以不考虑使用。Universe包含了1000+的游戏环境，并且将程序打包在docker环境中运行，提供与Gym一致的接口。Universe的环境由一个client和一个remote组成，client是一个VNCenv，主要负责接收agent的动作，传递回报和管理本地episode的状态，remote是指在docker环境中运行的程序，remote可以运行在本地、远程服务器或在cloud上。client和remote通过VNC远程桌面系统进行交互，通过WebSocket传递回报、诊断和控制信息。</p>\n<p>由于Universe环境提供Gym接口，而Gym是OpenAI去年4月份发布的一套开发和比较强化学习算法的toolkit。Gym本身是可以独立于Universe使用的，并且Universe和Gym中agent代码基本没有什么区别。我们下面就单独讲讲Gym接口和如何使用Gym训练自己的agent。</p>\n<p>Gym目前提供python接口，并支持任何的计算框架，比如tensorflow、theano等。强化学习解决的是agent和环境交互的任务，agent根据当前环境状态做出某个动作，然后观察下一个状态和回报，环境根据agent的动作转移到下一个状态，并发送回报。Gym提供的实际上是环境这个角色，每个Gym环境都提供一致的接口。</p>\n<h3 id=\"创建一个gym环境\">创建一个Gym环境</h3>\n<p>创建一个环境时只需要指定环境id，比如agent需要玩Atari\nBreakout-v0这个游戏，可以如下创建一个Breakout-v0的环境。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gym</span><br><span class=\"line\">env = gym.make(<span class=\"string\">&#x27;Breakout-v0&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"step\">step</h3>\n<p>输入agent的动作，返回4个值，分别为：</p>\n<ul>\n<li>observation：表示agent观察到的下一个状态，比如在一些游戏中，observation为RGB的图像</li>\n<li>reward：表示执行输入的动作后得到的回报值</li>\n<li>done：表示返回的observation是不是结束状态</li>\n<li>info：调试信息，一般没什么用处</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next_state, reward, terminal, _ = env.step(action)</span><br></pre></td></tr></table></figure>\n<h3 id=\"reset\">reset</h3>\n<p>在开始一个新的episode时，Gym环境都要reset，获得一个初始状态。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_state = env.reset()</span><br></pre></td></tr></table></figure>\n<h3 id=\"render\">render</h3>\n<p>render是Gym用来渲染环境状态的函数，当调用该函数时会出现一个动图框。一般agent执行一个动作，环境都要渲染一次，这样就可以实时看到agent的执行情况了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env.render()</span><br></pre></td></tr></table></figure>\n<h3 id=\"spaces\">Spaces</h3>\n<p>Gym环境有两个space属性，一个是action_space，一个是observation_space，分别表示该Gym环境下合法的动作和状态。action_space是Gym中的一个Discrete对象，Discrete对象有一个成员n，表示合法的动作数，比如Discrete(2)表示有两个合法动作，编号从0开始，因此两个动作编号为0和1。observation_space是Gym中的一个Box对象，Box的shape表示observation的数据组织方式，比如Box(210,\n160,\n3)表示合法的observation是一个210*160*3的数组，而Box(4,)表示observation是一个大小为4的向量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">observation_space = env.observation_space <span class=\"comment\"># observation_space: Discrete(6)</span></span><br><span class=\"line\">action_space = env.action_space <span class=\"comment\"># action_space: Box(210, 160, 3)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"breakout-v0例子\">Breakout-v0例子</h3>\n<p>采用了github上Flood Sung的DQN实现，感谢Flood Sung大神的无私贡献。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -----------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># File: Deep Q-Learning Algorithm</span></span><br><span class=\"line\"><span class=\"comment\"># Author: Flood Sung</span></span><br><span class=\"line\"><span class=\"comment\"># Date: 2016.3.21</span></span><br><span class=\"line\"><span class=\"comment\"># -----------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Hyper Parameters:</span></span><br><span class=\"line\">FRAME_PER_ACTION = <span class=\"number\">1</span></span><br><span class=\"line\">GAMMA = <span class=\"number\">0.99</span> <span class=\"comment\"># decay rate of past observations</span></span><br><span class=\"line\">OBSERVE = <span class=\"number\">100.</span> <span class=\"comment\"># timesteps to observe before training</span></span><br><span class=\"line\">EXPLORE = <span class=\"number\">200000.</span> <span class=\"comment\"># frames over which to anneal epsilon</span></span><br><span class=\"line\">FINAL_EPSILON = <span class=\"number\">0</span><span class=\"comment\">#0.001 # final value of epsilon</span></span><br><span class=\"line\">INITIAL_EPSILON = <span class=\"number\">0</span><span class=\"comment\">#0.01 # starting value of epsilon</span></span><br><span class=\"line\">REPLAY_MEMORY = <span class=\"number\">50000</span> <span class=\"comment\"># number of previous transitions to remember</span></span><br><span class=\"line\">BATCH_SIZE = <span class=\"number\">32</span> <span class=\"comment\"># size of minibatch</span></span><br><span class=\"line\">UPDATE_TIME = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BrainDQN</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,actions</span>):</span><br><span class=\"line\">\t\t<span class=\"comment\"># init replay memory</span></span><br><span class=\"line\">\t\tself.replayMemory = deque()</span><br><span class=\"line\">\t\t<span class=\"comment\"># init some parameters</span></span><br><span class=\"line\">\t\tself.timeStep = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tself.epsilon = INITIAL_EPSILON</span><br><span class=\"line\">\t\tself.actions = actions</span><br><span class=\"line\">\t\t<span class=\"comment\"># init Q network</span></span><br><span class=\"line\">\t\tself.stateInput,self.QValue,self.W_conv1,self.b_conv1,self.W_conv2,self.b_conv2,self.W_conv3,self.b_conv3,self.W_fc1,self.b_fc1,self.W_fc2,self.b_fc2 = self.createQNetwork()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># init Target Q Network</span></span><br><span class=\"line\">\t\tself.stateInputT,self.QValueT,self.W_conv1T,self.b_conv1T,self.W_conv2T,self.b_conv2T,self.W_conv3T,self.b_conv3T,self.W_fc1T,self.b_fc1T,self.W_fc2T,self.b_fc2T = self.createQNetwork()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.copyTargetQNetworkOperation = [self.W_conv1T.assign(self.W_conv1),self.b_conv1T.assign(self.b_conv1),self.W_conv2T.assign(self.W_conv2),self.b_conv2T.assign(self.b_conv2),self.W_conv3T.assign(self.W_conv3),self.b_conv3T.assign(self.b_conv3),self.W_fc1T.assign(self.W_fc1),self.b_fc1T.assign(self.b_fc1),self.W_fc2T.assign(self.W_fc2),self.b_fc2T.assign(self.b_fc2)]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.createTrainingMethod()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># saving and loading networks</span></span><br><span class=\"line\">\t\tself.saver = tf.train.Saver()</span><br><span class=\"line\">\t\tself.session = tf.InteractiveSession()</span><br><span class=\"line\">\t\tself.session.run(tf.initialize_all_variables())</span><br><span class=\"line\">\t\tcheckpoint = tf.train.get_checkpoint_state(<span class=\"string\">&quot;saved_networks&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> checkpoint <span class=\"keyword\">and</span> checkpoint.model_checkpoint_path:</span><br><span class=\"line\">\t\t\t\tself.saver.restore(self.session, checkpoint.model_checkpoint_path)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">print</span> <span class=\"string\">&quot;Successfully loaded:&quot;</span>, checkpoint.model_checkpoint_path</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">print</span> <span class=\"string\">&quot;Could not find old network weights&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">createQNetwork</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\t<span class=\"comment\"># network weights</span></span><br><span class=\"line\">\t\tW_conv1 = self.weight_variable([<span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">32</span>])</span><br><span class=\"line\">\t\tb_conv1 = self.bias_variable([<span class=\"number\">32</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tW_conv2 = self.weight_variable([<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">32</span>,<span class=\"number\">64</span>])</span><br><span class=\"line\">\t\tb_conv2 = self.bias_variable([<span class=\"number\">64</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tW_conv3 = self.weight_variable([<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">64</span>,<span class=\"number\">64</span>])</span><br><span class=\"line\">\t\tb_conv3 = self.bias_variable([<span class=\"number\">64</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tW_fc1 = self.weight_variable([<span class=\"number\">1600</span>,<span class=\"number\">512</span>])</span><br><span class=\"line\">\t\tb_fc1 = self.bias_variable([<span class=\"number\">512</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tW_fc2 = self.weight_variable([<span class=\"number\">512</span>,self.actions])</span><br><span class=\"line\">\t\tb_fc2 = self.bias_variable([self.actions])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># input layer</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tstateInput = tf.placeholder(<span class=\"string\">&quot;float&quot;</span>,[<span class=\"literal\">None</span>,<span class=\"number\">80</span>,<span class=\"number\">80</span>,<span class=\"number\">4</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># hidden layers</span></span><br><span class=\"line\">\t\th_conv1 = tf.nn.relu(self.conv2d(stateInput,W_conv1,<span class=\"number\">4</span>) + b_conv1)</span><br><span class=\"line\">\t\th_pool1 = self.max_pool_2x2(h_conv1)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\th_conv2 = tf.nn.relu(self.conv2d(h_pool1,W_conv2,<span class=\"number\">2</span>) + b_conv2)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\th_conv3 = tf.nn.relu(self.conv2d(h_conv2,W_conv3,<span class=\"number\">1</span>) + b_conv3)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\th_conv3_flat = tf.reshape(h_conv3,[-<span class=\"number\">1</span>,<span class=\"number\">1600</span>])</span><br><span class=\"line\">\t\th_fc1 = tf.nn.relu(tf.matmul(h_conv3_flat,W_fc1) + b_fc1)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># Q Value layer</span></span><br><span class=\"line\">\t\tQValue = tf.matmul(h_fc1,W_fc2) + b_fc2</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> stateInput,QValue,W_conv1,b_conv1,W_conv2,b_conv2,W_conv3,b_conv3,W_fc1,b_fc1,W_fc2,b_fc2</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">copyTargetQNetwork</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\tself.session.run(self.copyTargetQNetworkOperation)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">createTrainingMethod</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\tself.actionInput = tf.placeholder(<span class=\"string\">&quot;float&quot;</span>,[<span class=\"literal\">None</span>,self.actions])</span><br><span class=\"line\">\t\tself.yInput = tf.placeholder(<span class=\"string\">&quot;float&quot;</span>, [<span class=\"literal\">None</span>])</span><br><span class=\"line\">\t\tQ_Action = tf.reduce_sum(tf.mul(self.QValue, self.actionInput), reduction_indices = <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tself.cost = tf.reduce_mean(tf.square(self.yInput - Q_Action))</span><br><span class=\"line\">\t\tself.trainStep = tf.train.AdamOptimizer(<span class=\"number\">1e-6</span>).minimize(self.cost)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">trainQNetwork</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\t<span class=\"comment\"># Step 1: obtain random minibatch from replay memory</span></span><br><span class=\"line\">\t\tminibatch = random.sample(self.replayMemory,BATCH_SIZE)</span><br><span class=\"line\">\t\tstate_batch = [data[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> minibatch]</span><br><span class=\"line\">\t\taction_batch = [data[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> minibatch]</span><br><span class=\"line\">\t\treward_batch = [data[<span class=\"number\">2</span>] <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> minibatch]</span><br><span class=\"line\">\t\tnextState_batch = [data[<span class=\"number\">3</span>] <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> minibatch]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># Step 2: calculate y</span></span><br><span class=\"line\">\t\ty_batch = []</span><br><span class=\"line\">\t\tQValue_batch = self.QValueT.<span class=\"built_in\">eval</span>(feed_dict=&#123;self.stateInputT:nextState_batch&#125;)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>,BATCH_SIZE):</span><br><span class=\"line\">\t\t\tterminal = minibatch[i][<span class=\"number\">4</span>]</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> terminal:</span><br><span class=\"line\">\t\t\t\ty_batch.append(reward_batch[i])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\ty_batch.append(reward_batch[i] + GAMMA * np.<span class=\"built_in\">max</span>(QValue_batch[i]))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.trainStep.run(feed_dict=&#123;</span><br><span class=\"line\">\t\t\tself.yInput : y_batch,</span><br><span class=\"line\">\t\t\tself.actionInput : action_batch,</span><br><span class=\"line\">\t\t\tself.stateInput : state_batch</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># save network every 100000 iteration</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep % <span class=\"number\">10000</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\tself.saver.save(self.session, <span class=\"string\">&#x27;saved_networks/&#x27;</span> + <span class=\"string\">&#x27;network&#x27;</span> + <span class=\"string\">&#x27;-dqn&#x27;</span>, global_step = self.timeStep)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep % UPDATE_TIME == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\tself.copyTargetQNetwork()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">setPerception</span>(<span class=\"params\">self,nextObservation,action,reward,terminal</span>):</span><br><span class=\"line\">\t\t<span class=\"comment\">#newState = np.append(nextObservation,self.currentState[:,:,1:],axis = 2)</span></span><br><span class=\"line\">\t\tnewState = np.append(self.currentState[:,:,<span class=\"number\">1</span>:],nextObservation,axis = <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\tself.replayMemory.append((self.currentState,action,reward,newState,terminal))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(self.replayMemory) &gt; REPLAY_MEMORY:</span><br><span class=\"line\">\t\t\tself.replayMemory.popleft()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep &gt; OBSERVE:</span><br><span class=\"line\">\t\t\t<span class=\"comment\"># Train the network</span></span><br><span class=\"line\">\t\t\tself.trainQNetwork()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># print info</span></span><br><span class=\"line\">\t\tstate = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep &lt;= OBSERVE:</span><br><span class=\"line\">\t\t\tstate = <span class=\"string\">&quot;observe&quot;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">elif</span> self.timeStep &gt; OBSERVE <span class=\"keyword\">and</span> self.timeStep &lt;= OBSERVE + EXPLORE:</span><br><span class=\"line\">\t\t\tstate = <span class=\"string\">&quot;explore&quot;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\tstate = <span class=\"string\">&quot;train&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span> <span class=\"string\">&quot;TIMESTEP&quot;</span>, self.timeStep, <span class=\"string\">&quot;/ STATE&quot;</span>, state, \\</span><br><span class=\"line\">            <span class=\"string\">&quot;/ EPSILON&quot;</span>, self.epsilon</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.currentState = newState</span><br><span class=\"line\">\t\tself.timeStep += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">getAction</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">\t\tQValue = self.QValue.<span class=\"built_in\">eval</span>(feed_dict= &#123;self.stateInput:[self.currentState]&#125;)[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\taction = np.zeros(self.actions)</span><br><span class=\"line\">\t\taction_index = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.timeStep % FRAME_PER_ACTION == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> random.random() &lt;= self.epsilon:</span><br><span class=\"line\">\t\t\t\taction_index = random.randrange(self.actions)</span><br><span class=\"line\">\t\t\t\taction[action_index] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\t\taction_index = np.argmax(QValue)</span><br><span class=\"line\">\t\t\t\taction[action_index] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\taction[<span class=\"number\">0</span>] = <span class=\"number\">1</span> <span class=\"comment\"># do nothing</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># change episilon</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.epsilon &gt; FINAL_EPSILON <span class=\"keyword\">and</span> self.timeStep &gt; OBSERVE:</span><br><span class=\"line\">\t\t\tself.epsilon -= (INITIAL_EPSILON - FINAL_EPSILON)/EXPLORE</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> action</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">setInitState</span>(<span class=\"params\">self,observation</span>):</span><br><span class=\"line\">\t\tself.currentState = np.stack((observation, observation, observation, observation), axis = <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">weight_variable</span>(<span class=\"params\">self,shape</span>):</span><br><span class=\"line\">\t\tinitial = tf.truncated_normal(shape, stddev = <span class=\"number\">0.01</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tf.Variable(initial)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">bias_variable</span>(<span class=\"params\">self,shape</span>):</span><br><span class=\"line\">\t\tinitial = tf.constant(<span class=\"number\">0.01</span>, shape = shape)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tf.Variable(initial)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">conv2d</span>(<span class=\"params\">self,x, W, stride</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tf.nn.conv2d(x, W, strides = [<span class=\"number\">1</span>, stride, stride, <span class=\"number\">1</span>], padding = <span class=\"string\">&quot;SAME&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">max_pool_2x2</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tf.nn.max_pool(x, ksize = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>], strides = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>], padding = <span class=\"string\">&quot;SAME&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>下面是使用上面的DQN让agent玩Gym的Breakout-v0游戏。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Project: Deep Q-Learning on Breakout-v0</span></span><br><span class=\"line\"><span class=\"comment\"># Author: Houjiang Chen</span></span><br><span class=\"line\"><span class=\"comment\"># Date: 2017.4.25</span></span><br><span class=\"line\"><span class=\"comment\"># -------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> gym</span><br><span class=\"line\"><span class=\"keyword\">from</span> BrainDQN_Nature <span class=\"keyword\">import</span> BrainDQN</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># preprocess raw image to 80*80 gray image</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">preprocess</span>(<span class=\"params\">observation</span>):</span><br><span class=\"line\">    observation = cv2.cvtColor(cv2.resize(observation, (<span class=\"number\">80</span>, <span class=\"number\">80</span>)), cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    <span class=\"comment\">#ret, observation = cv2.threshold(observation, 1, 255, cv2.THRESH_BINARY)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.reshape(observation, (<span class=\"number\">80</span>, <span class=\"number\">80</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play</span>():</span><br><span class=\"line\">    env = gym.make(<span class=\"string\">&#x27;Breakout-v0&#x27;</span>)</span><br><span class=\"line\">    actions = env.action_space.n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># init BrainDQN</span></span><br><span class=\"line\">    brain = BrainDQN(actions)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        state = env.reset()</span><br><span class=\"line\">        state = cv2.cvtColor(cv2.resize(state, (<span class=\"number\">80</span>, <span class=\"number\">80</span>)), cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">        <span class=\"comment\">#ret, state = cv2.threshold(state, 1, 255, cv2.THRESH_BINARY)</span></span><br><span class=\"line\">        brain.setInitState(state)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            action = brain.getAction()</span><br><span class=\"line\">            state, reward, terminal, _ = env.step(np.argmax(action))</span><br><span class=\"line\">            env.render()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> terminal:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            state = preprocess(state)</span><br><span class=\"line\">            brain.setPerception(state, action, reward, terminal)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    play()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>1、Reinforcement Learning: An Introduction, Richard S. Sutton and\nAndrew G. Barto，2012<br />\n2、Playing Atari with Deep Reinforcement Learning，DeepMind\nTechnologies，Arxiv 2013.12<br />\n3、Human-level control through deep reinforcement learning，DeepMind\nTechnologies，Nature 2015.02<br />\n4、DeepMind官网\nhttps://deepmind.com/blog/deep-reinforcement-learning<br />\n5、https://www.nervanasys.com/demystifying-deep-reinforcement-learning<br />\n6、http://www.cnblogs.com/jinxulin/p/3511298.html<br />\n7、Introduction to Reinforcement Learning，David Silver</p>"},{"title":"FusionStitching, Deep Fusion and Code Generation for Tensorflow Computations on GPUs","date":"2019-11-27T04:00:04.000Z","_content":"\n## FusionStitching系统概述\n\n![屏幕快照 2019-11-25 13.56.40](https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-25%2013.56.40.png?raw=true)\n\n输入HloModule，经过以下三个阶段，最终输出LLVM IR。\n\n- Computation Fusion\n- Schedule Planning\n- Code Generation\n\n论文主要针对XLA Fusion算法进行了改进，提出了实现Block合并策略的Schedule和Shared Memory Planning技术，以及实现对应的IR Emitter。\n\n<!-- more -->\n\n## Computation Fusion\n\n利用Work/Span analysis，将instruction划分到不同的layer，然后Deep Fusion模块在Schedule Consistency Checker的指导下完成跨layer的instruction合并。该过程是迭代进行的，直到完全没有合并机会。\n\n### Work/Span analysis\n\n> Work/Span analysis通常用于并行算法的分析。假设每个基本运算执行时间都是单位时间，则Work表示的是所有基本运算时间总和，Span表示最长依赖路径上的基本运算时间总和。对于一个计算图来说，可以简单认为图中所有的计算节点总执行时间表示Work，而计算图的最大深度的路径上的节点的顺序执行总时间表示Span。\n\n在这里作者用Span来表示每个节点到root节点的深度。\n\n![屏幕快照 2019-11-26 18.28.17](https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-26%2018.28.17.png?raw=true)\n\n经过Work/Span analysis后，HloModule中的Instruction被划分到了不同的layer，相同Span值的Instruction的layer相同，并且同一layer的Instruction没有依赖关系。\n\n### Subgraph Fusion Algorithm\n\n基于Work/Span analysis计算得到的Span值，作者提出了不同于XLA的Fusion算法。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-26%2019.44.59.png?raw=true\" width=600/>\n\nSchdConsistent用来判断fusion_root和hlo是否应该合并，其具体的执行逻辑如下：\n\n1. 如果hlo有一个consumer在giveup集合中，为了防止潜在的循环依赖，放弃fusion。\n2. 如果hlo的所有consumer都不在fused集合中，则放弃fusion，因为这里只考虑Producer/Consumer的合并，没有消费关系的Instruction合并则会在ElementwiseFusion算法中处理。\n3. 最后会判断合并后的Computation是否存在一个可行的optimized shedule。如果不存在，则放弃fusion。\n\n> - 算法简单高效，Work/Span Analysis的作用其实相当于对Instruction做了一遍拓扑排序，通过简单的合并规则确保circle free。\n> - 不区分expensive op，可以通过shared memory来缓存中间结果，因此不需要重计算。\n> - 由于第一条约束的强制性，导致合并不完全。\n\n## Schedule Planning\n\n### Schedule定义\n\n> Schedule通常指的是将算法指定的计算过程分配给计算资源的方法。这些计算过程可能包括线程、进程以及数据流等。\n>\n> 常见的一些Schedule配置:\n> - Reorder\n> 循环顺序重排，比如for x for y -> for y for x\n> - Tile\n> - Unroll\n> - Vectorize\n> - Parallel\n> - some CUDA-specific\n> 比如blocks、threads、shared memory size等。\n>\n> 对于包含多个计算stage的算法，Schedule通常是由Consumer驱动，并指定何时对Consumer计算Producer（**Specify when the producer is computed with respect to the consumer** ）。\n\n论文中将Instruction大致分成Elementwise、Transpose、Reduce、BatchDot、Reshape和Broadcast这几种，然后基于这些op定义了一套用来表示对数据分块的Shedule配置。通过一个定义好的Shedule配置和数据的shape，我们就可以知道需要切成多少个数据块，映射到GPU硬件上就是多少个线程块（thread blocks）。\n\n![屏幕快照 2019-11-27 11.22.57](https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2011.22.57.png?raw=true)\n\nShedule定义在输出shape上，包含三个字段：split_dim、sword和sched_type。split_dim表示切割的维度，取值[0, num_dims)。sword表示在split_dim维度上切分多少块，sword要求能被split_dim维度K整除。sched_type表示行切割还是列切割，取值Row或者Column。给定一个Instruction，其Schedule空间即所有合法的三元组（split_dim、sword和sched_type）。\n\n上图表示Reduce Instruction的两种合法Schedule，通过split_dim和reduce dim来区分Row Schedule和Column Schedule。\n\n### Schedule约束和传播\n\n与Instruction的Schedule定义在输出shape上一样，Computation的Schedule也定义在Root Instruction的输出上，因为Root Instruction是整个Computation的输出。   \n对于一个Fused Computation，需要满足Shedule相容约束：即对于Root Instruction，给定一个合法的Shedule，该Shedule需要同时被其他Instruction相容。论文中提出后向传播的方法来判断Shedule约束的相容性。   \n任意一个Instruction，其合法的Schedule可以根据Instruction类型和output shape来确定。如果给定的Schedule满足约束（是合法的），则把Schedule后向传播到输入shape(s)，也就是输入Instruction的输出shape。否则从Root Instruction传播过来的Schedule在整个Fused Compution上不满足相容性约束。\n\n> 在Subgraph Fusion算法中，两个Instruction能否合并除了需要满足circle free约束外，还需要满足后端CodeGen模块的支持。只有Schedule满足约束，CodeGen才能正确发射代码，否则CodeGen无法处理。\n\n![屏幕快照 2019-11-27 13.53.21](https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2013.53.21.png?raw=true)\n\nTable.1表明了不同Instruction的Schedule后向传播规则。Schedule约束判断结果会反馈到Subgraph Fusion过程，Fusion不应该破坏Schedule相容性约束。\n\n### Schedule Tuning\n\n任意一个Instruction，split_dim=0和sword=1的Row Schedule总是合法的，也就是只有一个数据块，并且只用一个GPU线程块来计算。这样做的问题也很明显，就是无法充分利用GPU硬件资源。每个Instruction可能有多个合法的Schedule，Schedule Tuning用来选择一个合适的Schedule。  \n如果Computation中只有一个Root，遍历该Root Instructon所有合法的满足约束的Schedule，在performance library中查找每个kernel的执行时间，并统计总耗时。总耗时最少的Schedule会被选择用来Code Generation。\n\n如果Computation中有多个Roots，则采取一种two-stage的方法加速Schedule的搜索过程。  \n第一步：遍历所有的Roots，计算blocks和blocks对应的Schedule两个序列。对所有Roots对应的blocks序列求交集，结果对应的Schedule即合法的候选Schedule。  \n第二步：遍历所有的候选Schedule，计算每个Schedule下所有kernel的耗时，选择耗时最少的Schedule。论文中还提到可以忽略部分ops和early stop的搜索策略，加速第二步的搜索过程。\n\n## Code Generation\n\n### Shared Memory Planning\n\n标记出所有可能需要用到Shared Memory的候选ops，当Memory不足时优先满足most critical ops。\n\n- Size Requirement Analysis\n\n  1. 直接分配\n     对于非Root Instruction的Reduce和BatchDot，必须将中间结果放在Shared Memory，allowing consumer ops to use seperate parallel loop emitters to generate code。\n\n  2. 按优先级分配\n     对于有多个Users的Elementwise op，为了避免重计算，可以选择将结果缓存到Shared Memory。在memory受限的情况下，按照优先级（expensive op > 非expensive op）确定使用Shared Memory。  \n     有时对于只有一个User的expensive op也需要用到Shared Memory，比如如果expensive op后面接了一个BatchDot，由于BatchDot本身对数据的复用性比较高，将expensive op的结果缓存到Shared Memory会带来非常好的性能优化。\n\n- Size Shrinking\n\n  Size Shrinking与上面Requirement Analysis的第2点类似。当每个线程Block分到的数据块非常大时，可能存在Shared Memory受限的问题。解决办法就是让一些ops退化为重计算。  \n  从inexpensive ops开始，然后expensive ops，之后是带有BtachDot的expensive ops，最后按照靠近Root Instruction的程度选择候选ops，并优先选择靠近输出的ops。\n\n- Space Sharing\n\n  不同ops分配的Shared Memory是可以复用的，论文中作者提出从Root Instruction开始构造一颗支配树，支配节点可以复用被支配节点申请的Shared Memory。\n\n### Code Generation\n\nXLA使用GpuElementalIrEmitter来实现线程合并的Computation。基于XLA的GpuElementalIrEmitter，作者实现了用于Block合并的IrEmitter (论文中称作IrEmitterStitched)。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2017.26.12.png?raw=true\" width=600/>\n\nIrEmitterStitched输入有hlo、root、shared、schedule和generators。\n\n- hlo: 待处理的hlo Instruction\n- root: 是否是root Instruction\n- shared: 是否将输出写到shared memory\n- shedule: row schedule还是column schedule\n- generators：与XLA GpuElementalIrEmitter中的generators_类似，但是能处理shared memory的情况。\n\n基本逻辑如下：\n\n1. 如果待处理的Instruction不是root Instruction，并且没有用到Shared Memory，不是Dot和Reduce Opcode，则回退到XLA的GpuElementalIrEmitter中去处理，否则使用IrEmitterStitched发射LLVM代码。\n2. 如果需要用到Shared Memory，则调用EmitWriteSharedArray将结果写到Shared Memory。\n3. 如果是root Instruction，则调用EmitWriteOutputArray将结果写到Global Memory。如果不是root Instruction，则调用EmitGenerator在generators中创建一个entry，以支持当前Instruction与其他Instruction的合并。\n\n\n\n## XLA op fusion规则\n\n- Consumer本身支持合并\n\n  特定op不支持与Producer合并，比如Parameter、While、Conditional、Call等，以及op本身has a side effect或者调用了has a side effect的op。此外被标记为tracing的op也无法合并。\n\n- Consumer与Producer之间支持合并\n\n  - Consumer和Producer之间所有的op均可以被合并到Consumer。\n  - 对于Consumer和Producer之间所有的op：\n    1. 如果直接Producer已经是一个Fusion op，则不能合并。\n    2. 对Reduce和Scatter，以及CustomCall/LibraryCall的一些限制。\n    3. 如果直接Producer有其他Consumer，则Fusion会导致该Producer 需要重计算。如果Producer属于expensive op或为Parameter op则放弃合并。\n","source":"_posts/DeepFusion.md","raw":"---\ntitle: FusionStitching, Deep Fusion and Code Generation for Tensorflow Computations on GPUs\n\ndate: 2019-11-27 12:00:04\n\ncategory: DL Compiler\n\ntags: [XLA, Deep Learning Compiler, FusionStitching]\n\n---\n\n## FusionStitching系统概述\n\n![屏幕快照 2019-11-25 13.56.40](https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-25%2013.56.40.png?raw=true)\n\n输入HloModule，经过以下三个阶段，最终输出LLVM IR。\n\n- Computation Fusion\n- Schedule Planning\n- Code Generation\n\n论文主要针对XLA Fusion算法进行了改进，提出了实现Block合并策略的Schedule和Shared Memory Planning技术，以及实现对应的IR Emitter。\n\n<!-- more -->\n\n## Computation Fusion\n\n利用Work/Span analysis，将instruction划分到不同的layer，然后Deep Fusion模块在Schedule Consistency Checker的指导下完成跨layer的instruction合并。该过程是迭代进行的，直到完全没有合并机会。\n\n### Work/Span analysis\n\n> Work/Span analysis通常用于并行算法的分析。假设每个基本运算执行时间都是单位时间，则Work表示的是所有基本运算时间总和，Span表示最长依赖路径上的基本运算时间总和。对于一个计算图来说，可以简单认为图中所有的计算节点总执行时间表示Work，而计算图的最大深度的路径上的节点的顺序执行总时间表示Span。\n\n在这里作者用Span来表示每个节点到root节点的深度。\n\n![屏幕快照 2019-11-26 18.28.17](https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-26%2018.28.17.png?raw=true)\n\n经过Work/Span analysis后，HloModule中的Instruction被划分到了不同的layer，相同Span值的Instruction的layer相同，并且同一layer的Instruction没有依赖关系。\n\n### Subgraph Fusion Algorithm\n\n基于Work/Span analysis计算得到的Span值，作者提出了不同于XLA的Fusion算法。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-26%2019.44.59.png?raw=true\" width=600/>\n\nSchdConsistent用来判断fusion_root和hlo是否应该合并，其具体的执行逻辑如下：\n\n1. 如果hlo有一个consumer在giveup集合中，为了防止潜在的循环依赖，放弃fusion。\n2. 如果hlo的所有consumer都不在fused集合中，则放弃fusion，因为这里只考虑Producer/Consumer的合并，没有消费关系的Instruction合并则会在ElementwiseFusion算法中处理。\n3. 最后会判断合并后的Computation是否存在一个可行的optimized shedule。如果不存在，则放弃fusion。\n\n> - 算法简单高效，Work/Span Analysis的作用其实相当于对Instruction做了一遍拓扑排序，通过简单的合并规则确保circle free。\n> - 不区分expensive op，可以通过shared memory来缓存中间结果，因此不需要重计算。\n> - 由于第一条约束的强制性，导致合并不完全。\n\n## Schedule Planning\n\n### Schedule定义\n\n> Schedule通常指的是将算法指定的计算过程分配给计算资源的方法。这些计算过程可能包括线程、进程以及数据流等。\n>\n> 常见的一些Schedule配置:\n> - Reorder\n> 循环顺序重排，比如for x for y -> for y for x\n> - Tile\n> - Unroll\n> - Vectorize\n> - Parallel\n> - some CUDA-specific\n> 比如blocks、threads、shared memory size等。\n>\n> 对于包含多个计算stage的算法，Schedule通常是由Consumer驱动，并指定何时对Consumer计算Producer（**Specify when the producer is computed with respect to the consumer** ）。\n\n论文中将Instruction大致分成Elementwise、Transpose、Reduce、BatchDot、Reshape和Broadcast这几种，然后基于这些op定义了一套用来表示对数据分块的Shedule配置。通过一个定义好的Shedule配置和数据的shape，我们就可以知道需要切成多少个数据块，映射到GPU硬件上就是多少个线程块（thread blocks）。\n\n![屏幕快照 2019-11-27 11.22.57](https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2011.22.57.png?raw=true)\n\nShedule定义在输出shape上，包含三个字段：split_dim、sword和sched_type。split_dim表示切割的维度，取值[0, num_dims)。sword表示在split_dim维度上切分多少块，sword要求能被split_dim维度K整除。sched_type表示行切割还是列切割，取值Row或者Column。给定一个Instruction，其Schedule空间即所有合法的三元组（split_dim、sword和sched_type）。\n\n上图表示Reduce Instruction的两种合法Schedule，通过split_dim和reduce dim来区分Row Schedule和Column Schedule。\n\n### Schedule约束和传播\n\n与Instruction的Schedule定义在输出shape上一样，Computation的Schedule也定义在Root Instruction的输出上，因为Root Instruction是整个Computation的输出。   \n对于一个Fused Computation，需要满足Shedule相容约束：即对于Root Instruction，给定一个合法的Shedule，该Shedule需要同时被其他Instruction相容。论文中提出后向传播的方法来判断Shedule约束的相容性。   \n任意一个Instruction，其合法的Schedule可以根据Instruction类型和output shape来确定。如果给定的Schedule满足约束（是合法的），则把Schedule后向传播到输入shape(s)，也就是输入Instruction的输出shape。否则从Root Instruction传播过来的Schedule在整个Fused Compution上不满足相容性约束。\n\n> 在Subgraph Fusion算法中，两个Instruction能否合并除了需要满足circle free约束外，还需要满足后端CodeGen模块的支持。只有Schedule满足约束，CodeGen才能正确发射代码，否则CodeGen无法处理。\n\n![屏幕快照 2019-11-27 13.53.21](https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2013.53.21.png?raw=true)\n\nTable.1表明了不同Instruction的Schedule后向传播规则。Schedule约束判断结果会反馈到Subgraph Fusion过程，Fusion不应该破坏Schedule相容性约束。\n\n### Schedule Tuning\n\n任意一个Instruction，split_dim=0和sword=1的Row Schedule总是合法的，也就是只有一个数据块，并且只用一个GPU线程块来计算。这样做的问题也很明显，就是无法充分利用GPU硬件资源。每个Instruction可能有多个合法的Schedule，Schedule Tuning用来选择一个合适的Schedule。  \n如果Computation中只有一个Root，遍历该Root Instructon所有合法的满足约束的Schedule，在performance library中查找每个kernel的执行时间，并统计总耗时。总耗时最少的Schedule会被选择用来Code Generation。\n\n如果Computation中有多个Roots，则采取一种two-stage的方法加速Schedule的搜索过程。  \n第一步：遍历所有的Roots，计算blocks和blocks对应的Schedule两个序列。对所有Roots对应的blocks序列求交集，结果对应的Schedule即合法的候选Schedule。  \n第二步：遍历所有的候选Schedule，计算每个Schedule下所有kernel的耗时，选择耗时最少的Schedule。论文中还提到可以忽略部分ops和early stop的搜索策略，加速第二步的搜索过程。\n\n## Code Generation\n\n### Shared Memory Planning\n\n标记出所有可能需要用到Shared Memory的候选ops，当Memory不足时优先满足most critical ops。\n\n- Size Requirement Analysis\n\n  1. 直接分配\n     对于非Root Instruction的Reduce和BatchDot，必须将中间结果放在Shared Memory，allowing consumer ops to use seperate parallel loop emitters to generate code。\n\n  2. 按优先级分配\n     对于有多个Users的Elementwise op，为了避免重计算，可以选择将结果缓存到Shared Memory。在memory受限的情况下，按照优先级（expensive op > 非expensive op）确定使用Shared Memory。  \n     有时对于只有一个User的expensive op也需要用到Shared Memory，比如如果expensive op后面接了一个BatchDot，由于BatchDot本身对数据的复用性比较高，将expensive op的结果缓存到Shared Memory会带来非常好的性能优化。\n\n- Size Shrinking\n\n  Size Shrinking与上面Requirement Analysis的第2点类似。当每个线程Block分到的数据块非常大时，可能存在Shared Memory受限的问题。解决办法就是让一些ops退化为重计算。  \n  从inexpensive ops开始，然后expensive ops，之后是带有BtachDot的expensive ops，最后按照靠近Root Instruction的程度选择候选ops，并优先选择靠近输出的ops。\n\n- Space Sharing\n\n  不同ops分配的Shared Memory是可以复用的，论文中作者提出从Root Instruction开始构造一颗支配树，支配节点可以复用被支配节点申请的Shared Memory。\n\n### Code Generation\n\nXLA使用GpuElementalIrEmitter来实现线程合并的Computation。基于XLA的GpuElementalIrEmitter，作者实现了用于Block合并的IrEmitter (论文中称作IrEmitterStitched)。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2017.26.12.png?raw=true\" width=600/>\n\nIrEmitterStitched输入有hlo、root、shared、schedule和generators。\n\n- hlo: 待处理的hlo Instruction\n- root: 是否是root Instruction\n- shared: 是否将输出写到shared memory\n- shedule: row schedule还是column schedule\n- generators：与XLA GpuElementalIrEmitter中的generators_类似，但是能处理shared memory的情况。\n\n基本逻辑如下：\n\n1. 如果待处理的Instruction不是root Instruction，并且没有用到Shared Memory，不是Dot和Reduce Opcode，则回退到XLA的GpuElementalIrEmitter中去处理，否则使用IrEmitterStitched发射LLVM代码。\n2. 如果需要用到Shared Memory，则调用EmitWriteSharedArray将结果写到Shared Memory。\n3. 如果是root Instruction，则调用EmitWriteOutputArray将结果写到Global Memory。如果不是root Instruction，则调用EmitGenerator在generators中创建一个entry，以支持当前Instruction与其他Instruction的合并。\n\n\n\n## XLA op fusion规则\n\n- Consumer本身支持合并\n\n  特定op不支持与Producer合并，比如Parameter、While、Conditional、Call等，以及op本身has a side effect或者调用了has a side effect的op。此外被标记为tracing的op也无法合并。\n\n- Consumer与Producer之间支持合并\n\n  - Consumer和Producer之间所有的op均可以被合并到Consumer。\n  - 对于Consumer和Producer之间所有的op：\n    1. 如果直接Producer已经是一个Fusion op，则不能合并。\n    2. 对Reduce和Scatter，以及CustomCall/LibraryCall的一些限制。\n    3. 如果直接Producer有其他Consumer，则Fusion会导致该Producer 需要重计算。如果Producer属于expensive op或为Parameter op则放弃合并。\n","slug":"DeepFusion","published":1,"updated":"2023-01-03T14:04:24.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgb13ud0000j6eqcpb90er7","content":"<h2 id=\"fusionstitching系统概述\">FusionStitching系统概述</h2>\n<figure>\n<img\nsrc=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-25%2013.56.40.png?raw=true\"\nalt=\"屏幕快照 2019-11-25 13.56.40\" />\n<figcaption aria-hidden=\"true\">屏幕快照 2019-11-25 13.56.40</figcaption>\n</figure>\n<p>输入HloModule，经过以下三个阶段，最终输出LLVM IR。</p>\n<ul>\n<li>Computation Fusion</li>\n<li>Schedule Planning</li>\n<li>Code Generation</li>\n</ul>\n<p>论文主要针对XLA\nFusion算法进行了改进，提出了实现Block合并策略的Schedule和Shared Memory\nPlanning技术，以及实现对应的IR Emitter。</p>\n<span id=\"more\"></span>\n<h2 id=\"computation-fusion\">Computation Fusion</h2>\n<p>利用Work/Span analysis，将instruction划分到不同的layer，然后Deep\nFusion模块在Schedule Consistency\nChecker的指导下完成跨layer的instruction合并。该过程是迭代进行的，直到完全没有合并机会。</p>\n<h3 id=\"workspan-analysis\">Work/Span analysis</h3>\n<blockquote>\n<p>Work/Span\nanalysis通常用于并行算法的分析。假设每个基本运算执行时间都是单位时间，则Work表示的是所有基本运算时间总和，Span表示最长依赖路径上的基本运算时间总和。对于一个计算图来说，可以简单认为图中所有的计算节点总执行时间表示Work，而计算图的最大深度的路径上的节点的顺序执行总时间表示Span。</p>\n</blockquote>\n<p>在这里作者用Span来表示每个节点到root节点的深度。</p>\n<figure>\n<img\nsrc=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-26%2018.28.17.png?raw=true\"\nalt=\"屏幕快照 2019-11-26 18.28.17\" />\n<figcaption aria-hidden=\"true\">屏幕快照 2019-11-26 18.28.17</figcaption>\n</figure>\n<p>经过Work/Span\nanalysis后，HloModule中的Instruction被划分到了不同的layer，相同Span值的Instruction的layer相同，并且同一layer的Instruction没有依赖关系。</p>\n<h3 id=\"subgraph-fusion-algorithm\">Subgraph Fusion Algorithm</h3>\n<p>基于Work/Span\nanalysis计算得到的Span值，作者提出了不同于XLA的Fusion算法。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-26%2019.44.59.png?raw=true\" width=600/></p>\n<p>SchdConsistent用来判断fusion_root和hlo是否应该合并，其具体的执行逻辑如下：</p>\n<ol type=\"1\">\n<li>如果hlo有一个consumer在giveup集合中，为了防止潜在的循环依赖，放弃fusion。</li>\n<li>如果hlo的所有consumer都不在fused集合中，则放弃fusion，因为这里只考虑Producer/Consumer的合并，没有消费关系的Instruction合并则会在ElementwiseFusion算法中处理。</li>\n<li>最后会判断合并后的Computation是否存在一个可行的optimized\nshedule。如果不存在，则放弃fusion。</li>\n</ol>\n<blockquote>\n<ul>\n<li>算法简单高效，Work/Span\nAnalysis的作用其实相当于对Instruction做了一遍拓扑排序，通过简单的合并规则确保circle\nfree。</li>\n<li>不区分expensive op，可以通过shared\nmemory来缓存中间结果，因此不需要重计算。</li>\n<li>由于第一条约束的强制性，导致合并不完全。</li>\n</ul>\n</blockquote>\n<h2 id=\"schedule-planning\">Schedule Planning</h2>\n<h3 id=\"schedule定义\">Schedule定义</h3>\n<blockquote>\n<p>Schedule通常指的是将算法指定的计算过程分配给计算资源的方法。这些计算过程可能包括线程、进程以及数据流等。</p>\n<p>常见的一些Schedule配置: - Reorder 循环顺序重排，比如for x for y -&gt;\nfor y for x - Tile - Unroll - Vectorize - Parallel - some CUDA-specific\n比如blocks、threads、shared memory size等。</p>\n<p>对于包含多个计算stage的算法，Schedule通常是由Consumer驱动，并指定何时对Consumer计算Producer（<strong>Specify\nwhen the producer is computed with respect to the consumer</strong>\n）。</p>\n</blockquote>\n<p>论文中将Instruction大致分成Elementwise、Transpose、Reduce、BatchDot、Reshape和Broadcast这几种，然后基于这些op定义了一套用来表示对数据分块的Shedule配置。通过一个定义好的Shedule配置和数据的shape，我们就可以知道需要切成多少个数据块，映射到GPU硬件上就是多少个线程块（thread\nblocks）。</p>\n<figure>\n<img\nsrc=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2011.22.57.png?raw=true\"\nalt=\"屏幕快照 2019-11-27 11.22.57\" />\n<figcaption aria-hidden=\"true\">屏幕快照 2019-11-27 11.22.57</figcaption>\n</figure>\n<p>Shedule定义在输出shape上，包含三个字段：split_dim、sword和sched_type。split_dim表示切割的维度，取值[0,\nnum_dims)。sword表示在split_dim维度上切分多少块，sword要求能被split_dim维度K整除。sched_type表示行切割还是列切割，取值Row或者Column。给定一个Instruction，其Schedule空间即所有合法的三元组（split_dim、sword和sched_type）。</p>\n<p>上图表示Reduce Instruction的两种合法Schedule，通过split_dim和reduce\ndim来区分Row Schedule和Column Schedule。</p>\n<h3 id=\"schedule约束和传播\">Schedule约束和传播</h3>\n<p>与Instruction的Schedule定义在输出shape上一样，Computation的Schedule也定义在Root\nInstruction的输出上，因为Root Instruction是整个Computation的输出。<br />\n对于一个Fused Computation，需要满足Shedule相容约束：即对于Root\nInstruction，给定一个合法的Shedule，该Shedule需要同时被其他Instruction相容。论文中提出后向传播的方法来判断Shedule约束的相容性。<br />\n任意一个Instruction，其合法的Schedule可以根据Instruction类型和output\nshape来确定。如果给定的Schedule满足约束（是合法的），则把Schedule后向传播到输入shape(s)，也就是输入Instruction的输出shape。否则从Root\nInstruction传播过来的Schedule在整个Fused\nCompution上不满足相容性约束。</p>\n<blockquote>\n<p>在Subgraph Fusion算法中，两个Instruction能否合并除了需要满足circle\nfree约束外，还需要满足后端CodeGen模块的支持。只有Schedule满足约束，CodeGen才能正确发射代码，否则CodeGen无法处理。</p>\n</blockquote>\n<figure>\n<img\nsrc=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2013.53.21.png?raw=true\"\nalt=\"屏幕快照 2019-11-27 13.53.21\" />\n<figcaption aria-hidden=\"true\">屏幕快照 2019-11-27 13.53.21</figcaption>\n</figure>\n<p>Table.1表明了不同Instruction的Schedule后向传播规则。Schedule约束判断结果会反馈到Subgraph\nFusion过程，Fusion不应该破坏Schedule相容性约束。</p>\n<h3 id=\"schedule-tuning\">Schedule Tuning</h3>\n<p>任意一个Instruction，split_dim=0和sword=1的Row\nSchedule总是合法的，也就是只有一个数据块，并且只用一个GPU线程块来计算。这样做的问题也很明显，就是无法充分利用GPU硬件资源。每个Instruction可能有多个合法的Schedule，Schedule\nTuning用来选择一个合适的Schedule。<br />\n如果Computation中只有一个Root，遍历该Root\nInstructon所有合法的满足约束的Schedule，在performance\nlibrary中查找每个kernel的执行时间，并统计总耗时。总耗时最少的Schedule会被选择用来Code\nGeneration。</p>\n<p>如果Computation中有多个Roots，则采取一种two-stage的方法加速Schedule的搜索过程。<br />\n第一步：遍历所有的Roots，计算blocks和blocks对应的Schedule两个序列。对所有Roots对应的blocks序列求交集，结果对应的Schedule即合法的候选Schedule。<br />\n第二步：遍历所有的候选Schedule，计算每个Schedule下所有kernel的耗时，选择耗时最少的Schedule。论文中还提到可以忽略部分ops和early\nstop的搜索策略，加速第二步的搜索过程。</p>\n<h2 id=\"code-generation\">Code Generation</h2>\n<h3 id=\"shared-memory-planning\">Shared Memory Planning</h3>\n<p>标记出所有可能需要用到Shared\nMemory的候选ops，当Memory不足时优先满足most critical ops。</p>\n<ul>\n<li><p>Size Requirement Analysis</p>\n<ol type=\"1\">\n<li><p>直接分配 对于非Root\nInstruction的Reduce和BatchDot，必须将中间结果放在Shared Memory，allowing\nconsumer ops to use seperate parallel loop emitters to generate\ncode。</p></li>\n<li><p>按优先级分配 对于有多个Users的Elementwise\nop，为了避免重计算，可以选择将结果缓存到Shared\nMemory。在memory受限的情况下，按照优先级（expensive op &gt; 非expensive\nop）确定使用Shared Memory。<br />\n有时对于只有一个User的expensive op也需要用到Shared\nMemory，比如如果expensive\nop后面接了一个BatchDot，由于BatchDot本身对数据的复用性比较高，将expensive\nop的结果缓存到Shared Memory会带来非常好的性能优化。</p></li>\n</ol></li>\n<li><p>Size Shrinking</p>\n<p>Size Shrinking与上面Requirement\nAnalysis的第2点类似。当每个线程Block分到的数据块非常大时，可能存在Shared\nMemory受限的问题。解决办法就是让一些ops退化为重计算。<br />\n从inexpensive ops开始，然后expensive ops，之后是带有BtachDot的expensive\nops，最后按照靠近Root\nInstruction的程度选择候选ops，并优先选择靠近输出的ops。</p></li>\n<li><p>Space Sharing</p>\n<p>不同ops分配的Shared Memory是可以复用的，论文中作者提出从Root\nInstruction开始构造一颗支配树，支配节点可以复用被支配节点申请的Shared\nMemory。</p></li>\n</ul>\n<h3 id=\"code-generation-1\">Code Generation</h3>\n<p>XLA使用GpuElementalIrEmitter来实现线程合并的Computation。基于XLA的GpuElementalIrEmitter，作者实现了用于Block合并的IrEmitter\n(论文中称作IrEmitterStitched)。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2017.26.12.png?raw=true\" width=600/></p>\n<p>IrEmitterStitched输入有hlo、root、shared、schedule和generators。</p>\n<ul>\n<li>hlo: 待处理的hlo Instruction</li>\n<li>root: 是否是root Instruction</li>\n<li>shared: 是否将输出写到shared memory</li>\n<li>shedule: row schedule还是column schedule</li>\n<li>generators：与XLA\nGpuElementalIrEmitter中的generators_类似，但是能处理shared\nmemory的情况。</li>\n</ul>\n<p>基本逻辑如下：</p>\n<ol type=\"1\">\n<li>如果待处理的Instruction不是root Instruction，并且没有用到Shared\nMemory，不是Dot和Reduce\nOpcode，则回退到XLA的GpuElementalIrEmitter中去处理，否则使用IrEmitterStitched发射LLVM代码。</li>\n<li>如果需要用到Shared\nMemory，则调用EmitWriteSharedArray将结果写到Shared Memory。</li>\n<li>如果是root Instruction，则调用EmitWriteOutputArray将结果写到Global\nMemory。如果不是root\nInstruction，则调用EmitGenerator在generators中创建一个entry，以支持当前Instruction与其他Instruction的合并。</li>\n</ol>\n<h2 id=\"xla-op-fusion规则\">XLA op fusion规则</h2>\n<ul>\n<li><p>Consumer本身支持合并</p>\n<p>特定op不支持与Producer合并，比如Parameter、While、Conditional、Call等，以及op本身has\na side effect或者调用了has a side\neffect的op。此外被标记为tracing的op也无法合并。</p></li>\n<li><p>Consumer与Producer之间支持合并</p>\n<ul>\n<li>Consumer和Producer之间所有的op均可以被合并到Consumer。</li>\n<li>对于Consumer和Producer之间所有的op：\n<ol type=\"1\">\n<li>如果直接Producer已经是一个Fusion op，则不能合并。</li>\n<li>对Reduce和Scatter，以及CustomCall/LibraryCall的一些限制。</li>\n<li>如果直接Producer有其他Consumer，则Fusion会导致该Producer\n需要重计算。如果Producer属于expensive op或为Parameter\nop则放弃合并。</li>\n</ol></li>\n</ul></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"fusionstitching系统概述\">FusionStitching系统概述</h2>\n<figure>\n<img\nsrc=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-25%2013.56.40.png?raw=true\"\nalt=\"屏幕快照 2019-11-25 13.56.40\" />\n<figcaption aria-hidden=\"true\">屏幕快照 2019-11-25 13.56.40</figcaption>\n</figure>\n<p>输入HloModule，经过以下三个阶段，最终输出LLVM IR。</p>\n<ul>\n<li>Computation Fusion</li>\n<li>Schedule Planning</li>\n<li>Code Generation</li>\n</ul>\n<p>论文主要针对XLA\nFusion算法进行了改进，提出了实现Block合并策略的Schedule和Shared Memory\nPlanning技术，以及实现对应的IR Emitter。</p>","more":"<h2 id=\"computation-fusion\">Computation Fusion</h2>\n<p>利用Work/Span analysis，将instruction划分到不同的layer，然后Deep\nFusion模块在Schedule Consistency\nChecker的指导下完成跨layer的instruction合并。该过程是迭代进行的，直到完全没有合并机会。</p>\n<h3 id=\"workspan-analysis\">Work/Span analysis</h3>\n<blockquote>\n<p>Work/Span\nanalysis通常用于并行算法的分析。假设每个基本运算执行时间都是单位时间，则Work表示的是所有基本运算时间总和，Span表示最长依赖路径上的基本运算时间总和。对于一个计算图来说，可以简单认为图中所有的计算节点总执行时间表示Work，而计算图的最大深度的路径上的节点的顺序执行总时间表示Span。</p>\n</blockquote>\n<p>在这里作者用Span来表示每个节点到root节点的深度。</p>\n<figure>\n<img\nsrc=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-26%2018.28.17.png?raw=true\"\nalt=\"屏幕快照 2019-11-26 18.28.17\" />\n<figcaption aria-hidden=\"true\">屏幕快照 2019-11-26 18.28.17</figcaption>\n</figure>\n<p>经过Work/Span\nanalysis后，HloModule中的Instruction被划分到了不同的layer，相同Span值的Instruction的layer相同，并且同一layer的Instruction没有依赖关系。</p>\n<h3 id=\"subgraph-fusion-algorithm\">Subgraph Fusion Algorithm</h3>\n<p>基于Work/Span\nanalysis计算得到的Span值，作者提出了不同于XLA的Fusion算法。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-26%2019.44.59.png?raw=true\" width=600/></p>\n<p>SchdConsistent用来判断fusion_root和hlo是否应该合并，其具体的执行逻辑如下：</p>\n<ol type=\"1\">\n<li>如果hlo有一个consumer在giveup集合中，为了防止潜在的循环依赖，放弃fusion。</li>\n<li>如果hlo的所有consumer都不在fused集合中，则放弃fusion，因为这里只考虑Producer/Consumer的合并，没有消费关系的Instruction合并则会在ElementwiseFusion算法中处理。</li>\n<li>最后会判断合并后的Computation是否存在一个可行的optimized\nshedule。如果不存在，则放弃fusion。</li>\n</ol>\n<blockquote>\n<ul>\n<li>算法简单高效，Work/Span\nAnalysis的作用其实相当于对Instruction做了一遍拓扑排序，通过简单的合并规则确保circle\nfree。</li>\n<li>不区分expensive op，可以通过shared\nmemory来缓存中间结果，因此不需要重计算。</li>\n<li>由于第一条约束的强制性，导致合并不完全。</li>\n</ul>\n</blockquote>\n<h2 id=\"schedule-planning\">Schedule Planning</h2>\n<h3 id=\"schedule定义\">Schedule定义</h3>\n<blockquote>\n<p>Schedule通常指的是将算法指定的计算过程分配给计算资源的方法。这些计算过程可能包括线程、进程以及数据流等。</p>\n<p>常见的一些Schedule配置: - Reorder 循环顺序重排，比如for x for y -&gt;\nfor y for x - Tile - Unroll - Vectorize - Parallel - some CUDA-specific\n比如blocks、threads、shared memory size等。</p>\n<p>对于包含多个计算stage的算法，Schedule通常是由Consumer驱动，并指定何时对Consumer计算Producer（<strong>Specify\nwhen the producer is computed with respect to the consumer</strong>\n）。</p>\n</blockquote>\n<p>论文中将Instruction大致分成Elementwise、Transpose、Reduce、BatchDot、Reshape和Broadcast这几种，然后基于这些op定义了一套用来表示对数据分块的Shedule配置。通过一个定义好的Shedule配置和数据的shape，我们就可以知道需要切成多少个数据块，映射到GPU硬件上就是多少个线程块（thread\nblocks）。</p>\n<figure>\n<img\nsrc=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2011.22.57.png?raw=true\"\nalt=\"屏幕快照 2019-11-27 11.22.57\" />\n<figcaption aria-hidden=\"true\">屏幕快照 2019-11-27 11.22.57</figcaption>\n</figure>\n<p>Shedule定义在输出shape上，包含三个字段：split_dim、sword和sched_type。split_dim表示切割的维度，取值[0,\nnum_dims)。sword表示在split_dim维度上切分多少块，sword要求能被split_dim维度K整除。sched_type表示行切割还是列切割，取值Row或者Column。给定一个Instruction，其Schedule空间即所有合法的三元组（split_dim、sword和sched_type）。</p>\n<p>上图表示Reduce Instruction的两种合法Schedule，通过split_dim和reduce\ndim来区分Row Schedule和Column Schedule。</p>\n<h3 id=\"schedule约束和传播\">Schedule约束和传播</h3>\n<p>与Instruction的Schedule定义在输出shape上一样，Computation的Schedule也定义在Root\nInstruction的输出上，因为Root Instruction是整个Computation的输出。<br />\n对于一个Fused Computation，需要满足Shedule相容约束：即对于Root\nInstruction，给定一个合法的Shedule，该Shedule需要同时被其他Instruction相容。论文中提出后向传播的方法来判断Shedule约束的相容性。<br />\n任意一个Instruction，其合法的Schedule可以根据Instruction类型和output\nshape来确定。如果给定的Schedule满足约束（是合法的），则把Schedule后向传播到输入shape(s)，也就是输入Instruction的输出shape。否则从Root\nInstruction传播过来的Schedule在整个Fused\nCompution上不满足相容性约束。</p>\n<blockquote>\n<p>在Subgraph Fusion算法中，两个Instruction能否合并除了需要满足circle\nfree约束外，还需要满足后端CodeGen模块的支持。只有Schedule满足约束，CodeGen才能正确发射代码，否则CodeGen无法处理。</p>\n</blockquote>\n<figure>\n<img\nsrc=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2013.53.21.png?raw=true\"\nalt=\"屏幕快照 2019-11-27 13.53.21\" />\n<figcaption aria-hidden=\"true\">屏幕快照 2019-11-27 13.53.21</figcaption>\n</figure>\n<p>Table.1表明了不同Instruction的Schedule后向传播规则。Schedule约束判断结果会反馈到Subgraph\nFusion过程，Fusion不应该破坏Schedule相容性约束。</p>\n<h3 id=\"schedule-tuning\">Schedule Tuning</h3>\n<p>任意一个Instruction，split_dim=0和sword=1的Row\nSchedule总是合法的，也就是只有一个数据块，并且只用一个GPU线程块来计算。这样做的问题也很明显，就是无法充分利用GPU硬件资源。每个Instruction可能有多个合法的Schedule，Schedule\nTuning用来选择一个合适的Schedule。<br />\n如果Computation中只有一个Root，遍历该Root\nInstructon所有合法的满足约束的Schedule，在performance\nlibrary中查找每个kernel的执行时间，并统计总耗时。总耗时最少的Schedule会被选择用来Code\nGeneration。</p>\n<p>如果Computation中有多个Roots，则采取一种two-stage的方法加速Schedule的搜索过程。<br />\n第一步：遍历所有的Roots，计算blocks和blocks对应的Schedule两个序列。对所有Roots对应的blocks序列求交集，结果对应的Schedule即合法的候选Schedule。<br />\n第二步：遍历所有的候选Schedule，计算每个Schedule下所有kernel的耗时，选择耗时最少的Schedule。论文中还提到可以忽略部分ops和early\nstop的搜索策略，加速第二步的搜索过程。</p>\n<h2 id=\"code-generation\">Code Generation</h2>\n<h3 id=\"shared-memory-planning\">Shared Memory Planning</h3>\n<p>标记出所有可能需要用到Shared\nMemory的候选ops，当Memory不足时优先满足most critical ops。</p>\n<ul>\n<li><p>Size Requirement Analysis</p>\n<ol type=\"1\">\n<li><p>直接分配 对于非Root\nInstruction的Reduce和BatchDot，必须将中间结果放在Shared Memory，allowing\nconsumer ops to use seperate parallel loop emitters to generate\ncode。</p></li>\n<li><p>按优先级分配 对于有多个Users的Elementwise\nop，为了避免重计算，可以选择将结果缓存到Shared\nMemory。在memory受限的情况下，按照优先级（expensive op &gt; 非expensive\nop）确定使用Shared Memory。<br />\n有时对于只有一个User的expensive op也需要用到Shared\nMemory，比如如果expensive\nop后面接了一个BatchDot，由于BatchDot本身对数据的复用性比较高，将expensive\nop的结果缓存到Shared Memory会带来非常好的性能优化。</p></li>\n</ol></li>\n<li><p>Size Shrinking</p>\n<p>Size Shrinking与上面Requirement\nAnalysis的第2点类似。当每个线程Block分到的数据块非常大时，可能存在Shared\nMemory受限的问题。解决办法就是让一些ops退化为重计算。<br />\n从inexpensive ops开始，然后expensive ops，之后是带有BtachDot的expensive\nops，最后按照靠近Root\nInstruction的程度选择候选ops，并优先选择靠近输出的ops。</p></li>\n<li><p>Space Sharing</p>\n<p>不同ops分配的Shared Memory是可以复用的，论文中作者提出从Root\nInstruction开始构造一颗支配树，支配节点可以复用被支配节点申请的Shared\nMemory。</p></li>\n</ul>\n<h3 id=\"code-generation-1\">Code Generation</h3>\n<p>XLA使用GpuElementalIrEmitter来实现线程合并的Computation。基于XLA的GpuElementalIrEmitter，作者实现了用于Block合并的IrEmitter\n(论文中称作IrEmitterStitched)。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/DeepFusion/屏幕快照%202019-11-27%2017.26.12.png?raw=true\" width=600/></p>\n<p>IrEmitterStitched输入有hlo、root、shared、schedule和generators。</p>\n<ul>\n<li>hlo: 待处理的hlo Instruction</li>\n<li>root: 是否是root Instruction</li>\n<li>shared: 是否将输出写到shared memory</li>\n<li>shedule: row schedule还是column schedule</li>\n<li>generators：与XLA\nGpuElementalIrEmitter中的generators_类似，但是能处理shared\nmemory的情况。</li>\n</ul>\n<p>基本逻辑如下：</p>\n<ol type=\"1\">\n<li>如果待处理的Instruction不是root Instruction，并且没有用到Shared\nMemory，不是Dot和Reduce\nOpcode，则回退到XLA的GpuElementalIrEmitter中去处理，否则使用IrEmitterStitched发射LLVM代码。</li>\n<li>如果需要用到Shared\nMemory，则调用EmitWriteSharedArray将结果写到Shared Memory。</li>\n<li>如果是root Instruction，则调用EmitWriteOutputArray将结果写到Global\nMemory。如果不是root\nInstruction，则调用EmitGenerator在generators中创建一个entry，以支持当前Instruction与其他Instruction的合并。</li>\n</ol>\n<h2 id=\"xla-op-fusion规则\">XLA op fusion规则</h2>\n<ul>\n<li><p>Consumer本身支持合并</p>\n<p>特定op不支持与Producer合并，比如Parameter、While、Conditional、Call等，以及op本身has\na side effect或者调用了has a side\neffect的op。此外被标记为tracing的op也无法合并。</p></li>\n<li><p>Consumer与Producer之间支持合并</p>\n<ul>\n<li>Consumer和Producer之间所有的op均可以被合并到Consumer。</li>\n<li>对于Consumer和Producer之间所有的op：\n<ol type=\"1\">\n<li>如果直接Producer已经是一个Fusion op，则不能合并。</li>\n<li>对Reduce和Scatter，以及CustomCall/LibraryCall的一些限制。</li>\n<li>如果直接Producer有其他Consumer，则Fusion会导致该Producer\n需要重计算。如果Producer属于expensive op或为Parameter\nop则放弃合并。</li>\n</ol></li>\n</ul></li>\n</ul>"},{"title":"决策树在Kaldi中如何使用","date":"2016-06-08T06:54:04.000Z","_content":"\n说明：本文是kaldi主页相关内容的翻译（http://kaldi-asr.org/doc/tree_externals.html ）。目前网上已经有一个翻译的版本，但翻译的不是很清楚，导致我在刚学这部分内容的时候产生了一些误解，所以我希望结合我目前所知道的一些东西，尽量把这部分内容翻译地比较容易理解，但由于也是初学者，一些错误也是不可避免，希望大家发现后一起交流，以便我后期修正。好了，还是废话少说吧。\n\n<!-- more -->\n\n## 介绍（Introduction）\n本页将对声学决策树在kaldi中如何被创建和使用，以及如何在训练和解码图构建过程进行运用给出一个概述性的解释。对于构建决策树代码的内部描述，请参见Decision tree internals；对于构建解码图方法的详细信息，可以参见Decoding graph construction in Kaldi。\n\n 实现的基本算法就是自顶向下的贪婪分裂，通过问一些问题，比如说左边的音素，右边的音素，中心音素以及当前的状态等等，我们会得到很多可以把数据进行分裂的路径。我们实现的算法与标准算法非常相似，请参见Young，Odell和Woodland的这篇论文\"Tree-based State Tying for High Accuracy Acoustic Modeling\" 。假设我们对数据建模时采用单高斯将它们分成两部分，在这个算法中，我们通过选择局部最优的问题进行数据分裂，也就是使得似然值增加最大的那个问题。与标准算法实现不同的地方包括可以自由配置树的根节点；对HMM状态和中心音素相关问题提问的能力；以及实际上在Kaldi脚本中默认情况下，问题集是通过对数据自顶向下的二分聚类自动生成的，这就意味着不需要手动去创建问题集。关于树的根节点的配置：可能是把一个共享的群组里面所有音素分裂的统计量，或者独立的音素，或者每个音素的HMM状态，作为树的根节点来进行分裂，或者把音素组作为树的根节点（注：多个音素作为一棵树的根节点）。对于如何用标准的脚本配置根节点，请参见Data preparation。实际上，我们一般让每棵树的根节点都对应一个真实的音素（real phone），意思就是说我们把每个音素的词位置相关、发音相关或者音调相关的所有变种都放进一个音素组，作为决策树的根节点。\n\n本页下面主要给出相关代码层面的一些详细信息。\n\n## 音素上下文窗（Phonetic context windows）\n这里我们解释一下在代码中我们怎样描述一个音素的上下文。一棵特殊的决策树将有两个整型值，分别描述的是上下文窗的宽度和中心位置。下表简单说明了这两个值：\n![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNjA4MTQwNjU3MTkx?x-oss-process=image/format,png)\nN是上下文窗的宽度，P是设计的中心音素的标记。一般P就是窗的中心（因此叫中心位置）；举例说，当N=3时我们一般设P=1，但是我们也可以从0到N-1自由选择；比如，P=2和N=3意味着有左上下文有两个音素，并且没有右上下文。在代码中，当我们讨论中心音素时，我们总是认为讨论的是第P个音素，可能是也可能不是上下文窗中心的那个音素。\n\n一个用来表示典型的triphone上下文窗的整型向量可能是：\n```c++\n//probably not valid C++\nvector<int32> ctx_window = { 12, 15, 21 };\n```\n假设N=3和P=1，这个表示有一个右上下文21和一个左上下文12的音素15。我们处理端点位置上下文的一个方式是使用0（0不是一个合法的音素，因为在OpenFst中0是为空符号epsilon而保留的），所以比如：\n```c++\nvector<int32> ctx_window = { 12, 15, 0};\n```\n表示有一个左上下文12和没有右上下文的音素15，因为音素15是句子的结尾。在句子结尾这种特殊的地方，0这种方式的使用可能有一点意外，因为最后一个“音素”实际上是后续符号“$”（参见Making the context transducer），但是为了在决策树代码中的便利，我们不把后续符号放进上下文窗，而是把0放进去。注意，如果此时我们N=3和P=2，那上述的上下文窗是非法的，因为第P个元素是一个不能表示任何真实音素的0；当然同样如果我们有一个N=1的树，上面的窗都是不合法的，因为那些窗的大小都是错误的。在单音素的情况下，我们可以有一个如下的窗：\n```c++\nvector<int32> ctx_window = { 15 };\n```\n因此单音素系统只是被当成上下文相关系统的一种特殊情况，窗的大小N等于1，并且还有一棵什么都不做的树（注：经过这棵树后没有任何参数被绑定）。\n\n## 树的构建过程（The tree building process）\n在这部分我们给出Kaldi中树构建过程的一个概述。\n\n即使是单音素系统也有一个决策树，但是是一个无用的树。参见返回这样一个无用树的函数MonophoneContextDependency() 和 MonophoneContextDependencyShared()。这两个函数被命令行程序gmm-init-mono调用；它主要的输入参数是HmmTopology对象，并且输出一棵树，这棵树通常会被以ContextDependency类型的对象写到一个叫做“tree”的文件中，以及模型文件（模型文件包含一个TransitionModel对象和一个AmDiagGmm对象）。如果程序gmm-init-mono接受一个叫-shared-phones的可选参数，它将会在指定的音素序列间共享pdfs（注：输出概率密度函数，比如高斯），否则它会使得所有的音素都是独立的。\n\n从一个扁平的初始（注：除了sil，所有的单音素模型都是一样的）开始训练一个单音素系统后，我们拿单音素对齐的结果和使用函数AccumulateTreeStats()（被acc-tree-stats调用）来累积训练决策树的统计量。这个程序不限于读取单音素的对齐结果；它也能读取上下文相关的对齐结果，因此我们也可以基于triphone对齐结果来构建树。构建树的统计量以BuildTreeStatsType类型（参见Statistics for building the tree）被写到磁盘。函数AccumulateTreeStats()输入N和P的值，N和P就是上文解释过的上下文窗的大小和中心音素位置。命令行程序会默认地将N和P设为3和1，但是也可以使用–context-width和–central-position可选参数进行覆盖。程序acc-tree-stats输入一个上下文无关的音素列表（比如，silence），但是即使存在上下文无关的音素，这个也不是必需的；它只是减少统计量大小的一个机制。对于上下文无关的音素，程序将会累积一个没有定义keys的相关的统计量，keys是跟左右音素对应的（注：在代码中会把一个音素不同的上下文和pdf-class分别作为不同的key，然后累积每个key的统计量）（c.f. Event maps）。\n\n当统计量被积累后，我们使用程序build-tree来构建树。这个程序输出一棵树。程序build-tree需要三样东西：\n\n - 统计量（BuildTreeStatsType类型）\n - 问题集配置（Questions类型）\n - roots文件（参见下面）\n\n统计量一般从程序acc-tree-stats得到；问题集配置类可以用程序compile-questions输出，compile-questions输入一个声学问题集的拓扑列表（在我们的脚本中，这些都是自动地从构建树的统计量通过程序cluster-phones得到）（注：cluster-phones输入构建树的统计量可以得到一个声学问题集）。roots文件指定了将要在决策树聚类过程中共享根节点的音素集，并且对每个音素集指出下面两个东西：\n\n - “shared”或者“not-shared”指出是每个pdf-class（也就是一般情况下的HMM状态）都有不同的根节点，还是所有pdf-class共享一个根节点。如果是“shared”，对于所有的HMM状态（比如在正常的HMM拓扑下所有的三个状态）将只会有一个树根节点；如果是“not-shared”，将会有三个树根节点，每个pdf-class有一个。\n - “split”或者“not-split”指出对于根节点要不要根据问题进行决策树分裂（对于silence，我们一般不分裂）。如果该行指定“split”（正常情况），那么我们进行决策树分裂。如果指定“not-split”，那么就不会进行分裂，因此根节点就被无分裂地保留。\n \n下面将对这个怎样使用方面做一些阐述：\n\n - 如果我们指定“shared split”，即使所有的三个HMM状态有一个根节点，不同的HMM状态仍然可以到达不同的叶子节点，因为树可以像对声学上下文的问题提问一样对pdf-class的问题提问。\n - 对于roots文件中同一行出现的所有音素，我们总是让它们共享根节点。如果你不想共享音素的根节点，你只要把它们放在不同的行。\n \n下面是roots文件的一个例子；假设音素1是silence，并且其他的音素都有不同的根节点。\n\n```\nnot-shared not-split  1\nshared split  2\n...\nshared split  28\n```\n当我们有比如位置和声调相关的音素时，将多个音素放在同一行会非常有用；这样每个“真实的“音素将关联到一个整数的音素ID集合。在这种情况下我们将particular underlying（注：这个不知道怎么翻译）音素的所有变种版本共享一个根节点。下面是来自egs/wsj/s5脚本中Wall Street Journal的roots文件的一个例子（这个例子中音素是用文本表示的，而不是整数形式；但在被Kaldi读取之前会被转换成整数形式（注：就是会把音素映射成整数的ID））：\n```\nnot-shared not-split SIL SIL_B SIL_E SIL_I SIL_S SPN SPN_B SPN_E SPN_I SPN_S NSN NSN_B NSN_E NSN_I NSN_S\nshared split AA_B AA_E AA_I AA_S AA0_B AA0_E AA0_I AA0_S AA1_B AA1_E AA1_I AA1_S AA2_B AA2_E AA2_I AA2_S\nshared split AE_B AE_E AE_I AE_S AE0_B AE0_E AE0_I AE0_S AE1_B AE1_E AE1_I AE1_S AE2_B AE2_E AE2_I AE2_S\nshared split AH_B AH_E AH_I AH_S AH0_B AH0_E AH0_I AH0_S AH1_B AH1_E AH1_I AH1_S AH2_B AH2_E AH2_I AH2_S\nshared split AO_B AO_E AO_I AO_S AO0_B AO0_E AO0_I AO0_S AO1_B AO1_E AO1_I AO1_S AO2_B AO2_E AO2_I AO2_S\nshared split AW_B AW_E AW_I AW_S AW0_B AW0_E AW0_I AW0_S AW1_B AW1_E AW1_I AW1_S AW2_B AW2_E AW2_I AW2_S\nshared split AY_B AY_E AY_I AY_S AY0_B AY0_E AY0_I AY0_S AY1_B AY1_E AY1_I AY1_S AY2_B AY2_E AY2_I AY2_S\nshared split B_B B_E B_I B_S\nshared split CH_B CH_E CH_I CH_S\nshared split D_B D_E D_I D_S\n```\n\n当创建这个roots文件时，你应该确保在每一行至少有一个音素是可见的（注：有对应的训练样本）。比如上面的情况，如果音素AY至少在声调和词位置的某些连接中可见，那就没问题。\n\n在这个例子中，对于slience等音素我们有很多的词位置相关的变种。它们将共享它们的pdf's，因为它们都在同一行，并且是“not-split”，但是它们可能会有不同的状态转移参数。实际上，silence的大多数变种都不可能用到，因为silence不可能出现在词与词之间；这只是为了防止以后有人做一些奇怪的事而不会过时。\n\n我们用从之前创建的模型（比如，单音素模型）得到的对齐结果来对混合高斯参数进行初始化；对齐的结果会被程序convert-ali从一棵树转换到另一棵（注：应该就是说对齐的transition不变，但状态绑定的参数可能因为决策树的不同而变化）。\n\n## PDF标号（PDF identifiers）\nPDF标号（pdf-id）是一个从0开始的数字，用做概率密度函数（p.d.f.）的序号。系统中每一个p.d.f.都有自己的pdf-id，并且是连续的（在一个LVCSR系统中一般会有几千个）。在树首先被构建时，它们就会被赋值。对于每一个pdf-id对应的是哪个音素，可能知道也可能不知道，这取决于树是怎样被构建的。\n\n## 上下文相关对象（Context dependency objects）\nContextDependencyInterface对象是树的一个虚基类，指定了如何与构建解码图代码进行交互。这个接口只包含四个函数：\n\n - ContextWidth()返回树需要的N（上下文窗的大小）的值。\n - CentralPosition()返回树需要的P（窗中心位置）的值\n - NumPdfs()返回树定义的pdfs的数量；pdfs的编号从0到NumPdfs()-1。\n - Compute()是对某个特殊的上下文计算它对应的pdf-id的函数\n \n  ContextDependencyInterface::Compute()函数的声明如下：\n  ```c++\n  class ContextDependencyInterface {\n   ...\n      virtual bool Compute(const std::vector<int32> &phoneseq, int32 pdf_class,\n                      int32 *pdf_id) const;\n  }\n  ```\n  如果能计算得到上下文和pdf-class对应的pdf-id，函数返回true。返回false时表明出现了一些错误或者是不匹配。这个函数使用的一个例子：\n  ```c++\n  ContextDependencyInterface *ctx_dep = ... ;\n  vector<int32> ctx_window = { 12, 15, 21 }; // not valid C++\n  int32 pdf_class = 1; // probably central state of 3-state HMM.\n  int32 pdf_id;\n  if(!ctx_dep->Compute(ctx_window, pdf_class, &pdf_id))\n        KALDI_ERR << \"Something went wrong!\"\n  else\n        KALDI_LOG << \"Got pdf-id, it is \" << pdf_id;\n  ```\n  目前唯一继承ContextDependencyInterface的类就是ContextDependency，ContextDependency有少量更丰富的接口；唯一主要的添加就是函数GetPdfInfo，被用于TransitionModel类算出一个特殊的pdf可能对应哪些音素（这个函数的功能可以被 ContextDependencyInterface接口遍历所有的上下文而实现）。\n\nContextDependency对象实际上是对EventMap对象的简单组合封装；请参见Decision tree internals。我们希望尽可能地隐藏树的真正实现，使得以后需要重构代码时变得非常简单。\n\n## 决策树的一个例子（An example of a decision tree）\n决策树文件的格式不是以人们的可读性为首要目标而创建的，但由于大家需要我们在这里试着解释如何去解读这个文件。请看下面的例子，这个是一个来自Wall Street Journal脚本中triphone的决策树。它以这个对象的名字ContextDependency开始（注：在代码中整个树是一个ContextDependency对象）；然后是N（上下文窗的大小），这里是3；接着是P（上下文窗的中心位置），这里是1。文件剩下的部分包含单个EventMap对象。EventMap是一个可能包含指向其他EventMap指针的多态类型。更多详细信息，请参见Event maps。这个文件表示一棵决策树或多棵决策树的集合，并将一个键值对集合（比如，left-phone=5, central-phone=10, right-phone=11, pdf-class=2（注：注意这里是四个键值对，表示一个中心音素是10，上文是音素5，下文是音素11的triphone的第2个状态））映射到一个pdf-id（比如，158）。简单来说，一个决策树包含三种基本类型：一个是SplitEventMap（就像决策树中的分支判断），一个是ConstantEventMap（就像决策树的叶子节点，只包含一个表示pdf-id的数字），和一个是TableEventMap（就像是一个包含其他EventMaps的一个查找表）。SplitEventMap和TableEventMap都有一个需要它们判断的key，这个值可能是0，1或者2，分别表示左上下文音素，中心音素和右上下文音素，也可能是-1，表示pdf-class的标号（注：如果HMM的每个状态都有对应的pdf，则pdf-class可理解为HMM的第几个状态）。一般情况，pdf-class的值与HMM状态的序号是相同的，比如0，1或2。请尝试不要因此而感到困惑：key是-1，value是0，1或2，但它们与上下文窗中音素的keys 0，1或2是没有任何关系的（注：上下文窗中0，1和2表示的是窗中音素的位置）。SplitEventMap有一系列值可以触发决策树的yes分支。下面是一种quasi-BNF符号表示的决策树文件格式。\n```\n         EventMap := ConstantEventMap | SplitEventMap | TableEventMap | \"NULL\"\n ConstantEventMap := \"CE\" <numeric pdf-id>\n    SplitEventMap := \"SE\" <key-to-split-on> \"[\" yes-value-list \"]\" \"{\" EventMap EventMap \"}\"\n    TableEventMap := \"TE\" <key-to-split-on> <table-size> \"(\" EventMapList \")\"\n```\n在下面的例子中，树顶层的EventMap是一个以key 1进行分裂的SplitEventMap，也就是按中心音素分裂。在方括号中是一系列连续范围的phone-ids。然而，这些并不表示一个问题，它们只是音素分裂的一种方法，因此我们可以得到每个音素真正的决策树（注：音素真正的决策树是根据音素上下文和pdf-class进行决策的，对中心音素的决策只是为了找到这个音素对应的真正的决策树）。问题在于这棵树是通过“shared roots”方式创建的，所以有很多与同一音素不同词位置和音调标识相关的phone-ids，它们都共享树的根节点。在这种情况下在树的顶层我们不能使用TableEventMap，否则我们就不得不将每棵树重复好几遍（因为EventMap是一棵纯树，而不是一个通用的图，它没有指针共享的机制）。文件后面的一些“SE”标签也是quasi-tree的一部分，它们都是首先按中心音素进行分裂（当我们顺着文件往下看时我们进入了树的更深处；注意这个花括号“{”一直是打开的，还没有关闭）。然后我们看到字符串“TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 ) ”，表示通过TableEventMap对pdf-class -1进行分裂（实际上就是，HMM-position），并且返回从0到4的值。这5个值表示的是静音和噪声音素SIL，NSN和SPN的5个pdf-ids。在我们的设定中，这三个非语音音素的pdfs是共享的（只有转移矩阵是不同的）。注意：对于这些音素我们用5状态而不是3状态的HMM，所以这里有5个不同的pdf-ids。接下来是“SE -1 [ 0 ] ”，这可以被认为是这棵树中第一个真正的问题。我们可以从上面的SE问题看出这个问题被应用于中心音素为4到19时候，也就是音素AA的不同版本（注：原文写的是5到19，不过我认为原文有问题，改成了4到19）。这个问题问的是pdf-class（key -1）是不是0（即是不是最左边的HMM-state）。下一个问题是“SE 2 [ 220 221 222 223 ]”，问的是音素右上下文是不是音素“M”不同形式中的一个（这是一个非常有效的问题，因为我们是在最左边的HMM-state）；如果问题的答案是yes，我们继续问“SE 0 [ 104 105 106 107... 286 287 ]”，这是一个关于音素左上下文的问题（注：原文写的是右上下文，但应该是左上下文）；如果答案是yes，则pdf-id就是5（“CE 5”），否则就是696（“CE 696”）。\n```\ns3# copy-tree --binary=false exp/tri1/tree - 2>/dev/null | head -100\nContextDependency 3 1 ToPdf SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \\\n26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59\\\n 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 9\\\n3 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 1\\\n20 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 14\\\n5 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170\\\n 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 \\\n196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 ]\n{ SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\\\n 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 6\\\n8 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 10\\\n1 102 103 104 105 106 107 108 109 110 111 ]\n{ SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\\\n 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ]\n{ SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ]\n{ SE 1 [ 1 2 3 ]\n{ TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 )\nSE -1 [ 0 ]\n{ SE 2 [ 220 221 222 223 ]\n{ SE 0 [ 104 105 106 107 112 113 114 115 172 173 174 175 208 209 210 211 212 213 214 215 264 265 266 \\\n267 280 281 282 283 284 285 286 287 ]\n{ CE 5 CE 696 }\nSE 2 [ 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 132 \\\n133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 248 249 250 251 252 253 254 255 256 257 2\\\n58 259 260 261 262 263 268 269 270 271 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 30\\\n3 ]\n```\n下面是一个更简单的例子：来自Resource Management脚本的单音素决策树。顶层的EventMap是一个TableEventMap（“TE 0 49 ...”）。key 0是音素位置0，表示中心（并且只有这一个）音素，因为上下文窗大小（N）为1。TE的条目数量是49（音素的数量加1）。表中第一个EventMap是NULL，因为没有序号为0的音素。下一个EventMap是一个有三个元素的TableEventMap，关联到第一个音素的三个HMM状态（技术上来说，是pdf-class）：“TE -1 3 ( CE 0 CE 1 CE 2 )”。\n```\ns3# copy-tree --binary=false exp/mono/tree - 2>/dev/null| head -5\nContextDependency 1 0 ToPdf TE 0 49 ( NULL TE -1 3 ( CE 0 CE 1 CE 2 )\nTE -1 3 ( CE 3 CE 4 CE 5 )\nTE -1 3 ( CE 6 CE 7 CE 8 )\nTE -1 3 ( CE 9 CE 10 CE 11 )\nTE -1 3 ( CE 12 CE 13 CE 14 )\n```\n## 输入符号信息对象（The ilabel_info object）\nCLG图（请参见Decoding graph construction in Kaldi）在它的输入符号位置上有表示上下文相关音素的符号（辅助符号和可能的空符号也一样）。在图中它们总是用整型的标签来表示。在代码和文件名中，我们使用一个叫做ilable_info的对象。ilable_info对象跟ContextFst对象有很密切的联系，请参见see The ContextFst object。就跟许多其他的Kaldi类型一样，ilabel_info也是一个通用的（STL）类型，但是为了可以辨别出是ilabel_info，我们使用与之相同的变量名。就是下面定义的类型：\n```c++\nstd::vector<std::vector<int32> > ilabel_info;\n```\n它是一个以FST输入标签为索引的vector，给每一个输入标签一个对应的音素上下文窗（参见上文，Phonetic context windows）。比如，假设符号1500是左上下文是12和右上下文是4的音素30，我们有：\n```c++\n// not valid C++\nilabel_info[1500] == { 4, 30, 12 };\n```\n在单音素的情况下，我们就会像这样：\n```c++\nilabel_info[30] == { 28 }\n```\n处理辅助符号会有点特殊（参见Disambiguation symbols或者上面引用的Springer Handbook文献，该文献解释了这些辅助符号是什么）。如果一条ilabel_info记录对应到一个辅助符号，我们就把辅助符号的符号表序号取负值放进去（注意这跟辅助符号打印形式#0，#1，#2等等里面的数字是不一样的，它是跟这些辅助符号在符号表文件中的顺序相关的数字，这个符号表文件在我们现在的脚本中叫做phones_disambig.txt）。比如，\n```c++\nilabel_info[5] == { -42 }\n```\n意味着在HCLG中符号数5对应到整数id是42的辅助符号。为了编程方便我们对这些id取负号，因此解析ilable_info对象的程序不需要给一个辅助符号的列表就可以在单音素情况下将它们跟真实的音素进行区分。有两个额外特殊情况：\n```c++\nilabel_info[0] == { }; // epsilon\nilabel_info[1] == { 0 }; // disambig symbol #-1;\n// we use symbol 1, but don't consider this hardwired.\n```\n第一个是正常的空符号，我们给它一个空的vector作为它的ilabel_info。这个符号一般不会出现在CLG的左边（注：应该是说不会作为CLG的输入符号）。第二个是一个特殊的辅助符号，打印形式叫做“#-1”。在epsilons被用做标准（Springer Handbook）脚本中C转换器输入符号的时候，我们使用辅助符号“#-1”。它可以确保有空音素表示的词的CLG网络可以被确定化。\n\n程序fstmakecontextsyms可以创建一个与ilabel_info对象打印形式对应的符号表；这个主要用于调试和诊断错误。\n","source":"_posts/Kaldi决策树如何使用.md","raw":"---\n\ntitle: 决策树在Kaldi中如何使用\n\ndate: 2016-06-08 14:54:04\n\ncategory: kaldi, decision tree, 决策树\n\ntags: [kaldi, decision tree, 决策树, HMM, 上下文相关音素]\n\n---\n\n说明：本文是kaldi主页相关内容的翻译（http://kaldi-asr.org/doc/tree_externals.html ）。目前网上已经有一个翻译的版本，但翻译的不是很清楚，导致我在刚学这部分内容的时候产生了一些误解，所以我希望结合我目前所知道的一些东西，尽量把这部分内容翻译地比较容易理解，但由于也是初学者，一些错误也是不可避免，希望大家发现后一起交流，以便我后期修正。好了，还是废话少说吧。\n\n<!-- more -->\n\n## 介绍（Introduction）\n本页将对声学决策树在kaldi中如何被创建和使用，以及如何在训练和解码图构建过程进行运用给出一个概述性的解释。对于构建决策树代码的内部描述，请参见Decision tree internals；对于构建解码图方法的详细信息，可以参见Decoding graph construction in Kaldi。\n\n 实现的基本算法就是自顶向下的贪婪分裂，通过问一些问题，比如说左边的音素，右边的音素，中心音素以及当前的状态等等，我们会得到很多可以把数据进行分裂的路径。我们实现的算法与标准算法非常相似，请参见Young，Odell和Woodland的这篇论文\"Tree-based State Tying for High Accuracy Acoustic Modeling\" 。假设我们对数据建模时采用单高斯将它们分成两部分，在这个算法中，我们通过选择局部最优的问题进行数据分裂，也就是使得似然值增加最大的那个问题。与标准算法实现不同的地方包括可以自由配置树的根节点；对HMM状态和中心音素相关问题提问的能力；以及实际上在Kaldi脚本中默认情况下，问题集是通过对数据自顶向下的二分聚类自动生成的，这就意味着不需要手动去创建问题集。关于树的根节点的配置：可能是把一个共享的群组里面所有音素分裂的统计量，或者独立的音素，或者每个音素的HMM状态，作为树的根节点来进行分裂，或者把音素组作为树的根节点（注：多个音素作为一棵树的根节点）。对于如何用标准的脚本配置根节点，请参见Data preparation。实际上，我们一般让每棵树的根节点都对应一个真实的音素（real phone），意思就是说我们把每个音素的词位置相关、发音相关或者音调相关的所有变种都放进一个音素组，作为决策树的根节点。\n\n本页下面主要给出相关代码层面的一些详细信息。\n\n## 音素上下文窗（Phonetic context windows）\n这里我们解释一下在代码中我们怎样描述一个音素的上下文。一棵特殊的决策树将有两个整型值，分别描述的是上下文窗的宽度和中心位置。下表简单说明了这两个值：\n![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNjA4MTQwNjU3MTkx?x-oss-process=image/format,png)\nN是上下文窗的宽度，P是设计的中心音素的标记。一般P就是窗的中心（因此叫中心位置）；举例说，当N=3时我们一般设P=1，但是我们也可以从0到N-1自由选择；比如，P=2和N=3意味着有左上下文有两个音素，并且没有右上下文。在代码中，当我们讨论中心音素时，我们总是认为讨论的是第P个音素，可能是也可能不是上下文窗中心的那个音素。\n\n一个用来表示典型的triphone上下文窗的整型向量可能是：\n```c++\n//probably not valid C++\nvector<int32> ctx_window = { 12, 15, 21 };\n```\n假设N=3和P=1，这个表示有一个右上下文21和一个左上下文12的音素15。我们处理端点位置上下文的一个方式是使用0（0不是一个合法的音素，因为在OpenFst中0是为空符号epsilon而保留的），所以比如：\n```c++\nvector<int32> ctx_window = { 12, 15, 0};\n```\n表示有一个左上下文12和没有右上下文的音素15，因为音素15是句子的结尾。在句子结尾这种特殊的地方，0这种方式的使用可能有一点意外，因为最后一个“音素”实际上是后续符号“$”（参见Making the context transducer），但是为了在决策树代码中的便利，我们不把后续符号放进上下文窗，而是把0放进去。注意，如果此时我们N=3和P=2，那上述的上下文窗是非法的，因为第P个元素是一个不能表示任何真实音素的0；当然同样如果我们有一个N=1的树，上面的窗都是不合法的，因为那些窗的大小都是错误的。在单音素的情况下，我们可以有一个如下的窗：\n```c++\nvector<int32> ctx_window = { 15 };\n```\n因此单音素系统只是被当成上下文相关系统的一种特殊情况，窗的大小N等于1，并且还有一棵什么都不做的树（注：经过这棵树后没有任何参数被绑定）。\n\n## 树的构建过程（The tree building process）\n在这部分我们给出Kaldi中树构建过程的一个概述。\n\n即使是单音素系统也有一个决策树，但是是一个无用的树。参见返回这样一个无用树的函数MonophoneContextDependency() 和 MonophoneContextDependencyShared()。这两个函数被命令行程序gmm-init-mono调用；它主要的输入参数是HmmTopology对象，并且输出一棵树，这棵树通常会被以ContextDependency类型的对象写到一个叫做“tree”的文件中，以及模型文件（模型文件包含一个TransitionModel对象和一个AmDiagGmm对象）。如果程序gmm-init-mono接受一个叫-shared-phones的可选参数，它将会在指定的音素序列间共享pdfs（注：输出概率密度函数，比如高斯），否则它会使得所有的音素都是独立的。\n\n从一个扁平的初始（注：除了sil，所有的单音素模型都是一样的）开始训练一个单音素系统后，我们拿单音素对齐的结果和使用函数AccumulateTreeStats()（被acc-tree-stats调用）来累积训练决策树的统计量。这个程序不限于读取单音素的对齐结果；它也能读取上下文相关的对齐结果，因此我们也可以基于triphone对齐结果来构建树。构建树的统计量以BuildTreeStatsType类型（参见Statistics for building the tree）被写到磁盘。函数AccumulateTreeStats()输入N和P的值，N和P就是上文解释过的上下文窗的大小和中心音素位置。命令行程序会默认地将N和P设为3和1，但是也可以使用–context-width和–central-position可选参数进行覆盖。程序acc-tree-stats输入一个上下文无关的音素列表（比如，silence），但是即使存在上下文无关的音素，这个也不是必需的；它只是减少统计量大小的一个机制。对于上下文无关的音素，程序将会累积一个没有定义keys的相关的统计量，keys是跟左右音素对应的（注：在代码中会把一个音素不同的上下文和pdf-class分别作为不同的key，然后累积每个key的统计量）（c.f. Event maps）。\n\n当统计量被积累后，我们使用程序build-tree来构建树。这个程序输出一棵树。程序build-tree需要三样东西：\n\n - 统计量（BuildTreeStatsType类型）\n - 问题集配置（Questions类型）\n - roots文件（参见下面）\n\n统计量一般从程序acc-tree-stats得到；问题集配置类可以用程序compile-questions输出，compile-questions输入一个声学问题集的拓扑列表（在我们的脚本中，这些都是自动地从构建树的统计量通过程序cluster-phones得到）（注：cluster-phones输入构建树的统计量可以得到一个声学问题集）。roots文件指定了将要在决策树聚类过程中共享根节点的音素集，并且对每个音素集指出下面两个东西：\n\n - “shared”或者“not-shared”指出是每个pdf-class（也就是一般情况下的HMM状态）都有不同的根节点，还是所有pdf-class共享一个根节点。如果是“shared”，对于所有的HMM状态（比如在正常的HMM拓扑下所有的三个状态）将只会有一个树根节点；如果是“not-shared”，将会有三个树根节点，每个pdf-class有一个。\n - “split”或者“not-split”指出对于根节点要不要根据问题进行决策树分裂（对于silence，我们一般不分裂）。如果该行指定“split”（正常情况），那么我们进行决策树分裂。如果指定“not-split”，那么就不会进行分裂，因此根节点就被无分裂地保留。\n \n下面将对这个怎样使用方面做一些阐述：\n\n - 如果我们指定“shared split”，即使所有的三个HMM状态有一个根节点，不同的HMM状态仍然可以到达不同的叶子节点，因为树可以像对声学上下文的问题提问一样对pdf-class的问题提问。\n - 对于roots文件中同一行出现的所有音素，我们总是让它们共享根节点。如果你不想共享音素的根节点，你只要把它们放在不同的行。\n \n下面是roots文件的一个例子；假设音素1是silence，并且其他的音素都有不同的根节点。\n\n```\nnot-shared not-split  1\nshared split  2\n...\nshared split  28\n```\n当我们有比如位置和声调相关的音素时，将多个音素放在同一行会非常有用；这样每个“真实的“音素将关联到一个整数的音素ID集合。在这种情况下我们将particular underlying（注：这个不知道怎么翻译）音素的所有变种版本共享一个根节点。下面是来自egs/wsj/s5脚本中Wall Street Journal的roots文件的一个例子（这个例子中音素是用文本表示的，而不是整数形式；但在被Kaldi读取之前会被转换成整数形式（注：就是会把音素映射成整数的ID））：\n```\nnot-shared not-split SIL SIL_B SIL_E SIL_I SIL_S SPN SPN_B SPN_E SPN_I SPN_S NSN NSN_B NSN_E NSN_I NSN_S\nshared split AA_B AA_E AA_I AA_S AA0_B AA0_E AA0_I AA0_S AA1_B AA1_E AA1_I AA1_S AA2_B AA2_E AA2_I AA2_S\nshared split AE_B AE_E AE_I AE_S AE0_B AE0_E AE0_I AE0_S AE1_B AE1_E AE1_I AE1_S AE2_B AE2_E AE2_I AE2_S\nshared split AH_B AH_E AH_I AH_S AH0_B AH0_E AH0_I AH0_S AH1_B AH1_E AH1_I AH1_S AH2_B AH2_E AH2_I AH2_S\nshared split AO_B AO_E AO_I AO_S AO0_B AO0_E AO0_I AO0_S AO1_B AO1_E AO1_I AO1_S AO2_B AO2_E AO2_I AO2_S\nshared split AW_B AW_E AW_I AW_S AW0_B AW0_E AW0_I AW0_S AW1_B AW1_E AW1_I AW1_S AW2_B AW2_E AW2_I AW2_S\nshared split AY_B AY_E AY_I AY_S AY0_B AY0_E AY0_I AY0_S AY1_B AY1_E AY1_I AY1_S AY2_B AY2_E AY2_I AY2_S\nshared split B_B B_E B_I B_S\nshared split CH_B CH_E CH_I CH_S\nshared split D_B D_E D_I D_S\n```\n\n当创建这个roots文件时，你应该确保在每一行至少有一个音素是可见的（注：有对应的训练样本）。比如上面的情况，如果音素AY至少在声调和词位置的某些连接中可见，那就没问题。\n\n在这个例子中，对于slience等音素我们有很多的词位置相关的变种。它们将共享它们的pdf's，因为它们都在同一行，并且是“not-split”，但是它们可能会有不同的状态转移参数。实际上，silence的大多数变种都不可能用到，因为silence不可能出现在词与词之间；这只是为了防止以后有人做一些奇怪的事而不会过时。\n\n我们用从之前创建的模型（比如，单音素模型）得到的对齐结果来对混合高斯参数进行初始化；对齐的结果会被程序convert-ali从一棵树转换到另一棵（注：应该就是说对齐的transition不变，但状态绑定的参数可能因为决策树的不同而变化）。\n\n## PDF标号（PDF identifiers）\nPDF标号（pdf-id）是一个从0开始的数字，用做概率密度函数（p.d.f.）的序号。系统中每一个p.d.f.都有自己的pdf-id，并且是连续的（在一个LVCSR系统中一般会有几千个）。在树首先被构建时，它们就会被赋值。对于每一个pdf-id对应的是哪个音素，可能知道也可能不知道，这取决于树是怎样被构建的。\n\n## 上下文相关对象（Context dependency objects）\nContextDependencyInterface对象是树的一个虚基类，指定了如何与构建解码图代码进行交互。这个接口只包含四个函数：\n\n - ContextWidth()返回树需要的N（上下文窗的大小）的值。\n - CentralPosition()返回树需要的P（窗中心位置）的值\n - NumPdfs()返回树定义的pdfs的数量；pdfs的编号从0到NumPdfs()-1。\n - Compute()是对某个特殊的上下文计算它对应的pdf-id的函数\n \n  ContextDependencyInterface::Compute()函数的声明如下：\n  ```c++\n  class ContextDependencyInterface {\n   ...\n      virtual bool Compute(const std::vector<int32> &phoneseq, int32 pdf_class,\n                      int32 *pdf_id) const;\n  }\n  ```\n  如果能计算得到上下文和pdf-class对应的pdf-id，函数返回true。返回false时表明出现了一些错误或者是不匹配。这个函数使用的一个例子：\n  ```c++\n  ContextDependencyInterface *ctx_dep = ... ;\n  vector<int32> ctx_window = { 12, 15, 21 }; // not valid C++\n  int32 pdf_class = 1; // probably central state of 3-state HMM.\n  int32 pdf_id;\n  if(!ctx_dep->Compute(ctx_window, pdf_class, &pdf_id))\n        KALDI_ERR << \"Something went wrong!\"\n  else\n        KALDI_LOG << \"Got pdf-id, it is \" << pdf_id;\n  ```\n  目前唯一继承ContextDependencyInterface的类就是ContextDependency，ContextDependency有少量更丰富的接口；唯一主要的添加就是函数GetPdfInfo，被用于TransitionModel类算出一个特殊的pdf可能对应哪些音素（这个函数的功能可以被 ContextDependencyInterface接口遍历所有的上下文而实现）。\n\nContextDependency对象实际上是对EventMap对象的简单组合封装；请参见Decision tree internals。我们希望尽可能地隐藏树的真正实现，使得以后需要重构代码时变得非常简单。\n\n## 决策树的一个例子（An example of a decision tree）\n决策树文件的格式不是以人们的可读性为首要目标而创建的，但由于大家需要我们在这里试着解释如何去解读这个文件。请看下面的例子，这个是一个来自Wall Street Journal脚本中triphone的决策树。它以这个对象的名字ContextDependency开始（注：在代码中整个树是一个ContextDependency对象）；然后是N（上下文窗的大小），这里是3；接着是P（上下文窗的中心位置），这里是1。文件剩下的部分包含单个EventMap对象。EventMap是一个可能包含指向其他EventMap指针的多态类型。更多详细信息，请参见Event maps。这个文件表示一棵决策树或多棵决策树的集合，并将一个键值对集合（比如，left-phone=5, central-phone=10, right-phone=11, pdf-class=2（注：注意这里是四个键值对，表示一个中心音素是10，上文是音素5，下文是音素11的triphone的第2个状态））映射到一个pdf-id（比如，158）。简单来说，一个决策树包含三种基本类型：一个是SplitEventMap（就像决策树中的分支判断），一个是ConstantEventMap（就像决策树的叶子节点，只包含一个表示pdf-id的数字），和一个是TableEventMap（就像是一个包含其他EventMaps的一个查找表）。SplitEventMap和TableEventMap都有一个需要它们判断的key，这个值可能是0，1或者2，分别表示左上下文音素，中心音素和右上下文音素，也可能是-1，表示pdf-class的标号（注：如果HMM的每个状态都有对应的pdf，则pdf-class可理解为HMM的第几个状态）。一般情况，pdf-class的值与HMM状态的序号是相同的，比如0，1或2。请尝试不要因此而感到困惑：key是-1，value是0，1或2，但它们与上下文窗中音素的keys 0，1或2是没有任何关系的（注：上下文窗中0，1和2表示的是窗中音素的位置）。SplitEventMap有一系列值可以触发决策树的yes分支。下面是一种quasi-BNF符号表示的决策树文件格式。\n```\n         EventMap := ConstantEventMap | SplitEventMap | TableEventMap | \"NULL\"\n ConstantEventMap := \"CE\" <numeric pdf-id>\n    SplitEventMap := \"SE\" <key-to-split-on> \"[\" yes-value-list \"]\" \"{\" EventMap EventMap \"}\"\n    TableEventMap := \"TE\" <key-to-split-on> <table-size> \"(\" EventMapList \")\"\n```\n在下面的例子中，树顶层的EventMap是一个以key 1进行分裂的SplitEventMap，也就是按中心音素分裂。在方括号中是一系列连续范围的phone-ids。然而，这些并不表示一个问题，它们只是音素分裂的一种方法，因此我们可以得到每个音素真正的决策树（注：音素真正的决策树是根据音素上下文和pdf-class进行决策的，对中心音素的决策只是为了找到这个音素对应的真正的决策树）。问题在于这棵树是通过“shared roots”方式创建的，所以有很多与同一音素不同词位置和音调标识相关的phone-ids，它们都共享树的根节点。在这种情况下在树的顶层我们不能使用TableEventMap，否则我们就不得不将每棵树重复好几遍（因为EventMap是一棵纯树，而不是一个通用的图，它没有指针共享的机制）。文件后面的一些“SE”标签也是quasi-tree的一部分，它们都是首先按中心音素进行分裂（当我们顺着文件往下看时我们进入了树的更深处；注意这个花括号“{”一直是打开的，还没有关闭）。然后我们看到字符串“TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 ) ”，表示通过TableEventMap对pdf-class -1进行分裂（实际上就是，HMM-position），并且返回从0到4的值。这5个值表示的是静音和噪声音素SIL，NSN和SPN的5个pdf-ids。在我们的设定中，这三个非语音音素的pdfs是共享的（只有转移矩阵是不同的）。注意：对于这些音素我们用5状态而不是3状态的HMM，所以这里有5个不同的pdf-ids。接下来是“SE -1 [ 0 ] ”，这可以被认为是这棵树中第一个真正的问题。我们可以从上面的SE问题看出这个问题被应用于中心音素为4到19时候，也就是音素AA的不同版本（注：原文写的是5到19，不过我认为原文有问题，改成了4到19）。这个问题问的是pdf-class（key -1）是不是0（即是不是最左边的HMM-state）。下一个问题是“SE 2 [ 220 221 222 223 ]”，问的是音素右上下文是不是音素“M”不同形式中的一个（这是一个非常有效的问题，因为我们是在最左边的HMM-state）；如果问题的答案是yes，我们继续问“SE 0 [ 104 105 106 107... 286 287 ]”，这是一个关于音素左上下文的问题（注：原文写的是右上下文，但应该是左上下文）；如果答案是yes，则pdf-id就是5（“CE 5”），否则就是696（“CE 696”）。\n```\ns3# copy-tree --binary=false exp/tri1/tree - 2>/dev/null | head -100\nContextDependency 3 1 ToPdf SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \\\n26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59\\\n 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 9\\\n3 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 1\\\n20 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 14\\\n5 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170\\\n 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 \\\n196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 ]\n{ SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\\\n 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 6\\\n8 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 10\\\n1 102 103 104 105 106 107 108 109 110 111 ]\n{ SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\\\n 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ]\n{ SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ]\n{ SE 1 [ 1 2 3 ]\n{ TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 )\nSE -1 [ 0 ]\n{ SE 2 [ 220 221 222 223 ]\n{ SE 0 [ 104 105 106 107 112 113 114 115 172 173 174 175 208 209 210 211 212 213 214 215 264 265 266 \\\n267 280 281 282 283 284 285 286 287 ]\n{ CE 5 CE 696 }\nSE 2 [ 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 132 \\\n133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 248 249 250 251 252 253 254 255 256 257 2\\\n58 259 260 261 262 263 268 269 270 271 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 30\\\n3 ]\n```\n下面是一个更简单的例子：来自Resource Management脚本的单音素决策树。顶层的EventMap是一个TableEventMap（“TE 0 49 ...”）。key 0是音素位置0，表示中心（并且只有这一个）音素，因为上下文窗大小（N）为1。TE的条目数量是49（音素的数量加1）。表中第一个EventMap是NULL，因为没有序号为0的音素。下一个EventMap是一个有三个元素的TableEventMap，关联到第一个音素的三个HMM状态（技术上来说，是pdf-class）：“TE -1 3 ( CE 0 CE 1 CE 2 )”。\n```\ns3# copy-tree --binary=false exp/mono/tree - 2>/dev/null| head -5\nContextDependency 1 0 ToPdf TE 0 49 ( NULL TE -1 3 ( CE 0 CE 1 CE 2 )\nTE -1 3 ( CE 3 CE 4 CE 5 )\nTE -1 3 ( CE 6 CE 7 CE 8 )\nTE -1 3 ( CE 9 CE 10 CE 11 )\nTE -1 3 ( CE 12 CE 13 CE 14 )\n```\n## 输入符号信息对象（The ilabel_info object）\nCLG图（请参见Decoding graph construction in Kaldi）在它的输入符号位置上有表示上下文相关音素的符号（辅助符号和可能的空符号也一样）。在图中它们总是用整型的标签来表示。在代码和文件名中，我们使用一个叫做ilable_info的对象。ilable_info对象跟ContextFst对象有很密切的联系，请参见see The ContextFst object。就跟许多其他的Kaldi类型一样，ilabel_info也是一个通用的（STL）类型，但是为了可以辨别出是ilabel_info，我们使用与之相同的变量名。就是下面定义的类型：\n```c++\nstd::vector<std::vector<int32> > ilabel_info;\n```\n它是一个以FST输入标签为索引的vector，给每一个输入标签一个对应的音素上下文窗（参见上文，Phonetic context windows）。比如，假设符号1500是左上下文是12和右上下文是4的音素30，我们有：\n```c++\n// not valid C++\nilabel_info[1500] == { 4, 30, 12 };\n```\n在单音素的情况下，我们就会像这样：\n```c++\nilabel_info[30] == { 28 }\n```\n处理辅助符号会有点特殊（参见Disambiguation symbols或者上面引用的Springer Handbook文献，该文献解释了这些辅助符号是什么）。如果一条ilabel_info记录对应到一个辅助符号，我们就把辅助符号的符号表序号取负值放进去（注意这跟辅助符号打印形式#0，#1，#2等等里面的数字是不一样的，它是跟这些辅助符号在符号表文件中的顺序相关的数字，这个符号表文件在我们现在的脚本中叫做phones_disambig.txt）。比如，\n```c++\nilabel_info[5] == { -42 }\n```\n意味着在HCLG中符号数5对应到整数id是42的辅助符号。为了编程方便我们对这些id取负号，因此解析ilable_info对象的程序不需要给一个辅助符号的列表就可以在单音素情况下将它们跟真实的音素进行区分。有两个额外特殊情况：\n```c++\nilabel_info[0] == { }; // epsilon\nilabel_info[1] == { 0 }; // disambig symbol #-1;\n// we use symbol 1, but don't consider this hardwired.\n```\n第一个是正常的空符号，我们给它一个空的vector作为它的ilabel_info。这个符号一般不会出现在CLG的左边（注：应该是说不会作为CLG的输入符号）。第二个是一个特殊的辅助符号，打印形式叫做“#-1”。在epsilons被用做标准（Springer Handbook）脚本中C转换器输入符号的时候，我们使用辅助符号“#-1”。它可以确保有空音素表示的词的CLG网络可以被确定化。\n\n程序fstmakecontextsyms可以创建一个与ilabel_info对象打印形式对应的符号表；这个主要用于调试和诊断错误。\n","slug":"Kaldi决策树如何使用","published":1,"updated":"2023-01-03T14:04:35.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgb13uh0001j6eqcl1d209z","content":"<p>说明：本文是kaldi主页相关内容的翻译（http://kaldi-asr.org/doc/tree_externals.html\n）。目前网上已经有一个翻译的版本，但翻译的不是很清楚，导致我在刚学这部分内容的时候产生了一些误解，所以我希望结合我目前所知道的一些东西，尽量把这部分内容翻译地比较容易理解，但由于也是初学者，一些错误也是不可避免，希望大家发现后一起交流，以便我后期修正。好了，还是废话少说吧。</p>\n<span id=\"more\"></span>\n<h2 id=\"介绍introduction\">介绍（Introduction）</h2>\n<p>本页将对声学决策树在kaldi中如何被创建和使用，以及如何在训练和解码图构建过程进行运用给出一个概述性的解释。对于构建决策树代码的内部描述，请参见Decision\ntree internals；对于构建解码图方法的详细信息，可以参见Decoding graph\nconstruction in Kaldi。</p>\n<p>实现的基本算法就是自顶向下的贪婪分裂，通过问一些问题，比如说左边的音素，右边的音素，中心音素以及当前的状态等等，我们会得到很多可以把数据进行分裂的路径。我们实现的算法与标准算法非常相似，请参见Young，Odell和Woodland的这篇论文\"Tree-based\nState Tying for High Accuracy Acoustic Modeling\"\n。假设我们对数据建模时采用单高斯将它们分成两部分，在这个算法中，我们通过选择局部最优的问题进行数据分裂，也就是使得似然值增加最大的那个问题。与标准算法实现不同的地方包括可以自由配置树的根节点；对HMM状态和中心音素相关问题提问的能力；以及实际上在Kaldi脚本中默认情况下，问题集是通过对数据自顶向下的二分聚类自动生成的，这就意味着不需要手动去创建问题集。关于树的根节点的配置：可能是把一个共享的群组里面所有音素分裂的统计量，或者独立的音素，或者每个音素的HMM状态，作为树的根节点来进行分裂，或者把音素组作为树的根节点（注：多个音素作为一棵树的根节点）。对于如何用标准的脚本配置根节点，请参见Data\npreparation。实际上，我们一般让每棵树的根节点都对应一个真实的音素（real\nphone），意思就是说我们把每个音素的词位置相关、发音相关或者音调相关的所有变种都放进一个音素组，作为决策树的根节点。</p>\n<p>本页下面主要给出相关代码层面的一些详细信息。</p>\n<h2 id=\"音素上下文窗phonetic-context-windows\">音素上下文窗（Phonetic\ncontext windows）</h2>\n<p>这里我们解释一下在代码中我们怎样描述一个音素的上下文。一棵特殊的决策树将有两个整型值，分别描述的是上下文窗的宽度和中心位置。下表简单说明了这两个值：\n<img\nsrc=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNjA4MTQwNjU3MTkx?x-oss-process=image/format,png\"\nalt=\"这里写图片描述\" />\nN是上下文窗的宽度，P是设计的中心音素的标记。一般P就是窗的中心（因此叫中心位置）；举例说，当N=3时我们一般设P=1，但是我们也可以从0到N-1自由选择；比如，P=2和N=3意味着有左上下文有两个音素，并且没有右上下文。在代码中，当我们讨论中心音素时，我们总是认为讨论的是第P个音素，可能是也可能不是上下文窗中心的那个音素。</p>\n<p>一个用来表示典型的triphone上下文窗的整型向量可能是： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//probably not valid C++</span></span><br><span class=\"line\">vector&lt;int32&gt; ctx_window = &#123; <span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">21</span> &#125;;</span><br></pre></td></tr></table></figure>\n假设N=3和P=1，这个表示有一个右上下文21和一个左上下文12的音素15。我们处理端点位置上下文的一个方式是使用0（0不是一个合法的音素，因为在OpenFst中0是为空符号epsilon而保留的），所以比如：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int32&gt; ctx_window = &#123; <span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>&#125;;</span><br></pre></td></tr></table></figure>\n表示有一个左上下文12和没有右上下文的音素15，因为音素15是句子的结尾。在句子结尾这种特殊的地方，0这种方式的使用可能有一点意外，因为最后一个“音素”实际上是后续符号“$”（参见Making\nthe context\ntransducer），但是为了在决策树代码中的便利，我们不把后续符号放进上下文窗，而是把0放进去。注意，如果此时我们N=3和P=2，那上述的上下文窗是非法的，因为第P个元素是一个不能表示任何真实音素的0；当然同样如果我们有一个N=1的树，上面的窗都是不合法的，因为那些窗的大小都是错误的。在单音素的情况下，我们可以有一个如下的窗：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int32&gt; ctx_window = &#123; <span class=\"number\">15</span> &#125;;</span><br></pre></td></tr></table></figure>\n因此单音素系统只是被当成上下文相关系统的一种特殊情况，窗的大小N等于1，并且还有一棵什么都不做的树（注：经过这棵树后没有任何参数被绑定）。</p>\n<h2 id=\"树的构建过程the-tree-building-process\">树的构建过程（The tree\nbuilding process）</h2>\n<p>在这部分我们给出Kaldi中树构建过程的一个概述。</p>\n<p>即使是单音素系统也有一个决策树，但是是一个无用的树。参见返回这样一个无用树的函数MonophoneContextDependency()\n和\nMonophoneContextDependencyShared()。这两个函数被命令行程序gmm-init-mono调用；它主要的输入参数是HmmTopology对象，并且输出一棵树，这棵树通常会被以ContextDependency类型的对象写到一个叫做“tree”的文件中，以及模型文件（模型文件包含一个TransitionModel对象和一个AmDiagGmm对象）。如果程序gmm-init-mono接受一个叫-shared-phones的可选参数，它将会在指定的音素序列间共享pdfs（注：输出概率密度函数，比如高斯），否则它会使得所有的音素都是独立的。</p>\n<p>从一个扁平的初始（注：除了sil，所有的单音素模型都是一样的）开始训练一个单音素系统后，我们拿单音素对齐的结果和使用函数AccumulateTreeStats()（被acc-tree-stats调用）来累积训练决策树的统计量。这个程序不限于读取单音素的对齐结果；它也能读取上下文相关的对齐结果，因此我们也可以基于triphone对齐结果来构建树。构建树的统计量以BuildTreeStatsType类型（参见Statistics\nfor building the\ntree）被写到磁盘。函数AccumulateTreeStats()输入N和P的值，N和P就是上文解释过的上下文窗的大小和中心音素位置。命令行程序会默认地将N和P设为3和1，但是也可以使用–context-width和–central-position可选参数进行覆盖。程序acc-tree-stats输入一个上下文无关的音素列表（比如，silence），但是即使存在上下文无关的音素，这个也不是必需的；它只是减少统计量大小的一个机制。对于上下文无关的音素，程序将会累积一个没有定义keys的相关的统计量，keys是跟左右音素对应的（注：在代码中会把一个音素不同的上下文和pdf-class分别作为不同的key，然后累积每个key的统计量）（c.f.\nEvent maps）。</p>\n<p>当统计量被积累后，我们使用程序build-tree来构建树。这个程序输出一棵树。程序build-tree需要三样东西：</p>\n<ul>\n<li>统计量（BuildTreeStatsType类型）</li>\n<li>问题集配置（Questions类型）</li>\n<li>roots文件（参见下面）</li>\n</ul>\n<p>统计量一般从程序acc-tree-stats得到；问题集配置类可以用程序compile-questions输出，compile-questions输入一个声学问题集的拓扑列表（在我们的脚本中，这些都是自动地从构建树的统计量通过程序cluster-phones得到）（注：cluster-phones输入构建树的统计量可以得到一个声学问题集）。roots文件指定了将要在决策树聚类过程中共享根节点的音素集，并且对每个音素集指出下面两个东西：</p>\n<ul>\n<li>“shared”或者“not-shared”指出是每个pdf-class（也就是一般情况下的HMM状态）都有不同的根节点，还是所有pdf-class共享一个根节点。如果是“shared”，对于所有的HMM状态（比如在正常的HMM拓扑下所有的三个状态）将只会有一个树根节点；如果是“not-shared”，将会有三个树根节点，每个pdf-class有一个。</li>\n<li>“split”或者“not-split”指出对于根节点要不要根据问题进行决策树分裂（对于silence，我们一般不分裂）。如果该行指定“split”（正常情况），那么我们进行决策树分裂。如果指定“not-split”，那么就不会进行分裂，因此根节点就被无分裂地保留。</li>\n</ul>\n<p>下面将对这个怎样使用方面做一些阐述：</p>\n<ul>\n<li>如果我们指定“shared\nsplit”，即使所有的三个HMM状态有一个根节点，不同的HMM状态仍然可以到达不同的叶子节点，因为树可以像对声学上下文的问题提问一样对pdf-class的问题提问。</li>\n<li>对于roots文件中同一行出现的所有音素，我们总是让它们共享根节点。如果你不想共享音素的根节点，你只要把它们放在不同的行。</li>\n</ul>\n<p>下面是roots文件的一个例子；假设音素1是silence，并且其他的音素都有不同的根节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">not-shared not-split  1</span><br><span class=\"line\">shared split  2</span><br><span class=\"line\">...</span><br><span class=\"line\">shared split  28</span><br></pre></td></tr></table></figure>\n<p>当我们有比如位置和声调相关的音素时，将多个音素放在同一行会非常有用；这样每个“真实的“音素将关联到一个整数的音素ID集合。在这种情况下我们将particular\nunderlying（注：这个不知道怎么翻译）音素的所有变种版本共享一个根节点。下面是来自egs/wsj/s5脚本中Wall\nStreet\nJournal的roots文件的一个例子（这个例子中音素是用文本表示的，而不是整数形式；但在被Kaldi读取之前会被转换成整数形式（注：就是会把音素映射成整数的ID））：\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">not-shared not-split SIL SIL_B SIL_E SIL_I SIL_S SPN SPN_B SPN_E SPN_I SPN_S NSN NSN_B NSN_E NSN_I NSN_S</span><br><span class=\"line\">shared split AA_B AA_E AA_I AA_S AA0_B AA0_E AA0_I AA0_S AA1_B AA1_E AA1_I AA1_S AA2_B AA2_E AA2_I AA2_S</span><br><span class=\"line\">shared split AE_B AE_E AE_I AE_S AE0_B AE0_E AE0_I AE0_S AE1_B AE1_E AE1_I AE1_S AE2_B AE2_E AE2_I AE2_S</span><br><span class=\"line\">shared split AH_B AH_E AH_I AH_S AH0_B AH0_E AH0_I AH0_S AH1_B AH1_E AH1_I AH1_S AH2_B AH2_E AH2_I AH2_S</span><br><span class=\"line\">shared split AO_B AO_E AO_I AO_S AO0_B AO0_E AO0_I AO0_S AO1_B AO1_E AO1_I AO1_S AO2_B AO2_E AO2_I AO2_S</span><br><span class=\"line\">shared split AW_B AW_E AW_I AW_S AW0_B AW0_E AW0_I AW0_S AW1_B AW1_E AW1_I AW1_S AW2_B AW2_E AW2_I AW2_S</span><br><span class=\"line\">shared split AY_B AY_E AY_I AY_S AY0_B AY0_E AY0_I AY0_S AY1_B AY1_E AY1_I AY1_S AY2_B AY2_E AY2_I AY2_S</span><br><span class=\"line\">shared split B_B B_E B_I B_S</span><br><span class=\"line\">shared split CH_B CH_E CH_I CH_S</span><br><span class=\"line\">shared split D_B D_E D_I D_S</span><br></pre></td></tr></table></figure></p>\n<p>当创建这个roots文件时，你应该确保在每一行至少有一个音素是可见的（注：有对应的训练样本）。比如上面的情况，如果音素AY至少在声调和词位置的某些连接中可见，那就没问题。</p>\n<p>在这个例子中，对于slience等音素我们有很多的词位置相关的变种。它们将共享它们的pdf's，因为它们都在同一行，并且是“not-split”，但是它们可能会有不同的状态转移参数。实际上，silence的大多数变种都不可能用到，因为silence不可能出现在词与词之间；这只是为了防止以后有人做一些奇怪的事而不会过时。</p>\n<p>我们用从之前创建的模型（比如，单音素模型）得到的对齐结果来对混合高斯参数进行初始化；对齐的结果会被程序convert-ali从一棵树转换到另一棵（注：应该就是说对齐的transition不变，但状态绑定的参数可能因为决策树的不同而变化）。</p>\n<h2 id=\"pdf标号pdf-identifiers\">PDF标号（PDF identifiers）</h2>\n<p>PDF标号（pdf-id）是一个从0开始的数字，用做概率密度函数（p.d.f.）的序号。系统中每一个p.d.f.都有自己的pdf-id，并且是连续的（在一个LVCSR系统中一般会有几千个）。在树首先被构建时，它们就会被赋值。对于每一个pdf-id对应的是哪个音素，可能知道也可能不知道，这取决于树是怎样被构建的。</p>\n<h2\nid=\"上下文相关对象context-dependency-objects\">上下文相关对象（Context\ndependency objects）</h2>\n<p>ContextDependencyInterface对象是树的一个虚基类，指定了如何与构建解码图代码进行交互。这个接口只包含四个函数：</p>\n<ul>\n<li>ContextWidth()返回树需要的N（上下文窗的大小）的值。</li>\n<li>CentralPosition()返回树需要的P（窗中心位置）的值</li>\n<li>NumPdfs()返回树定义的pdfs的数量；pdfs的编号从0到NumPdfs()-1。</li>\n<li>Compute()是对某个特殊的上下文计算它对应的pdf-id的函数</li>\n</ul>\n<p>ContextDependencyInterface::Compute()函数的声明如下： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ContextDependencyInterface</span> &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">Compute</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;int32&gt; &amp;phoneseq, int32 pdf_class,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    int32 *pdf_id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n如果能计算得到上下文和pdf-class对应的pdf-id，函数返回true。返回false时表明出现了一些错误或者是不匹配。这个函数使用的一个例子：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContextDependencyInterface *ctx_dep = ... ;</span><br><span class=\"line\">vector&lt;int32&gt; ctx_window = &#123; <span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">21</span> &#125;; <span class=\"comment\">// not valid C++</span></span><br><span class=\"line\">int32 pdf_class = <span class=\"number\">1</span>; <span class=\"comment\">// probably central state of 3-state HMM.</span></span><br><span class=\"line\">int32 pdf_id;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!ctx_dep-&gt;<span class=\"built_in\">Compute</span>(ctx_window, pdf_class, &amp;pdf_id))</span><br><span class=\"line\">      KALDI_ERR &lt;&lt; <span class=\"string\">&quot;Something went wrong!&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">      KALDI_LOG &lt;&lt; <span class=\"string\">&quot;Got pdf-id, it is &quot;</span> &lt;&lt; pdf_id;</span><br></pre></td></tr></table></figure>\n目前唯一继承ContextDependencyInterface的类就是ContextDependency，ContextDependency有少量更丰富的接口；唯一主要的添加就是函数GetPdfInfo，被用于TransitionModel类算出一个特殊的pdf可能对应哪些音素（这个函数的功能可以被\nContextDependencyInterface接口遍历所有的上下文而实现）。</p>\n<p>ContextDependency对象实际上是对EventMap对象的简单组合封装；请参见Decision\ntree\ninternals。我们希望尽可能地隐藏树的真正实现，使得以后需要重构代码时变得非常简单。</p>\n<h2\nid=\"决策树的一个例子an-example-of-a-decision-tree\">决策树的一个例子（An\nexample of a decision tree）</h2>\n<p>决策树文件的格式不是以人们的可读性为首要目标而创建的，但由于大家需要我们在这里试着解释如何去解读这个文件。请看下面的例子，这个是一个来自Wall\nStreet\nJournal脚本中triphone的决策树。它以这个对象的名字ContextDependency开始（注：在代码中整个树是一个ContextDependency对象）；然后是N（上下文窗的大小），这里是3；接着是P（上下文窗的中心位置），这里是1。文件剩下的部分包含单个EventMap对象。EventMap是一个可能包含指向其他EventMap指针的多态类型。更多详细信息，请参见Event\nmaps。这个文件表示一棵决策树或多棵决策树的集合，并将一个键值对集合（比如，left-phone=5,\ncentral-phone=10, right-phone=11,\npdf-class=2（注：注意这里是四个键值对，表示一个中心音素是10，上文是音素5，下文是音素11的triphone的第2个状态））映射到一个pdf-id（比如，158）。简单来说，一个决策树包含三种基本类型：一个是SplitEventMap（就像决策树中的分支判断），一个是ConstantEventMap（就像决策树的叶子节点，只包含一个表示pdf-id的数字），和一个是TableEventMap（就像是一个包含其他EventMaps的一个查找表）。SplitEventMap和TableEventMap都有一个需要它们判断的key，这个值可能是0，1或者2，分别表示左上下文音素，中心音素和右上下文音素，也可能是-1，表示pdf-class的标号（注：如果HMM的每个状态都有对应的pdf，则pdf-class可理解为HMM的第几个状态）。一般情况，pdf-class的值与HMM状态的序号是相同的，比如0，1或2。请尝试不要因此而感到困惑：key是-1，value是0，1或2，但它们与上下文窗中音素的keys\n0，1或2是没有任何关系的（注：上下文窗中0，1和2表示的是窗中音素的位置）。SplitEventMap有一系列值可以触发决策树的yes分支。下面是一种quasi-BNF符号表示的决策树文件格式。\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        EventMap := ConstantEventMap | SplitEventMap | TableEventMap | &quot;NULL&quot;</span><br><span class=\"line\">ConstantEventMap := &quot;CE&quot; &lt;numeric pdf-id&gt;</span><br><span class=\"line\">   SplitEventMap := &quot;SE&quot; &lt;key-to-split-on&gt; &quot;[&quot; yes-value-list &quot;]&quot; &quot;&#123;&quot; EventMap EventMap &quot;&#125;&quot;</span><br><span class=\"line\">   TableEventMap := &quot;TE&quot; &lt;key-to-split-on&gt; &lt;table-size&gt; &quot;(&quot; EventMapList &quot;)&quot;</span><br></pre></td></tr></table></figure> 在下面的例子中，树顶层的EventMap是一个以key\n1进行分裂的SplitEventMap，也就是按中心音素分裂。在方括号中是一系列连续范围的phone-ids。然而，这些并不表示一个问题，它们只是音素分裂的一种方法，因此我们可以得到每个音素真正的决策树（注：音素真正的决策树是根据音素上下文和pdf-class进行决策的，对中心音素的决策只是为了找到这个音素对应的真正的决策树）。问题在于这棵树是通过“shared\nroots”方式创建的，所以有很多与同一音素不同词位置和音调标识相关的phone-ids，它们都共享树的根节点。在这种情况下在树的顶层我们不能使用TableEventMap，否则我们就不得不将每棵树重复好几遍（因为EventMap是一棵纯树，而不是一个通用的图，它没有指针共享的机制）。文件后面的一些“SE”标签也是quasi-tree的一部分，它们都是首先按中心音素进行分裂（当我们顺着文件往下看时我们进入了树的更深处；注意这个花括号“{”一直是打开的，还没有关闭）。然后我们看到字符串“TE\n-1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 ) ”，表示通过TableEventMap对pdf-class\n-1进行分裂（实际上就是，HMM-position），并且返回从0到4的值。这5个值表示的是静音和噪声音素SIL，NSN和SPN的5个pdf-ids。在我们的设定中，这三个非语音音素的pdfs是共享的（只有转移矩阵是不同的）。注意：对于这些音素我们用5状态而不是3状态的HMM，所以这里有5个不同的pdf-ids。接下来是“SE\n-1 [ 0 ]\n”，这可以被认为是这棵树中第一个真正的问题。我们可以从上面的SE问题看出这个问题被应用于中心音素为4到19时候，也就是音素AA的不同版本（注：原文写的是5到19，不过我认为原文有问题，改成了4到19）。这个问题问的是pdf-class（key\n-1）是不是0（即是不是最左边的HMM-state）。下一个问题是“SE 2 [ 220 221\n222 223\n]”，问的是音素右上下文是不是音素“M”不同形式中的一个（这是一个非常有效的问题，因为我们是在最左边的HMM-state）；如果问题的答案是yes，我们继续问“SE\n0 [ 104 105 106 107... 286 287\n]”，这是一个关于音素左上下文的问题（注：原文写的是右上下文，但应该是左上下文）；如果答案是yes，则pdf-id就是5（“CE\n5”），否则就是696（“CE 696”）。 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s3# copy-tree --binary=false exp/tri1/tree - 2&gt;/dev/null | head -100</span><br><span class=\"line\">ContextDependency 3 1 ToPdf SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \\</span><br><span class=\"line\">26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59\\</span><br><span class=\"line\"> 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 9\\</span><br><span class=\"line\">3 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 1\\</span><br><span class=\"line\">20 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 14\\</span><br><span class=\"line\">5 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170\\</span><br><span class=\"line\"> 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 \\</span><br><span class=\"line\">196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 ]</span><br><span class=\"line\">&#123; SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\\</span><br><span class=\"line\"> 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 6\\</span><br><span class=\"line\">8 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 10\\</span><br><span class=\"line\">1 102 103 104 105 106 107 108 109 110 111 ]</span><br><span class=\"line\">&#123; SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\\</span><br><span class=\"line\"> 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ]</span><br><span class=\"line\">&#123; SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ]</span><br><span class=\"line\">&#123; SE 1 [ 1 2 3 ]</span><br><span class=\"line\">&#123; TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 )</span><br><span class=\"line\">SE -1 [ 0 ]</span><br><span class=\"line\">&#123; SE 2 [ 220 221 222 223 ]</span><br><span class=\"line\">&#123; SE 0 [ 104 105 106 107 112 113 114 115 172 173 174 175 208 209 210 211 212 213 214 215 264 265 266 \\</span><br><span class=\"line\">267 280 281 282 283 284 285 286 287 ]</span><br><span class=\"line\">&#123; CE 5 CE 696 &#125;</span><br><span class=\"line\">SE 2 [ 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 132 \\</span><br><span class=\"line\">133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 248 249 250 251 252 253 254 255 256 257 2\\</span><br><span class=\"line\">58 259 260 261 262 263 268 269 270 271 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 30\\</span><br><span class=\"line\">3 ]</span><br></pre></td></tr></table></figure>\n下面是一个更简单的例子：来自Resource\nManagement脚本的单音素决策树。顶层的EventMap是一个TableEventMap（“TE 0\n49 ...”）。key\n0是音素位置0，表示中心（并且只有这一个）音素，因为上下文窗大小（N）为1。TE的条目数量是49（音素的数量加1）。表中第一个EventMap是NULL，因为没有序号为0的音素。下一个EventMap是一个有三个元素的TableEventMap，关联到第一个音素的三个HMM状态（技术上来说，是pdf-class）：“TE\n-1 3 ( CE 0 CE 1 CE 2 )”。 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s3# copy-tree --binary=false exp/mono/tree - 2&gt;/dev/null| head -5</span><br><span class=\"line\">ContextDependency 1 0 ToPdf TE 0 49 ( NULL TE -1 3 ( CE 0 CE 1 CE 2 )</span><br><span class=\"line\">TE -1 3 ( CE 3 CE 4 CE 5 )</span><br><span class=\"line\">TE -1 3 ( CE 6 CE 7 CE 8 )</span><br><span class=\"line\">TE -1 3 ( CE 9 CE 10 CE 11 )</span><br><span class=\"line\">TE -1 3 ( CE 12 CE 13 CE 14 )</span><br></pre></td></tr></table></figure> ## 输入符号信息对象（The\nilabel_info object） CLG图（请参见Decoding graph construction in\nKaldi）在它的输入符号位置上有表示上下文相关音素的符号（辅助符号和可能的空符号也一样）。在图中它们总是用整型的标签来表示。在代码和文件名中，我们使用一个叫做ilable_info的对象。ilable_info对象跟ContextFst对象有很密切的联系，请参见see\nThe ContextFst\nobject。就跟许多其他的Kaldi类型一样，ilabel_info也是一个通用的（STL）类型，但是为了可以辨别出是ilabel_info，我们使用与之相同的变量名。就是下面定义的类型：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;std::vector&lt;int32&gt; &gt; ilabel_info;</span><br></pre></td></tr></table></figure>\n它是一个以FST输入标签为索引的vector，给每一个输入标签一个对应的音素上下文窗（参见上文，Phonetic\ncontext\nwindows）。比如，假设符号1500是左上下文是12和右上下文是4的音素30，我们有：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// not valid C++</span></span><br><span class=\"line\">ilabel_info[<span class=\"number\">1500</span>] == &#123; <span class=\"number\">4</span>, <span class=\"number\">30</span>, <span class=\"number\">12</span> &#125;;</span><br></pre></td></tr></table></figure> 在单音素的情况下，我们就会像这样： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ilabel_info[<span class=\"number\">30</span>] == &#123; <span class=\"number\">28</span> &#125;</span><br></pre></td></tr></table></figure>\n处理辅助符号会有点特殊（参见Disambiguation symbols或者上面引用的Springer\nHandbook文献，该文献解释了这些辅助符号是什么）。如果一条ilabel_info记录对应到一个辅助符号，我们就把辅助符号的符号表序号取负值放进去（注意这跟辅助符号打印形式#0，#1，#2等等里面的数字是不一样的，它是跟这些辅助符号在符号表文件中的顺序相关的数字，这个符号表文件在我们现在的脚本中叫做phones_disambig.txt）。比如，\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ilabel_info[<span class=\"number\">5</span>] == &#123; <span class=\"number\">-42</span> &#125;</span><br></pre></td></tr></table></figure>\n意味着在HCLG中符号数5对应到整数id是42的辅助符号。为了编程方便我们对这些id取负号，因此解析ilable_info对象的程序不需要给一个辅助符号的列表就可以在单音素情况下将它们跟真实的音素进行区分。有两个额外特殊情况：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ilabel_info[<span class=\"number\">0</span>] == &#123; &#125;; <span class=\"comment\">// epsilon</span></span><br><span class=\"line\">ilabel_info[<span class=\"number\">1</span>] == &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">// disambig symbol #-1;</span></span><br><span class=\"line\"><span class=\"comment\">// we use symbol 1, but don&#x27;t consider this hardwired.</span></span><br></pre></td></tr></table></figure>\n第一个是正常的空符号，我们给它一个空的vector作为它的ilabel_info。这个符号一般不会出现在CLG的左边（注：应该是说不会作为CLG的输入符号）。第二个是一个特殊的辅助符号，打印形式叫做“#-1”。在epsilons被用做标准（Springer\nHandbook）脚本中C转换器输入符号的时候，我们使用辅助符号“#-1”。它可以确保有空音素表示的词的CLG网络可以被确定化。</p>\n<p>程序fstmakecontextsyms可以创建一个与ilabel_info对象打印形式对应的符号表；这个主要用于调试和诊断错误。</p>\n","site":{"data":{}},"excerpt":"<p>说明：本文是kaldi主页相关内容的翻译（http://kaldi-asr.org/doc/tree_externals.html\n）。目前网上已经有一个翻译的版本，但翻译的不是很清楚，导致我在刚学这部分内容的时候产生了一些误解，所以我希望结合我目前所知道的一些东西，尽量把这部分内容翻译地比较容易理解，但由于也是初学者，一些错误也是不可避免，希望大家发现后一起交流，以便我后期修正。好了，还是废话少说吧。</p>","more":"<h2 id=\"介绍introduction\">介绍（Introduction）</h2>\n<p>本页将对声学决策树在kaldi中如何被创建和使用，以及如何在训练和解码图构建过程进行运用给出一个概述性的解释。对于构建决策树代码的内部描述，请参见Decision\ntree internals；对于构建解码图方法的详细信息，可以参见Decoding graph\nconstruction in Kaldi。</p>\n<p>实现的基本算法就是自顶向下的贪婪分裂，通过问一些问题，比如说左边的音素，右边的音素，中心音素以及当前的状态等等，我们会得到很多可以把数据进行分裂的路径。我们实现的算法与标准算法非常相似，请参见Young，Odell和Woodland的这篇论文\"Tree-based\nState Tying for High Accuracy Acoustic Modeling\"\n。假设我们对数据建模时采用单高斯将它们分成两部分，在这个算法中，我们通过选择局部最优的问题进行数据分裂，也就是使得似然值增加最大的那个问题。与标准算法实现不同的地方包括可以自由配置树的根节点；对HMM状态和中心音素相关问题提问的能力；以及实际上在Kaldi脚本中默认情况下，问题集是通过对数据自顶向下的二分聚类自动生成的，这就意味着不需要手动去创建问题集。关于树的根节点的配置：可能是把一个共享的群组里面所有音素分裂的统计量，或者独立的音素，或者每个音素的HMM状态，作为树的根节点来进行分裂，或者把音素组作为树的根节点（注：多个音素作为一棵树的根节点）。对于如何用标准的脚本配置根节点，请参见Data\npreparation。实际上，我们一般让每棵树的根节点都对应一个真实的音素（real\nphone），意思就是说我们把每个音素的词位置相关、发音相关或者音调相关的所有变种都放进一个音素组，作为决策树的根节点。</p>\n<p>本页下面主要给出相关代码层面的一些详细信息。</p>\n<h2 id=\"音素上下文窗phonetic-context-windows\">音素上下文窗（Phonetic\ncontext windows）</h2>\n<p>这里我们解释一下在代码中我们怎样描述一个音素的上下文。一棵特殊的决策树将有两个整型值，分别描述的是上下文窗的宽度和中心位置。下表简单说明了这两个值：\n<img\nsrc=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNjA4MTQwNjU3MTkx?x-oss-process=image/format,png\"\nalt=\"这里写图片描述\" />\nN是上下文窗的宽度，P是设计的中心音素的标记。一般P就是窗的中心（因此叫中心位置）；举例说，当N=3时我们一般设P=1，但是我们也可以从0到N-1自由选择；比如，P=2和N=3意味着有左上下文有两个音素，并且没有右上下文。在代码中，当我们讨论中心音素时，我们总是认为讨论的是第P个音素，可能是也可能不是上下文窗中心的那个音素。</p>\n<p>一个用来表示典型的triphone上下文窗的整型向量可能是： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//probably not valid C++</span></span><br><span class=\"line\">vector&lt;int32&gt; ctx_window = &#123; <span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">21</span> &#125;;</span><br></pre></td></tr></table></figure>\n假设N=3和P=1，这个表示有一个右上下文21和一个左上下文12的音素15。我们处理端点位置上下文的一个方式是使用0（0不是一个合法的音素，因为在OpenFst中0是为空符号epsilon而保留的），所以比如：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int32&gt; ctx_window = &#123; <span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>&#125;;</span><br></pre></td></tr></table></figure>\n表示有一个左上下文12和没有右上下文的音素15，因为音素15是句子的结尾。在句子结尾这种特殊的地方，0这种方式的使用可能有一点意外，因为最后一个“音素”实际上是后续符号“$”（参见Making\nthe context\ntransducer），但是为了在决策树代码中的便利，我们不把后续符号放进上下文窗，而是把0放进去。注意，如果此时我们N=3和P=2，那上述的上下文窗是非法的，因为第P个元素是一个不能表示任何真实音素的0；当然同样如果我们有一个N=1的树，上面的窗都是不合法的，因为那些窗的大小都是错误的。在单音素的情况下，我们可以有一个如下的窗：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int32&gt; ctx_window = &#123; <span class=\"number\">15</span> &#125;;</span><br></pre></td></tr></table></figure>\n因此单音素系统只是被当成上下文相关系统的一种特殊情况，窗的大小N等于1，并且还有一棵什么都不做的树（注：经过这棵树后没有任何参数被绑定）。</p>\n<h2 id=\"树的构建过程the-tree-building-process\">树的构建过程（The tree\nbuilding process）</h2>\n<p>在这部分我们给出Kaldi中树构建过程的一个概述。</p>\n<p>即使是单音素系统也有一个决策树，但是是一个无用的树。参见返回这样一个无用树的函数MonophoneContextDependency()\n和\nMonophoneContextDependencyShared()。这两个函数被命令行程序gmm-init-mono调用；它主要的输入参数是HmmTopology对象，并且输出一棵树，这棵树通常会被以ContextDependency类型的对象写到一个叫做“tree”的文件中，以及模型文件（模型文件包含一个TransitionModel对象和一个AmDiagGmm对象）。如果程序gmm-init-mono接受一个叫-shared-phones的可选参数，它将会在指定的音素序列间共享pdfs（注：输出概率密度函数，比如高斯），否则它会使得所有的音素都是独立的。</p>\n<p>从一个扁平的初始（注：除了sil，所有的单音素模型都是一样的）开始训练一个单音素系统后，我们拿单音素对齐的结果和使用函数AccumulateTreeStats()（被acc-tree-stats调用）来累积训练决策树的统计量。这个程序不限于读取单音素的对齐结果；它也能读取上下文相关的对齐结果，因此我们也可以基于triphone对齐结果来构建树。构建树的统计量以BuildTreeStatsType类型（参见Statistics\nfor building the\ntree）被写到磁盘。函数AccumulateTreeStats()输入N和P的值，N和P就是上文解释过的上下文窗的大小和中心音素位置。命令行程序会默认地将N和P设为3和1，但是也可以使用–context-width和–central-position可选参数进行覆盖。程序acc-tree-stats输入一个上下文无关的音素列表（比如，silence），但是即使存在上下文无关的音素，这个也不是必需的；它只是减少统计量大小的一个机制。对于上下文无关的音素，程序将会累积一个没有定义keys的相关的统计量，keys是跟左右音素对应的（注：在代码中会把一个音素不同的上下文和pdf-class分别作为不同的key，然后累积每个key的统计量）（c.f.\nEvent maps）。</p>\n<p>当统计量被积累后，我们使用程序build-tree来构建树。这个程序输出一棵树。程序build-tree需要三样东西：</p>\n<ul>\n<li>统计量（BuildTreeStatsType类型）</li>\n<li>问题集配置（Questions类型）</li>\n<li>roots文件（参见下面）</li>\n</ul>\n<p>统计量一般从程序acc-tree-stats得到；问题集配置类可以用程序compile-questions输出，compile-questions输入一个声学问题集的拓扑列表（在我们的脚本中，这些都是自动地从构建树的统计量通过程序cluster-phones得到）（注：cluster-phones输入构建树的统计量可以得到一个声学问题集）。roots文件指定了将要在决策树聚类过程中共享根节点的音素集，并且对每个音素集指出下面两个东西：</p>\n<ul>\n<li>“shared”或者“not-shared”指出是每个pdf-class（也就是一般情况下的HMM状态）都有不同的根节点，还是所有pdf-class共享一个根节点。如果是“shared”，对于所有的HMM状态（比如在正常的HMM拓扑下所有的三个状态）将只会有一个树根节点；如果是“not-shared”，将会有三个树根节点，每个pdf-class有一个。</li>\n<li>“split”或者“not-split”指出对于根节点要不要根据问题进行决策树分裂（对于silence，我们一般不分裂）。如果该行指定“split”（正常情况），那么我们进行决策树分裂。如果指定“not-split”，那么就不会进行分裂，因此根节点就被无分裂地保留。</li>\n</ul>\n<p>下面将对这个怎样使用方面做一些阐述：</p>\n<ul>\n<li>如果我们指定“shared\nsplit”，即使所有的三个HMM状态有一个根节点，不同的HMM状态仍然可以到达不同的叶子节点，因为树可以像对声学上下文的问题提问一样对pdf-class的问题提问。</li>\n<li>对于roots文件中同一行出现的所有音素，我们总是让它们共享根节点。如果你不想共享音素的根节点，你只要把它们放在不同的行。</li>\n</ul>\n<p>下面是roots文件的一个例子；假设音素1是silence，并且其他的音素都有不同的根节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">not-shared not-split  1</span><br><span class=\"line\">shared split  2</span><br><span class=\"line\">...</span><br><span class=\"line\">shared split  28</span><br></pre></td></tr></table></figure>\n<p>当我们有比如位置和声调相关的音素时，将多个音素放在同一行会非常有用；这样每个“真实的“音素将关联到一个整数的音素ID集合。在这种情况下我们将particular\nunderlying（注：这个不知道怎么翻译）音素的所有变种版本共享一个根节点。下面是来自egs/wsj/s5脚本中Wall\nStreet\nJournal的roots文件的一个例子（这个例子中音素是用文本表示的，而不是整数形式；但在被Kaldi读取之前会被转换成整数形式（注：就是会把音素映射成整数的ID））：\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">not-shared not-split SIL SIL_B SIL_E SIL_I SIL_S SPN SPN_B SPN_E SPN_I SPN_S NSN NSN_B NSN_E NSN_I NSN_S</span><br><span class=\"line\">shared split AA_B AA_E AA_I AA_S AA0_B AA0_E AA0_I AA0_S AA1_B AA1_E AA1_I AA1_S AA2_B AA2_E AA2_I AA2_S</span><br><span class=\"line\">shared split AE_B AE_E AE_I AE_S AE0_B AE0_E AE0_I AE0_S AE1_B AE1_E AE1_I AE1_S AE2_B AE2_E AE2_I AE2_S</span><br><span class=\"line\">shared split AH_B AH_E AH_I AH_S AH0_B AH0_E AH0_I AH0_S AH1_B AH1_E AH1_I AH1_S AH2_B AH2_E AH2_I AH2_S</span><br><span class=\"line\">shared split AO_B AO_E AO_I AO_S AO0_B AO0_E AO0_I AO0_S AO1_B AO1_E AO1_I AO1_S AO2_B AO2_E AO2_I AO2_S</span><br><span class=\"line\">shared split AW_B AW_E AW_I AW_S AW0_B AW0_E AW0_I AW0_S AW1_B AW1_E AW1_I AW1_S AW2_B AW2_E AW2_I AW2_S</span><br><span class=\"line\">shared split AY_B AY_E AY_I AY_S AY0_B AY0_E AY0_I AY0_S AY1_B AY1_E AY1_I AY1_S AY2_B AY2_E AY2_I AY2_S</span><br><span class=\"line\">shared split B_B B_E B_I B_S</span><br><span class=\"line\">shared split CH_B CH_E CH_I CH_S</span><br><span class=\"line\">shared split D_B D_E D_I D_S</span><br></pre></td></tr></table></figure></p>\n<p>当创建这个roots文件时，你应该确保在每一行至少有一个音素是可见的（注：有对应的训练样本）。比如上面的情况，如果音素AY至少在声调和词位置的某些连接中可见，那就没问题。</p>\n<p>在这个例子中，对于slience等音素我们有很多的词位置相关的变种。它们将共享它们的pdf's，因为它们都在同一行，并且是“not-split”，但是它们可能会有不同的状态转移参数。实际上，silence的大多数变种都不可能用到，因为silence不可能出现在词与词之间；这只是为了防止以后有人做一些奇怪的事而不会过时。</p>\n<p>我们用从之前创建的模型（比如，单音素模型）得到的对齐结果来对混合高斯参数进行初始化；对齐的结果会被程序convert-ali从一棵树转换到另一棵（注：应该就是说对齐的transition不变，但状态绑定的参数可能因为决策树的不同而变化）。</p>\n<h2 id=\"pdf标号pdf-identifiers\">PDF标号（PDF identifiers）</h2>\n<p>PDF标号（pdf-id）是一个从0开始的数字，用做概率密度函数（p.d.f.）的序号。系统中每一个p.d.f.都有自己的pdf-id，并且是连续的（在一个LVCSR系统中一般会有几千个）。在树首先被构建时，它们就会被赋值。对于每一个pdf-id对应的是哪个音素，可能知道也可能不知道，这取决于树是怎样被构建的。</p>\n<h2\nid=\"上下文相关对象context-dependency-objects\">上下文相关对象（Context\ndependency objects）</h2>\n<p>ContextDependencyInterface对象是树的一个虚基类，指定了如何与构建解码图代码进行交互。这个接口只包含四个函数：</p>\n<ul>\n<li>ContextWidth()返回树需要的N（上下文窗的大小）的值。</li>\n<li>CentralPosition()返回树需要的P（窗中心位置）的值</li>\n<li>NumPdfs()返回树定义的pdfs的数量；pdfs的编号从0到NumPdfs()-1。</li>\n<li>Compute()是对某个特殊的上下文计算它对应的pdf-id的函数</li>\n</ul>\n<p>ContextDependencyInterface::Compute()函数的声明如下： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ContextDependencyInterface</span> &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">Compute</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;int32&gt; &amp;phoneseq, int32 pdf_class,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    int32 *pdf_id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n如果能计算得到上下文和pdf-class对应的pdf-id，函数返回true。返回false时表明出现了一些错误或者是不匹配。这个函数使用的一个例子：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContextDependencyInterface *ctx_dep = ... ;</span><br><span class=\"line\">vector&lt;int32&gt; ctx_window = &#123; <span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">21</span> &#125;; <span class=\"comment\">// not valid C++</span></span><br><span class=\"line\">int32 pdf_class = <span class=\"number\">1</span>; <span class=\"comment\">// probably central state of 3-state HMM.</span></span><br><span class=\"line\">int32 pdf_id;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!ctx_dep-&gt;<span class=\"built_in\">Compute</span>(ctx_window, pdf_class, &amp;pdf_id))</span><br><span class=\"line\">      KALDI_ERR &lt;&lt; <span class=\"string\">&quot;Something went wrong!&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">      KALDI_LOG &lt;&lt; <span class=\"string\">&quot;Got pdf-id, it is &quot;</span> &lt;&lt; pdf_id;</span><br></pre></td></tr></table></figure>\n目前唯一继承ContextDependencyInterface的类就是ContextDependency，ContextDependency有少量更丰富的接口；唯一主要的添加就是函数GetPdfInfo，被用于TransitionModel类算出一个特殊的pdf可能对应哪些音素（这个函数的功能可以被\nContextDependencyInterface接口遍历所有的上下文而实现）。</p>\n<p>ContextDependency对象实际上是对EventMap对象的简单组合封装；请参见Decision\ntree\ninternals。我们希望尽可能地隐藏树的真正实现，使得以后需要重构代码时变得非常简单。</p>\n<h2\nid=\"决策树的一个例子an-example-of-a-decision-tree\">决策树的一个例子（An\nexample of a decision tree）</h2>\n<p>决策树文件的格式不是以人们的可读性为首要目标而创建的，但由于大家需要我们在这里试着解释如何去解读这个文件。请看下面的例子，这个是一个来自Wall\nStreet\nJournal脚本中triphone的决策树。它以这个对象的名字ContextDependency开始（注：在代码中整个树是一个ContextDependency对象）；然后是N（上下文窗的大小），这里是3；接着是P（上下文窗的中心位置），这里是1。文件剩下的部分包含单个EventMap对象。EventMap是一个可能包含指向其他EventMap指针的多态类型。更多详细信息，请参见Event\nmaps。这个文件表示一棵决策树或多棵决策树的集合，并将一个键值对集合（比如，left-phone=5,\ncentral-phone=10, right-phone=11,\npdf-class=2（注：注意这里是四个键值对，表示一个中心音素是10，上文是音素5，下文是音素11的triphone的第2个状态））映射到一个pdf-id（比如，158）。简单来说，一个决策树包含三种基本类型：一个是SplitEventMap（就像决策树中的分支判断），一个是ConstantEventMap（就像决策树的叶子节点，只包含一个表示pdf-id的数字），和一个是TableEventMap（就像是一个包含其他EventMaps的一个查找表）。SplitEventMap和TableEventMap都有一个需要它们判断的key，这个值可能是0，1或者2，分别表示左上下文音素，中心音素和右上下文音素，也可能是-1，表示pdf-class的标号（注：如果HMM的每个状态都有对应的pdf，则pdf-class可理解为HMM的第几个状态）。一般情况，pdf-class的值与HMM状态的序号是相同的，比如0，1或2。请尝试不要因此而感到困惑：key是-1，value是0，1或2，但它们与上下文窗中音素的keys\n0，1或2是没有任何关系的（注：上下文窗中0，1和2表示的是窗中音素的位置）。SplitEventMap有一系列值可以触发决策树的yes分支。下面是一种quasi-BNF符号表示的决策树文件格式。\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        EventMap := ConstantEventMap | SplitEventMap | TableEventMap | &quot;NULL&quot;</span><br><span class=\"line\">ConstantEventMap := &quot;CE&quot; &lt;numeric pdf-id&gt;</span><br><span class=\"line\">   SplitEventMap := &quot;SE&quot; &lt;key-to-split-on&gt; &quot;[&quot; yes-value-list &quot;]&quot; &quot;&#123;&quot; EventMap EventMap &quot;&#125;&quot;</span><br><span class=\"line\">   TableEventMap := &quot;TE&quot; &lt;key-to-split-on&gt; &lt;table-size&gt; &quot;(&quot; EventMapList &quot;)&quot;</span><br></pre></td></tr></table></figure> 在下面的例子中，树顶层的EventMap是一个以key\n1进行分裂的SplitEventMap，也就是按中心音素分裂。在方括号中是一系列连续范围的phone-ids。然而，这些并不表示一个问题，它们只是音素分裂的一种方法，因此我们可以得到每个音素真正的决策树（注：音素真正的决策树是根据音素上下文和pdf-class进行决策的，对中心音素的决策只是为了找到这个音素对应的真正的决策树）。问题在于这棵树是通过“shared\nroots”方式创建的，所以有很多与同一音素不同词位置和音调标识相关的phone-ids，它们都共享树的根节点。在这种情况下在树的顶层我们不能使用TableEventMap，否则我们就不得不将每棵树重复好几遍（因为EventMap是一棵纯树，而不是一个通用的图，它没有指针共享的机制）。文件后面的一些“SE”标签也是quasi-tree的一部分，它们都是首先按中心音素进行分裂（当我们顺着文件往下看时我们进入了树的更深处；注意这个花括号“{”一直是打开的，还没有关闭）。然后我们看到字符串“TE\n-1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 ) ”，表示通过TableEventMap对pdf-class\n-1进行分裂（实际上就是，HMM-position），并且返回从0到4的值。这5个值表示的是静音和噪声音素SIL，NSN和SPN的5个pdf-ids。在我们的设定中，这三个非语音音素的pdfs是共享的（只有转移矩阵是不同的）。注意：对于这些音素我们用5状态而不是3状态的HMM，所以这里有5个不同的pdf-ids。接下来是“SE\n-1 [ 0 ]\n”，这可以被认为是这棵树中第一个真正的问题。我们可以从上面的SE问题看出这个问题被应用于中心音素为4到19时候，也就是音素AA的不同版本（注：原文写的是5到19，不过我认为原文有问题，改成了4到19）。这个问题问的是pdf-class（key\n-1）是不是0（即是不是最左边的HMM-state）。下一个问题是“SE 2 [ 220 221\n222 223\n]”，问的是音素右上下文是不是音素“M”不同形式中的一个（这是一个非常有效的问题，因为我们是在最左边的HMM-state）；如果问题的答案是yes，我们继续问“SE\n0 [ 104 105 106 107... 286 287\n]”，这是一个关于音素左上下文的问题（注：原文写的是右上下文，但应该是左上下文）；如果答案是yes，则pdf-id就是5（“CE\n5”），否则就是696（“CE 696”）。 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s3# copy-tree --binary=false exp/tri1/tree - 2&gt;/dev/null | head -100</span><br><span class=\"line\">ContextDependency 3 1 ToPdf SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \\</span><br><span class=\"line\">26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59\\</span><br><span class=\"line\"> 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 9\\</span><br><span class=\"line\">3 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 1\\</span><br><span class=\"line\">20 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 14\\</span><br><span class=\"line\">5 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170\\</span><br><span class=\"line\"> 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 \\</span><br><span class=\"line\">196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 ]</span><br><span class=\"line\">&#123; SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\\</span><br><span class=\"line\"> 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 6\\</span><br><span class=\"line\">8 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 10\\</span><br><span class=\"line\">1 102 103 104 105 106 107 108 109 110 111 ]</span><br><span class=\"line\">&#123; SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\\</span><br><span class=\"line\"> 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ]</span><br><span class=\"line\">&#123; SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ]</span><br><span class=\"line\">&#123; SE 1 [ 1 2 3 ]</span><br><span class=\"line\">&#123; TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 )</span><br><span class=\"line\">SE -1 [ 0 ]</span><br><span class=\"line\">&#123; SE 2 [ 220 221 222 223 ]</span><br><span class=\"line\">&#123; SE 0 [ 104 105 106 107 112 113 114 115 172 173 174 175 208 209 210 211 212 213 214 215 264 265 266 \\</span><br><span class=\"line\">267 280 281 282 283 284 285 286 287 ]</span><br><span class=\"line\">&#123; CE 5 CE 696 &#125;</span><br><span class=\"line\">SE 2 [ 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 132 \\</span><br><span class=\"line\">133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 248 249 250 251 252 253 254 255 256 257 2\\</span><br><span class=\"line\">58 259 260 261 262 263 268 269 270 271 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 30\\</span><br><span class=\"line\">3 ]</span><br></pre></td></tr></table></figure>\n下面是一个更简单的例子：来自Resource\nManagement脚本的单音素决策树。顶层的EventMap是一个TableEventMap（“TE 0\n49 ...”）。key\n0是音素位置0，表示中心（并且只有这一个）音素，因为上下文窗大小（N）为1。TE的条目数量是49（音素的数量加1）。表中第一个EventMap是NULL，因为没有序号为0的音素。下一个EventMap是一个有三个元素的TableEventMap，关联到第一个音素的三个HMM状态（技术上来说，是pdf-class）：“TE\n-1 3 ( CE 0 CE 1 CE 2 )”。 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s3# copy-tree --binary=false exp/mono/tree - 2&gt;/dev/null| head -5</span><br><span class=\"line\">ContextDependency 1 0 ToPdf TE 0 49 ( NULL TE -1 3 ( CE 0 CE 1 CE 2 )</span><br><span class=\"line\">TE -1 3 ( CE 3 CE 4 CE 5 )</span><br><span class=\"line\">TE -1 3 ( CE 6 CE 7 CE 8 )</span><br><span class=\"line\">TE -1 3 ( CE 9 CE 10 CE 11 )</span><br><span class=\"line\">TE -1 3 ( CE 12 CE 13 CE 14 )</span><br></pre></td></tr></table></figure> ## 输入符号信息对象（The\nilabel_info object） CLG图（请参见Decoding graph construction in\nKaldi）在它的输入符号位置上有表示上下文相关音素的符号（辅助符号和可能的空符号也一样）。在图中它们总是用整型的标签来表示。在代码和文件名中，我们使用一个叫做ilable_info的对象。ilable_info对象跟ContextFst对象有很密切的联系，请参见see\nThe ContextFst\nobject。就跟许多其他的Kaldi类型一样，ilabel_info也是一个通用的（STL）类型，但是为了可以辨别出是ilabel_info，我们使用与之相同的变量名。就是下面定义的类型：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;std::vector&lt;int32&gt; &gt; ilabel_info;</span><br></pre></td></tr></table></figure>\n它是一个以FST输入标签为索引的vector，给每一个输入标签一个对应的音素上下文窗（参见上文，Phonetic\ncontext\nwindows）。比如，假设符号1500是左上下文是12和右上下文是4的音素30，我们有：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// not valid C++</span></span><br><span class=\"line\">ilabel_info[<span class=\"number\">1500</span>] == &#123; <span class=\"number\">4</span>, <span class=\"number\">30</span>, <span class=\"number\">12</span> &#125;;</span><br></pre></td></tr></table></figure> 在单音素的情况下，我们就会像这样： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ilabel_info[<span class=\"number\">30</span>] == &#123; <span class=\"number\">28</span> &#125;</span><br></pre></td></tr></table></figure>\n处理辅助符号会有点特殊（参见Disambiguation symbols或者上面引用的Springer\nHandbook文献，该文献解释了这些辅助符号是什么）。如果一条ilabel_info记录对应到一个辅助符号，我们就把辅助符号的符号表序号取负值放进去（注意这跟辅助符号打印形式#0，#1，#2等等里面的数字是不一样的，它是跟这些辅助符号在符号表文件中的顺序相关的数字，这个符号表文件在我们现在的脚本中叫做phones_disambig.txt）。比如，\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ilabel_info[<span class=\"number\">5</span>] == &#123; <span class=\"number\">-42</span> &#125;</span><br></pre></td></tr></table></figure>\n意味着在HCLG中符号数5对应到整数id是42的辅助符号。为了编程方便我们对这些id取负号，因此解析ilable_info对象的程序不需要给一个辅助符号的列表就可以在单音素情况下将它们跟真实的音素进行区分。有两个额外特殊情况：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ilabel_info[<span class=\"number\">0</span>] == &#123; &#125;; <span class=\"comment\">// epsilon</span></span><br><span class=\"line\">ilabel_info[<span class=\"number\">1</span>] == &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">// disambig symbol #-1;</span></span><br><span class=\"line\"><span class=\"comment\">// we use symbol 1, but don&#x27;t consider this hardwired.</span></span><br></pre></td></tr></table></figure>\n第一个是正常的空符号，我们给它一个空的vector作为它的ilabel_info。这个符号一般不会出现在CLG的左边（注：应该是说不会作为CLG的输入符号）。第二个是一个特殊的辅助符号，打印形式叫做“#-1”。在epsilons被用做标准（Springer\nHandbook）脚本中C转换器输入符号的时候，我们使用辅助符号“#-1”。它可以确保有空音素表示的词的CLG网络可以被确定化。</p>\n<p>程序fstmakecontextsyms可以创建一个与ilabel_info对象打印形式对应的符号表；这个主要用于调试和诊断错误。</p>"},{"title":"TVM PackedFunc实现机制","date":"2020-01-10T04:24:08.000Z","_content":"\n## TVM PackedFunc实现\n\n为了便于Python和C\\+\\+混合编程，TVM使用了统一的PackedFunc机制。PackedFunc可以将C\\+\\+中的各类函数打包成统一的函数接口，并自动导出到Python模块中进行调用，并且也支持从Python中注册一个函数，并伪装成PackedFunc在C\\+\\+和Python中调用。\n\n<!-- more -->\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/tvm/屏幕快照%202020-01-10%2010.55.45.png?raw=true\" style=\"zoom:36%;\" />\n\n### 预备知识\n\n#### Python ctypes混合编程\n\nctypes是Python自带的跨语言函数调用库，ctypes提供了简单的C数据类型，可以将C/C\\+\\+动态库中的函数包装成Python函数进行调用。\n\n- 导出C\\+\\+函数\n\n  首先在C\\+\\+中定义一个全局函数，并编译生成C\\+\\+动态库。\n\n  ```c++\n  // test.h\n  extern \"C\" {\n  int add(int a, int b);\n  }\n  ```\n\n  ```c++\n  // test.cc\n  #include \"test.h\"\n  int add(int a, int b) {\n    return a + b;\n  }\n  ```\n\n  用ctypes模块在Python中加载生成的动态库（test.so），并调用C\\+\\+中的函数。\n\n  ```python\n  import ctypes\n\n  # Load shared library\n  _LIB = ctypes.CDLL(\"./test.so\", ctypes.RTLD_GLOBAL)\n\n  a = ctypes.c_int(1)\n  b = ctypes.c_int(2)\n  # Call C func in Python\n  print(_LIB.add(a, b))\n  # Or\n  print(_LIB.add(1, 2))\n  ```\n\n\n\n- 传递Python函数到C\\+\\+\n\n  ctypes也支持将Python函数转换成C类型的函数，并在C/C\\+\\+中进行调用。\n\n  ```python\n  def add(a, b):\n    return a + b\n  ```\n\n  Python add有两个参数a和b，返回值类型与a和b的类型一致。在C\\+\\+中可以为Python add定义一个函数原型 int(int, int)。\n\n  ```c++\n  extern \"C\" {\n  typedef int (*PyCFunc)(int, int);\n  int call_py_func(PyCFunc f, int a, int b);\n  }\n  ```\n\n  ```c++\n  #include \"test.h\"\n  int call_py_func(PyCFunc f, int a, int b) {\n    return f(a, b);\n  }\n  ```\n\n  使用ctypes将Python函数转换成C function，传入C\\+\\+中进行调用。\n\n  ```python\n  import ctypes\n\n  cfunc = ctypes.CFUNCTYPE(\n      ctypes.c_int, # return type\n      ctypes.c_int, # arg0 type\n      ctypes.c_int  # arg1 type\n      )\n\n  f = cfunc(add)\n  # CFUNCTYPE is callable in Python\n  print(f(5, 1))\n\n  # Call Python func in C\n  print(_LIB.call_py_func(f, 5, 1))\n  ```\n\n\n\n### PackedFunc实现\n\n#### PackedFunc定义\n\nctypes可以很方便的将C/C\\+\\+中的函数导出到Python，调用时直接传入对应的参数即可，但如果需要将Python函数导入到C/C\\+\\+，则需要在C/C\\+\\+中提前定义好对应的函数原型（比如上面的PyCFunc），并提供对应函数的调用入口（call_py_func）。为了支持更加灵活的函数定义，TVM将不同类型的函数包装成统一的函数原型。\n\n```c++\nvoid(TVMArgs args, TVMRetValue *rv);\n```\n\n统一的函数原型被封装成PackedFunc对象，提供通用的调用接口，直接与调用者进行交互。\n\n```c++\nclass PackedFunc {\n public:\n  using FType = std::function<void (TVMArgs args, TVMRetValue* rv)>;\n  template<typename... Args>\n  inline TVMRetValue operator()(Args&& ...args) const;\n  inline void CallPacked(TVMArgs args, TVMRetValue* rv) const;\n\n  private:\n  /*! \\brief internal container of packed function */\n  FType body_;\n};\n```\n\n当获得一个PackedFunc对象时，我们就可以像调用普通函数一样调用PackedFunc打包的函数。比如：\n\n```c++\nPackedFunc f;\n// f(1, 2)首先会自动将参数1，2打包成TVMArgs，接着调用CallPacked，CallPacked最终的执行体是body_\nTVMRetValue ret = f(1, 2);\n```\n\n#### 函数打包\n\nTVM支持对各类函数进行打包，包括一般的函数、类的成员函数以及lamda表达式。\n\n- 函数原型萃取\n\n  萃取函数原型是为了得到函数的参数和返回值类型。TVM中使用decltype和模版结构体function_signature来实现。\n\n  比如定义一个简单的C函数，\n\n  ```c++\n  int add(int a, int b) {\n    return a + b;\n  }\n  ```\n\n  接下来就可以使用如下的代码来萃取add的函数原型，\n\n  ```c++\n  template <typename R, typename ...Args>\n  struct function_signature<R(Args...)> {\n    using FType = R(Args...);\n  };\n\n  // 萃取add的函数原型\n  using FType = function_signature<decltype(add)>::FType;\n  ```\n\n  此外只需要特化function_signature就可以支持函数指针和lambda表达式。注意：TVM function_signature不支持普通成员函数的类型萃取，因此TVM需要借助一个辅助function_signature_helper来对lambda表达式类型进行萃取，而我们这里的function_signature支持普通成员函数，因此lambda表达式类型萃取可以通过递归的function_signature来实现。\n\n  ```c++\n  // 普通函数指针\n  template <typename R, typename ...Args>\n  struct function_signature<R(*)(Args...)> {\n    using FType = R(Args...);\n  };\n\n  // 非const类的成员函数指针\n  template <typename T, typename R, typename ...Args>\n   struct function_signature<R(T::*)(Args...)> {\n     using FType = R(Args...);\n  };\n\n  // const类的成员函数指针\n  template <typename T, typename R, typename ...Args>\n   struct function_signature<R(T::*)(Args...) const> {\n     using FType = R(Args...);\n  };\n\n  // lambda表达式\n  template<typename T>\n  struct function_signature {\n    using FType = typename function_signature<decltype(&T::operator())>::FType;\n  };\n  ```\n\n- 函数打包\n\n  一旦萃取到了函数原型，TVM就利用TypedPackedFunc对普通函数或lambda表达式进行打包。TypedPackedFunc只支持对R(Args...)类型的函数打包，所以如果被打包的函数是一个函数指针，则需要创建一个lambda表达式，转换成R(Args...)类型之后再用TypedPackedFunc对创建的lambda表达式进行打包。\n\n  ```c++\n  template<typename R, typename ...Args>\n  class TypedPackedFunc<R(Args...)> {\n   public:\n    using TSelf = TypedPackedFunc<R(Args...)>;\n    template<typename FLambda,\n             typename = typename std::enable_if<\n               std::is_convertible<FLambda,\n                                   std::function<R(Args...)>\n                                   >::value>::type>\n    TypedPackedFunc(const FLambda& typed_lambda) {  // NOLINT(*)\n      this->AssignTypedLambda(typed_lambda);\n    }\n    ...\n   private:\n    ...\n    PackedFunc packed_;\n  };\n  ```\n\n  当被打包的函数用来实例化TypedPackedFunc对象时，会立刻调用AssignTypedLambda将被打包的函数打包成PackedFunc。\n\n  ```c++\n  template<typename R, typename ...Args>\n  template<typename FType>\n  inline void TypedPackedFunc<R(Args...)>::AssignTypedLambda(FType flambda) {\n    packed_ = PackedFunc([flambda](const TVMArgs& args, TVMRetValue* rv) {\n        detail::unpack_call<R, sizeof...(Args)>(flambda, args, rv);\n      });\n  }\n  ```\n\n  AssignTypedLambda实际上是将被打包的函数先封装成了一个函数原型为void(const TVMArgs &args, TVMRetValue *rv)的lambda表达式，然后将这个lambda表达式作为PackedFunc对象的一个成员，通过设置合适的接口（重载operator ()），使得PackedFunc与被打包的源函数表现的完全一样了。\n\n### 自动导出函数\n\nTVM将需要从C++自动导出的函数打包成PackedFunc，然后通过宏TVM_REGISTER_GLOBAL注册到全局的一个map中。比如：\n```c++\nTVM_REGISTER_GLOBAL(\"_Var\")\n.set_body_typed([](std::string s, DataType t) {\n    return VarNode::make(t, s);\n  });\n```\n\n当Python加载编译好的动态库时，会自动查询map中静态注册的函数，每个函数都包装成Python中的Function对象，最终添加到Python模块中。Function重定义了函数调用接口，自动完成参数打包过程。\n如果是在Python中动态注册的函数，则需要在Python中通过函数名和来查询PackedFunc，返回一个PackedFunc的handle（函数指针），并封装成Function。\n\n```python\ndef get_global_func(name, allow_missing=False):\n    handle = FunctionHandle()\n    check_call(_LIB.TVMFuncGetGlobal(c_str(name), ctypes.byref(handle)))\n    if handle.value:\n        return Function(handle, False)\n\n    if allow_missing:\n        return None\n\n    raise ValueError(\"Cannot find global function %s\" % name)\n```\n注：TVMFuncGetGlobal是通过ctypes导出的C++接口，FunctionHandle是ctypes中表示void指针类型（c_void_p）。\n\n### 从Python注册函数\n\n由于TVM中PackedFunc的精心设计，我们只需要将Python中的函数转换成统一的函数原型void(const TVMArgs, TVMRetValue)，然后将函数转换成PackedFunc并动态地注册到全局的map中。\n\n先将Python函数用ctypes转成int(TVMValue *, int *, int, void *, void *)的C函数。\n\n```python\nTVMPackedCFunc = ctypes.CFUNCTYPE(\n    ctypes.c_int,\n    ctypes.POINTER(TVMValue),\n    ctypes.POINTER(ctypes.c_int),\n    ctypes.c_int,\n    ctypes.c_void_p,\n    ctypes.c_void_p)\n```\n\n然后通过TVMFuncCreateFromCFunc将上面的C函数转换成统一的PackedFunc函数。\n\n```c++\nint TVMFuncCreateFromCFunc(TVMPackedCFunc func,\n                           void* resource_handle,\n                           TVMPackedCFuncFinalizer fin,\n                           TVMFunctionHandle *out) {\n  API_BEGIN();\n  if (fin == nullptr) {\n    *out = new PackedFunc(\n        [func, resource_handle](TVMArgs args, TVMRetValue* rv) {\n          int ret = func((TVMValue*)args.values, (int*)args.type_codes, // NOLINT(*)\n                         args.num_args, rv, resource_handle);\n          if (ret != 0) {\n            throw dmlc::Error(TVMGetLastError() + ::dmlc::StackTrace());\n          }\n        });\n  } else {\n    ...\n  }\n  API_END();\n}\n```\n\n最后通过接口TVMFuncRegisterGlobal注册到全局的map中。下面是从Python中注册一个函数，并在Python中调用的例子。\n\n```python\ntargs = (10, 10.0, \"hello\")\n\n@tvm.register_func\ndef my_packed_func(*args):\n    assert(tuple(args) == targs)\n    return 10\n\n# Get it out from global function table\nf = tvm.get_global_func(\"my_packed_func\")\nassert isinstance(f, tvm.nd.Function)\ny = f(*targs)\nassert y == 10\n```\n","source":"_posts/TVM-PackedFunc实现机制.md","raw":"---\n\ntitle: TVM PackedFunc实现机制\n\ndate: 2020-1-10 12:24:08\n\ncategory: tvm knowledge\n\ntags: [TVM, PackedFunc]\n\n---\n\n## TVM PackedFunc实现\n\n为了便于Python和C\\+\\+混合编程，TVM使用了统一的PackedFunc机制。PackedFunc可以将C\\+\\+中的各类函数打包成统一的函数接口，并自动导出到Python模块中进行调用，并且也支持从Python中注册一个函数，并伪装成PackedFunc在C\\+\\+和Python中调用。\n\n<!-- more -->\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/tvm/屏幕快照%202020-01-10%2010.55.45.png?raw=true\" style=\"zoom:36%;\" />\n\n### 预备知识\n\n#### Python ctypes混合编程\n\nctypes是Python自带的跨语言函数调用库，ctypes提供了简单的C数据类型，可以将C/C\\+\\+动态库中的函数包装成Python函数进行调用。\n\n- 导出C\\+\\+函数\n\n  首先在C\\+\\+中定义一个全局函数，并编译生成C\\+\\+动态库。\n\n  ```c++\n  // test.h\n  extern \"C\" {\n  int add(int a, int b);\n  }\n  ```\n\n  ```c++\n  // test.cc\n  #include \"test.h\"\n  int add(int a, int b) {\n    return a + b;\n  }\n  ```\n\n  用ctypes模块在Python中加载生成的动态库（test.so），并调用C\\+\\+中的函数。\n\n  ```python\n  import ctypes\n\n  # Load shared library\n  _LIB = ctypes.CDLL(\"./test.so\", ctypes.RTLD_GLOBAL)\n\n  a = ctypes.c_int(1)\n  b = ctypes.c_int(2)\n  # Call C func in Python\n  print(_LIB.add(a, b))\n  # Or\n  print(_LIB.add(1, 2))\n  ```\n\n\n\n- 传递Python函数到C\\+\\+\n\n  ctypes也支持将Python函数转换成C类型的函数，并在C/C\\+\\+中进行调用。\n\n  ```python\n  def add(a, b):\n    return a + b\n  ```\n\n  Python add有两个参数a和b，返回值类型与a和b的类型一致。在C\\+\\+中可以为Python add定义一个函数原型 int(int, int)。\n\n  ```c++\n  extern \"C\" {\n  typedef int (*PyCFunc)(int, int);\n  int call_py_func(PyCFunc f, int a, int b);\n  }\n  ```\n\n  ```c++\n  #include \"test.h\"\n  int call_py_func(PyCFunc f, int a, int b) {\n    return f(a, b);\n  }\n  ```\n\n  使用ctypes将Python函数转换成C function，传入C\\+\\+中进行调用。\n\n  ```python\n  import ctypes\n\n  cfunc = ctypes.CFUNCTYPE(\n      ctypes.c_int, # return type\n      ctypes.c_int, # arg0 type\n      ctypes.c_int  # arg1 type\n      )\n\n  f = cfunc(add)\n  # CFUNCTYPE is callable in Python\n  print(f(5, 1))\n\n  # Call Python func in C\n  print(_LIB.call_py_func(f, 5, 1))\n  ```\n\n\n\n### PackedFunc实现\n\n#### PackedFunc定义\n\nctypes可以很方便的将C/C\\+\\+中的函数导出到Python，调用时直接传入对应的参数即可，但如果需要将Python函数导入到C/C\\+\\+，则需要在C/C\\+\\+中提前定义好对应的函数原型（比如上面的PyCFunc），并提供对应函数的调用入口（call_py_func）。为了支持更加灵活的函数定义，TVM将不同类型的函数包装成统一的函数原型。\n\n```c++\nvoid(TVMArgs args, TVMRetValue *rv);\n```\n\n统一的函数原型被封装成PackedFunc对象，提供通用的调用接口，直接与调用者进行交互。\n\n```c++\nclass PackedFunc {\n public:\n  using FType = std::function<void (TVMArgs args, TVMRetValue* rv)>;\n  template<typename... Args>\n  inline TVMRetValue operator()(Args&& ...args) const;\n  inline void CallPacked(TVMArgs args, TVMRetValue* rv) const;\n\n  private:\n  /*! \\brief internal container of packed function */\n  FType body_;\n};\n```\n\n当获得一个PackedFunc对象时，我们就可以像调用普通函数一样调用PackedFunc打包的函数。比如：\n\n```c++\nPackedFunc f;\n// f(1, 2)首先会自动将参数1，2打包成TVMArgs，接着调用CallPacked，CallPacked最终的执行体是body_\nTVMRetValue ret = f(1, 2);\n```\n\n#### 函数打包\n\nTVM支持对各类函数进行打包，包括一般的函数、类的成员函数以及lamda表达式。\n\n- 函数原型萃取\n\n  萃取函数原型是为了得到函数的参数和返回值类型。TVM中使用decltype和模版结构体function_signature来实现。\n\n  比如定义一个简单的C函数，\n\n  ```c++\n  int add(int a, int b) {\n    return a + b;\n  }\n  ```\n\n  接下来就可以使用如下的代码来萃取add的函数原型，\n\n  ```c++\n  template <typename R, typename ...Args>\n  struct function_signature<R(Args...)> {\n    using FType = R(Args...);\n  };\n\n  // 萃取add的函数原型\n  using FType = function_signature<decltype(add)>::FType;\n  ```\n\n  此外只需要特化function_signature就可以支持函数指针和lambda表达式。注意：TVM function_signature不支持普通成员函数的类型萃取，因此TVM需要借助一个辅助function_signature_helper来对lambda表达式类型进行萃取，而我们这里的function_signature支持普通成员函数，因此lambda表达式类型萃取可以通过递归的function_signature来实现。\n\n  ```c++\n  // 普通函数指针\n  template <typename R, typename ...Args>\n  struct function_signature<R(*)(Args...)> {\n    using FType = R(Args...);\n  };\n\n  // 非const类的成员函数指针\n  template <typename T, typename R, typename ...Args>\n   struct function_signature<R(T::*)(Args...)> {\n     using FType = R(Args...);\n  };\n\n  // const类的成员函数指针\n  template <typename T, typename R, typename ...Args>\n   struct function_signature<R(T::*)(Args...) const> {\n     using FType = R(Args...);\n  };\n\n  // lambda表达式\n  template<typename T>\n  struct function_signature {\n    using FType = typename function_signature<decltype(&T::operator())>::FType;\n  };\n  ```\n\n- 函数打包\n\n  一旦萃取到了函数原型，TVM就利用TypedPackedFunc对普通函数或lambda表达式进行打包。TypedPackedFunc只支持对R(Args...)类型的函数打包，所以如果被打包的函数是一个函数指针，则需要创建一个lambda表达式，转换成R(Args...)类型之后再用TypedPackedFunc对创建的lambda表达式进行打包。\n\n  ```c++\n  template<typename R, typename ...Args>\n  class TypedPackedFunc<R(Args...)> {\n   public:\n    using TSelf = TypedPackedFunc<R(Args...)>;\n    template<typename FLambda,\n             typename = typename std::enable_if<\n               std::is_convertible<FLambda,\n                                   std::function<R(Args...)>\n                                   >::value>::type>\n    TypedPackedFunc(const FLambda& typed_lambda) {  // NOLINT(*)\n      this->AssignTypedLambda(typed_lambda);\n    }\n    ...\n   private:\n    ...\n    PackedFunc packed_;\n  };\n  ```\n\n  当被打包的函数用来实例化TypedPackedFunc对象时，会立刻调用AssignTypedLambda将被打包的函数打包成PackedFunc。\n\n  ```c++\n  template<typename R, typename ...Args>\n  template<typename FType>\n  inline void TypedPackedFunc<R(Args...)>::AssignTypedLambda(FType flambda) {\n    packed_ = PackedFunc([flambda](const TVMArgs& args, TVMRetValue* rv) {\n        detail::unpack_call<R, sizeof...(Args)>(flambda, args, rv);\n      });\n  }\n  ```\n\n  AssignTypedLambda实际上是将被打包的函数先封装成了一个函数原型为void(const TVMArgs &args, TVMRetValue *rv)的lambda表达式，然后将这个lambda表达式作为PackedFunc对象的一个成员，通过设置合适的接口（重载operator ()），使得PackedFunc与被打包的源函数表现的完全一样了。\n\n### 自动导出函数\n\nTVM将需要从C++自动导出的函数打包成PackedFunc，然后通过宏TVM_REGISTER_GLOBAL注册到全局的一个map中。比如：\n```c++\nTVM_REGISTER_GLOBAL(\"_Var\")\n.set_body_typed([](std::string s, DataType t) {\n    return VarNode::make(t, s);\n  });\n```\n\n当Python加载编译好的动态库时，会自动查询map中静态注册的函数，每个函数都包装成Python中的Function对象，最终添加到Python模块中。Function重定义了函数调用接口，自动完成参数打包过程。\n如果是在Python中动态注册的函数，则需要在Python中通过函数名和来查询PackedFunc，返回一个PackedFunc的handle（函数指针），并封装成Function。\n\n```python\ndef get_global_func(name, allow_missing=False):\n    handle = FunctionHandle()\n    check_call(_LIB.TVMFuncGetGlobal(c_str(name), ctypes.byref(handle)))\n    if handle.value:\n        return Function(handle, False)\n\n    if allow_missing:\n        return None\n\n    raise ValueError(\"Cannot find global function %s\" % name)\n```\n注：TVMFuncGetGlobal是通过ctypes导出的C++接口，FunctionHandle是ctypes中表示void指针类型（c_void_p）。\n\n### 从Python注册函数\n\n由于TVM中PackedFunc的精心设计，我们只需要将Python中的函数转换成统一的函数原型void(const TVMArgs, TVMRetValue)，然后将函数转换成PackedFunc并动态地注册到全局的map中。\n\n先将Python函数用ctypes转成int(TVMValue *, int *, int, void *, void *)的C函数。\n\n```python\nTVMPackedCFunc = ctypes.CFUNCTYPE(\n    ctypes.c_int,\n    ctypes.POINTER(TVMValue),\n    ctypes.POINTER(ctypes.c_int),\n    ctypes.c_int,\n    ctypes.c_void_p,\n    ctypes.c_void_p)\n```\n\n然后通过TVMFuncCreateFromCFunc将上面的C函数转换成统一的PackedFunc函数。\n\n```c++\nint TVMFuncCreateFromCFunc(TVMPackedCFunc func,\n                           void* resource_handle,\n                           TVMPackedCFuncFinalizer fin,\n                           TVMFunctionHandle *out) {\n  API_BEGIN();\n  if (fin == nullptr) {\n    *out = new PackedFunc(\n        [func, resource_handle](TVMArgs args, TVMRetValue* rv) {\n          int ret = func((TVMValue*)args.values, (int*)args.type_codes, // NOLINT(*)\n                         args.num_args, rv, resource_handle);\n          if (ret != 0) {\n            throw dmlc::Error(TVMGetLastError() + ::dmlc::StackTrace());\n          }\n        });\n  } else {\n    ...\n  }\n  API_END();\n}\n```\n\n最后通过接口TVMFuncRegisterGlobal注册到全局的map中。下面是从Python中注册一个函数，并在Python中调用的例子。\n\n```python\ntargs = (10, 10.0, \"hello\")\n\n@tvm.register_func\ndef my_packed_func(*args):\n    assert(tuple(args) == targs)\n    return 10\n\n# Get it out from global function table\nf = tvm.get_global_func(\"my_packed_func\")\nassert isinstance(f, tvm.nd.Function)\ny = f(*targs)\nassert y == 10\n```\n","slug":"TVM-PackedFunc实现机制","published":1,"updated":"2023-01-03T14:05:07.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgb13um0004j6eq25msh21k","content":"<h2 id=\"tvm-packedfunc实现\">TVM PackedFunc实现</h2>\n<p>为了便于Python和C++混合编程，TVM使用了统一的PackedFunc机制。PackedFunc可以将C++中的各类函数打包成统一的函数接口，并自动导出到Python模块中进行调用，并且也支持从Python中注册一个函数，并伪装成PackedFunc在C++和Python中调用。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/tvm/屏幕快照%202020-01-10%2010.55.45.png?raw=true\" style=\"zoom:36%;\" /></p>\n<h3 id=\"预备知识\">预备知识</h3>\n<h4 id=\"python-ctypes混合编程\">Python ctypes混合编程</h4>\n<p>ctypes是Python自带的跨语言函数调用库，ctypes提供了简单的C数据类型，可以将C/C++动态库中的函数包装成Python函数进行调用。</p>\n<ul>\n<li><p>导出C++函数</p>\n<p>首先在C++中定义一个全局函数，并编译生成C++动态库。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.cc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;test.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用ctypes模块在Python中加载生成的动态库（test.so），并调用C++中的函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ctypes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Load shared library</span></span><br><span class=\"line\">_LIB = ctypes.CDLL(<span class=\"string\">&quot;./test.so&quot;</span>, ctypes.RTLD_GLOBAL)</span><br><span class=\"line\"></span><br><span class=\"line\">a = ctypes.c_int(<span class=\"number\">1</span>)</span><br><span class=\"line\">b = ctypes.c_int(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># Call C func in Python</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_LIB.add(a, b))</span><br><span class=\"line\"><span class=\"comment\"># Or</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_LIB.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure></li>\n<li><p>传递Python函数到C++</p>\n<p>ctypes也支持将Python函数转换成C类型的函数，并在C/C++中进行调用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b</span><br></pre></td></tr></table></figure>\n<p>Python\nadd有两个参数a和b，返回值类型与a和b的类型一致。在C++中可以为Python\nadd定义一个函数原型 int(int, int)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*PyCFunc)</span><span class=\"params\">(<span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">call_py_func</span><span class=\"params\">(PyCFunc f, <span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;test.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">call_py_func</span><span class=\"params\">(PyCFunc f, <span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">f</span>(a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用ctypes将Python函数转换成C function，传入C++中进行调用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ctypes</span><br><span class=\"line\"></span><br><span class=\"line\">cfunc = ctypes.CFUNCTYPE(</span><br><span class=\"line\">    ctypes.c_int, <span class=\"comment\"># return type</span></span><br><span class=\"line\">    ctypes.c_int, <span class=\"comment\"># arg0 type</span></span><br><span class=\"line\">    ctypes.c_int  <span class=\"comment\"># arg1 type</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">f = cfunc(add)</span><br><span class=\"line\"><span class=\"comment\"># CFUNCTYPE is callable in Python</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(f(<span class=\"number\">5</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Call Python func in C</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_LIB.call_py_func(f, <span class=\"number\">5</span>, <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"packedfunc实现\">PackedFunc实现</h3>\n<h4 id=\"packedfunc定义\">PackedFunc定义</h4>\n<p>ctypes可以很方便的将C/C++中的函数导出到Python，调用时直接传入对应的参数即可，但如果需要将Python函数导入到C/C++，则需要在C/C++中提前定义好对应的函数原型（比如上面的PyCFunc），并提供对应函数的调用入口（call_py_func）。为了支持更加灵活的函数定义，TVM将不同类型的函数包装成统一的函数原型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">void</span>(TVMArgs args, TVMRetValue *rv);</span><br></pre></td></tr></table></figure>\n<p>统一的函数原型被封装成PackedFunc对象，提供通用的调用接口，直接与调用者进行交互。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PackedFunc</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">using</span> FType = std::function&lt;<span class=\"built_in\">void</span> (TVMArgs args, TVMRetValue* rv)&gt;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span>... Args&gt;</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">inline</span> TVMRetValue <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(Args&amp;&amp; ...args)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">CallPacked</span><span class=\"params\">(TVMArgs args, TVMRetValue* rv)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"comment\">/*! \\brief internal container of packed function */</span></span><br><span class=\"line\">  FType body_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当获得一个PackedFunc对象时，我们就可以像调用普通函数一样调用PackedFunc打包的函数。比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PackedFunc f;</span><br><span class=\"line\"><span class=\"comment\">// f(1, 2)首先会自动将参数1，2打包成TVMArgs，接着调用CallPacked，CallPacked最终的执行体是body_</span></span><br><span class=\"line\">TVMRetValue ret = <span class=\"built_in\">f</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数打包\">函数打包</h4>\n<p>TVM支持对各类函数进行打包，包括一般的函数、类的成员函数以及lamda表达式。</p>\n<ul>\n<li><p>函数原型萃取</p>\n<p>萃取函数原型是为了得到函数的参数和返回值类型。TVM中使用decltype和模版结构体function_signature来实现。</p>\n<p>比如定义一个简单的C函数，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就可以使用如下的代码来萃取add的函数原型，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span>&lt;<span class=\"built_in\">R</span>(Args...)&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> FType = <span class=\"built_in\">R</span>(Args...);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 萃取add的函数原型</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> FType = function_signature&lt;<span class=\"keyword\">decltype</span>(add)&gt;::FType;</span><br></pre></td></tr></table></figure>\n<p>此外只需要特化function_signature就可以支持函数指针和lambda表达式。注意：TVM\nfunction_signature不支持普通成员函数的类型萃取，因此TVM需要借助一个辅助function_signature_helper来对lambda表达式类型进行萃取，而我们这里的function_signature支持普通成员函数，因此lambda表达式类型萃取可以通过递归的function_signature来实现。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通函数指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span>&lt;<span class=\"built_in\">R</span>(*)(Args...)&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> FType = <span class=\"built_in\">R</span>(Args...);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非const类的成员函数指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span>&lt;<span class=\"built_in\">R</span>(T::*)(Args...)&gt; &#123;</span><br><span class=\"line\">   <span class=\"keyword\">using</span> FType = <span class=\"built_in\">R</span>(Args...);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const类的成员函数指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span>&lt;<span class=\"built_in\">R</span>(T::*)(Args...) <span class=\"type\">const</span>&gt; &#123;</span><br><span class=\"line\">   <span class=\"keyword\">using</span> FType = <span class=\"built_in\">R</span>(Args...);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lambda表达式</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> FType = <span class=\"keyword\">typename</span> function_signature&lt;<span class=\"keyword\">decltype</span>(&amp;T::<span class=\"built_in\">operator</span>())&gt;::FType;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p>函数打包</p>\n<p>一旦萃取到了函数原型，TVM就利用TypedPackedFunc对普通函数或lambda表达式进行打包。TypedPackedFunc只支持对R(Args...)类型的函数打包，所以如果被打包的函数是一个函数指针，则需要创建一个lambda表达式，转换成R(Args...)类型之后再用TypedPackedFunc对创建的lambda表达式进行打包。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TypedPackedFunc</span>&lt;<span class=\"built_in\">R</span>(Args...)&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">using</span> TSelf = TypedPackedFunc&lt;<span class=\"built_in\">R</span>(Args...)&gt;;</span><br><span class=\"line\">  <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> FLambda,</span><br><span class=\"line\">           <span class=\"keyword\">typename</span> = <span class=\"keyword\">typename</span> std::enable_if&lt;</span><br><span class=\"line\">             std::is_convertible&lt;FLambda,</span><br><span class=\"line\">                                 std::function&lt;<span class=\"built_in\">R</span>(Args...)&gt;</span><br><span class=\"line\">                                 &gt;::value&gt;::type&gt;</span><br><span class=\"line\">  <span class=\"built_in\">TypedPackedFunc</span>(<span class=\"type\">const</span> FLambda&amp; typed_lambda) &#123;  <span class=\"comment\">// NOLINT(*)</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">AssignTypedLambda</span>(typed_lambda);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  PackedFunc packed_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当被打包的函数用来实例化TypedPackedFunc对象时，会立刻调用AssignTypedLambda将被打包的函数打包成PackedFunc。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> FType&gt;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> TypedPackedFunc&lt;<span class=\"built_in\">R</span>(Args...)&gt;::<span class=\"built_in\">AssignTypedLambda</span>(FType flambda) &#123;</span><br><span class=\"line\">  packed_ = <span class=\"built_in\">PackedFunc</span>([flambda](<span class=\"type\">const</span> TVMArgs&amp; args, TVMRetValue* rv) &#123;</span><br><span class=\"line\">      detail::<span class=\"built_in\">unpack_call</span>&lt;R, <span class=\"keyword\">sizeof</span>...(Args)&gt;(flambda, args, rv);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AssignTypedLambda实际上是将被打包的函数先封装成了一个函数原型为void(const\nTVMArgs &amp;args, TVMRetValue\n*rv)的lambda表达式，然后将这个lambda表达式作为PackedFunc对象的一个成员，通过设置合适的接口（重载operator\n()），使得PackedFunc与被打包的源函数表现的完全一样了。</p></li>\n</ul>\n<h3 id=\"自动导出函数\">自动导出函数</h3>\n<p>TVM将需要从C++自动导出的函数打包成PackedFunc，然后通过宏TVM_REGISTER_GLOBAL注册到全局的一个map中。比如：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TVM_REGISTER_GLOBAL</span>(<span class=\"string\">&quot;_Var&quot;</span>)</span><br><span class=\"line\">.<span class=\"built_in\">set_body_typed</span>([](std::string s, DataType t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> VarNode::<span class=\"built_in\">make</span>(t, s);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>当Python加载编译好的动态库时，会自动查询map中静态注册的函数，每个函数都包装成Python中的Function对象，最终添加到Python模块中。Function重定义了函数调用接口，自动完成参数打包过程。\n如果是在Python中动态注册的函数，则需要在Python中通过函数名和来查询PackedFunc，返回一个PackedFunc的handle（函数指针），并封装成Function。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_global_func</span>(<span class=\"params\">name, allow_missing=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">    handle = FunctionHandle()</span><br><span class=\"line\">    check_call(_LIB.TVMFuncGetGlobal(c_str(name), ctypes.byref(handle)))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handle.value:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Function(handle, <span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> allow_missing:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;Cannot find global function %s&quot;</span> % name)</span><br></pre></td></tr></table></figure>\n<p>注：TVMFuncGetGlobal是通过ctypes导出的C++接口，FunctionHandle是ctypes中表示void指针类型（c_void_p）。</p>\n<h3 id=\"从python注册函数\">从Python注册函数</h3>\n<p>由于TVM中PackedFunc的精心设计，我们只需要将Python中的函数转换成统一的函数原型void(const\nTVMArgs,\nTVMRetValue)，然后将函数转换成PackedFunc并动态地注册到全局的map中。</p>\n<p>先将Python函数用ctypes转成int(TVMValue <em>, int </em>, int, void\n<em>, void </em>)的C函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TVMPackedCFunc = ctypes.CFUNCTYPE(</span><br><span class=\"line\">    ctypes.c_int,</span><br><span class=\"line\">    ctypes.POINTER(TVMValue),</span><br><span class=\"line\">    ctypes.POINTER(ctypes.c_int),</span><br><span class=\"line\">    ctypes.c_int,</span><br><span class=\"line\">    ctypes.c_void_p,</span><br><span class=\"line\">    ctypes.c_void_p)</span><br></pre></td></tr></table></figure>\n<p>然后通过TVMFuncCreateFromCFunc将上面的C函数转换成统一的PackedFunc函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">TVMFuncCreateFromCFunc</span><span class=\"params\">(TVMPackedCFunc func,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           <span class=\"type\">void</span>* resource_handle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           TVMPackedCFuncFinalizer fin,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           TVMFunctionHandle *out)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">API_BEGIN</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fin == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">    *out = <span class=\"keyword\">new</span> <span class=\"built_in\">PackedFunc</span>(</span><br><span class=\"line\">        [func, resource_handle](TVMArgs args, TVMRetValue* rv) &#123;</span><br><span class=\"line\">          <span class=\"type\">int</span> ret = <span class=\"built_in\">func</span>((TVMValue*)args.values, (<span class=\"type\">int</span>*)args.type_codes, <span class=\"comment\">// NOLINT(*)</span></span><br><span class=\"line\">                         args.num_args, rv, resource_handle);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> dmlc::<span class=\"built_in\">Error</span>(<span class=\"built_in\">TVMGetLastError</span>() + ::dmlc::<span class=\"built_in\">StackTrace</span>());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">API_END</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后通过接口TVMFuncRegisterGlobal注册到全局的map中。下面是从Python中注册一个函数，并在Python中调用的例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targs = (<span class=\"number\">10</span>, <span class=\"number\">10.0</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@tvm.register_func</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_packed_func</span>(<span class=\"params\">*args</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(<span class=\"built_in\">tuple</span>(args) == targs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get it out from global function table</span></span><br><span class=\"line\">f = tvm.get_global_func(<span class=\"string\">&quot;my_packed_func&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(f, tvm.nd.Function)</span><br><span class=\"line\">y = f(*targs)</span><br><span class=\"line\"><span class=\"keyword\">assert</span> y == <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"tvm-packedfunc实现\">TVM PackedFunc实现</h2>\n<p>为了便于Python和C++混合编程，TVM使用了统一的PackedFunc机制。PackedFunc可以将C++中的各类函数打包成统一的函数接口，并自动导出到Python模块中进行调用，并且也支持从Python中注册一个函数，并伪装成PackedFunc在C++和Python中调用。</p>","more":"<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/tvm/屏幕快照%202020-01-10%2010.55.45.png?raw=true\" style=\"zoom:36%;\" /></p>\n<h3 id=\"预备知识\">预备知识</h3>\n<h4 id=\"python-ctypes混合编程\">Python ctypes混合编程</h4>\n<p>ctypes是Python自带的跨语言函数调用库，ctypes提供了简单的C数据类型，可以将C/C++动态库中的函数包装成Python函数进行调用。</p>\n<ul>\n<li><p>导出C++函数</p>\n<p>首先在C++中定义一个全局函数，并编译生成C++动态库。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.cc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;test.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用ctypes模块在Python中加载生成的动态库（test.so），并调用C++中的函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ctypes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Load shared library</span></span><br><span class=\"line\">_LIB = ctypes.CDLL(<span class=\"string\">&quot;./test.so&quot;</span>, ctypes.RTLD_GLOBAL)</span><br><span class=\"line\"></span><br><span class=\"line\">a = ctypes.c_int(<span class=\"number\">1</span>)</span><br><span class=\"line\">b = ctypes.c_int(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># Call C func in Python</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_LIB.add(a, b))</span><br><span class=\"line\"><span class=\"comment\"># Or</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_LIB.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure></li>\n<li><p>传递Python函数到C++</p>\n<p>ctypes也支持将Python函数转换成C类型的函数，并在C/C++中进行调用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b</span><br></pre></td></tr></table></figure>\n<p>Python\nadd有两个参数a和b，返回值类型与a和b的类型一致。在C++中可以为Python\nadd定义一个函数原型 int(int, int)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*PyCFunc)</span><span class=\"params\">(<span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">call_py_func</span><span class=\"params\">(PyCFunc f, <span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;test.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">call_py_func</span><span class=\"params\">(PyCFunc f, <span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">f</span>(a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用ctypes将Python函数转换成C function，传入C++中进行调用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ctypes</span><br><span class=\"line\"></span><br><span class=\"line\">cfunc = ctypes.CFUNCTYPE(</span><br><span class=\"line\">    ctypes.c_int, <span class=\"comment\"># return type</span></span><br><span class=\"line\">    ctypes.c_int, <span class=\"comment\"># arg0 type</span></span><br><span class=\"line\">    ctypes.c_int  <span class=\"comment\"># arg1 type</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">f = cfunc(add)</span><br><span class=\"line\"><span class=\"comment\"># CFUNCTYPE is callable in Python</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(f(<span class=\"number\">5</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Call Python func in C</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_LIB.call_py_func(f, <span class=\"number\">5</span>, <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"packedfunc实现\">PackedFunc实现</h3>\n<h4 id=\"packedfunc定义\">PackedFunc定义</h4>\n<p>ctypes可以很方便的将C/C++中的函数导出到Python，调用时直接传入对应的参数即可，但如果需要将Python函数导入到C/C++，则需要在C/C++中提前定义好对应的函数原型（比如上面的PyCFunc），并提供对应函数的调用入口（call_py_func）。为了支持更加灵活的函数定义，TVM将不同类型的函数包装成统一的函数原型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">void</span>(TVMArgs args, TVMRetValue *rv);</span><br></pre></td></tr></table></figure>\n<p>统一的函数原型被封装成PackedFunc对象，提供通用的调用接口，直接与调用者进行交互。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PackedFunc</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">using</span> FType = std::function&lt;<span class=\"built_in\">void</span> (TVMArgs args, TVMRetValue* rv)&gt;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span>... Args&gt;</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">inline</span> TVMRetValue <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(Args&amp;&amp; ...args)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">CallPacked</span><span class=\"params\">(TVMArgs args, TVMRetValue* rv)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"comment\">/*! \\brief internal container of packed function */</span></span><br><span class=\"line\">  FType body_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当获得一个PackedFunc对象时，我们就可以像调用普通函数一样调用PackedFunc打包的函数。比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PackedFunc f;</span><br><span class=\"line\"><span class=\"comment\">// f(1, 2)首先会自动将参数1，2打包成TVMArgs，接着调用CallPacked，CallPacked最终的执行体是body_</span></span><br><span class=\"line\">TVMRetValue ret = <span class=\"built_in\">f</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数打包\">函数打包</h4>\n<p>TVM支持对各类函数进行打包，包括一般的函数、类的成员函数以及lamda表达式。</p>\n<ul>\n<li><p>函数原型萃取</p>\n<p>萃取函数原型是为了得到函数的参数和返回值类型。TVM中使用decltype和模版结构体function_signature来实现。</p>\n<p>比如定义一个简单的C函数，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就可以使用如下的代码来萃取add的函数原型，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span>&lt;<span class=\"built_in\">R</span>(Args...)&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> FType = <span class=\"built_in\">R</span>(Args...);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 萃取add的函数原型</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> FType = function_signature&lt;<span class=\"keyword\">decltype</span>(add)&gt;::FType;</span><br></pre></td></tr></table></figure>\n<p>此外只需要特化function_signature就可以支持函数指针和lambda表达式。注意：TVM\nfunction_signature不支持普通成员函数的类型萃取，因此TVM需要借助一个辅助function_signature_helper来对lambda表达式类型进行萃取，而我们这里的function_signature支持普通成员函数，因此lambda表达式类型萃取可以通过递归的function_signature来实现。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通函数指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span>&lt;<span class=\"built_in\">R</span>(*)(Args...)&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> FType = <span class=\"built_in\">R</span>(Args...);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非const类的成员函数指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span>&lt;<span class=\"built_in\">R</span>(T::*)(Args...)&gt; &#123;</span><br><span class=\"line\">   <span class=\"keyword\">using</span> FType = <span class=\"built_in\">R</span>(Args...);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const类的成员函数指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"> <span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span>&lt;<span class=\"built_in\">R</span>(T::*)(Args...) <span class=\"type\">const</span>&gt; &#123;</span><br><span class=\"line\">   <span class=\"keyword\">using</span> FType = <span class=\"built_in\">R</span>(Args...);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lambda表达式</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">function_signature</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> FType = <span class=\"keyword\">typename</span> function_signature&lt;<span class=\"keyword\">decltype</span>(&amp;T::<span class=\"built_in\">operator</span>())&gt;::FType;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p>函数打包</p>\n<p>一旦萃取到了函数原型，TVM就利用TypedPackedFunc对普通函数或lambda表达式进行打包。TypedPackedFunc只支持对R(Args...)类型的函数打包，所以如果被打包的函数是一个函数指针，则需要创建一个lambda表达式，转换成R(Args...)类型之后再用TypedPackedFunc对创建的lambda表达式进行打包。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TypedPackedFunc</span>&lt;<span class=\"built_in\">R</span>(Args...)&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">using</span> TSelf = TypedPackedFunc&lt;<span class=\"built_in\">R</span>(Args...)&gt;;</span><br><span class=\"line\">  <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> FLambda,</span><br><span class=\"line\">           <span class=\"keyword\">typename</span> = <span class=\"keyword\">typename</span> std::enable_if&lt;</span><br><span class=\"line\">             std::is_convertible&lt;FLambda,</span><br><span class=\"line\">                                 std::function&lt;<span class=\"built_in\">R</span>(Args...)&gt;</span><br><span class=\"line\">                                 &gt;::value&gt;::type&gt;</span><br><span class=\"line\">  <span class=\"built_in\">TypedPackedFunc</span>(<span class=\"type\">const</span> FLambda&amp; typed_lambda) &#123;  <span class=\"comment\">// NOLINT(*)</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">AssignTypedLambda</span>(typed_lambda);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  PackedFunc packed_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当被打包的函数用来实例化TypedPackedFunc对象时，会立刻调用AssignTypedLambda将被打包的函数打包成PackedFunc。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> R, <span class=\"keyword\">typename</span> ...Args&gt;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> FType&gt;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> TypedPackedFunc&lt;<span class=\"built_in\">R</span>(Args...)&gt;::<span class=\"built_in\">AssignTypedLambda</span>(FType flambda) &#123;</span><br><span class=\"line\">  packed_ = <span class=\"built_in\">PackedFunc</span>([flambda](<span class=\"type\">const</span> TVMArgs&amp; args, TVMRetValue* rv) &#123;</span><br><span class=\"line\">      detail::<span class=\"built_in\">unpack_call</span>&lt;R, <span class=\"keyword\">sizeof</span>...(Args)&gt;(flambda, args, rv);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AssignTypedLambda实际上是将被打包的函数先封装成了一个函数原型为void(const\nTVMArgs &amp;args, TVMRetValue\n*rv)的lambda表达式，然后将这个lambda表达式作为PackedFunc对象的一个成员，通过设置合适的接口（重载operator\n()），使得PackedFunc与被打包的源函数表现的完全一样了。</p></li>\n</ul>\n<h3 id=\"自动导出函数\">自动导出函数</h3>\n<p>TVM将需要从C++自动导出的函数打包成PackedFunc，然后通过宏TVM_REGISTER_GLOBAL注册到全局的一个map中。比如：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TVM_REGISTER_GLOBAL</span>(<span class=\"string\">&quot;_Var&quot;</span>)</span><br><span class=\"line\">.<span class=\"built_in\">set_body_typed</span>([](std::string s, DataType t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> VarNode::<span class=\"built_in\">make</span>(t, s);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>当Python加载编译好的动态库时，会自动查询map中静态注册的函数，每个函数都包装成Python中的Function对象，最终添加到Python模块中。Function重定义了函数调用接口，自动完成参数打包过程。\n如果是在Python中动态注册的函数，则需要在Python中通过函数名和来查询PackedFunc，返回一个PackedFunc的handle（函数指针），并封装成Function。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_global_func</span>(<span class=\"params\">name, allow_missing=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">    handle = FunctionHandle()</span><br><span class=\"line\">    check_call(_LIB.TVMFuncGetGlobal(c_str(name), ctypes.byref(handle)))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handle.value:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Function(handle, <span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> allow_missing:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;Cannot find global function %s&quot;</span> % name)</span><br></pre></td></tr></table></figure>\n<p>注：TVMFuncGetGlobal是通过ctypes导出的C++接口，FunctionHandle是ctypes中表示void指针类型（c_void_p）。</p>\n<h3 id=\"从python注册函数\">从Python注册函数</h3>\n<p>由于TVM中PackedFunc的精心设计，我们只需要将Python中的函数转换成统一的函数原型void(const\nTVMArgs,\nTVMRetValue)，然后将函数转换成PackedFunc并动态地注册到全局的map中。</p>\n<p>先将Python函数用ctypes转成int(TVMValue <em>, int </em>, int, void\n<em>, void </em>)的C函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TVMPackedCFunc = ctypes.CFUNCTYPE(</span><br><span class=\"line\">    ctypes.c_int,</span><br><span class=\"line\">    ctypes.POINTER(TVMValue),</span><br><span class=\"line\">    ctypes.POINTER(ctypes.c_int),</span><br><span class=\"line\">    ctypes.c_int,</span><br><span class=\"line\">    ctypes.c_void_p,</span><br><span class=\"line\">    ctypes.c_void_p)</span><br></pre></td></tr></table></figure>\n<p>然后通过TVMFuncCreateFromCFunc将上面的C函数转换成统一的PackedFunc函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">TVMFuncCreateFromCFunc</span><span class=\"params\">(TVMPackedCFunc func,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           <span class=\"type\">void</span>* resource_handle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           TVMPackedCFuncFinalizer fin,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           TVMFunctionHandle *out)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">API_BEGIN</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fin == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">    *out = <span class=\"keyword\">new</span> <span class=\"built_in\">PackedFunc</span>(</span><br><span class=\"line\">        [func, resource_handle](TVMArgs args, TVMRetValue* rv) &#123;</span><br><span class=\"line\">          <span class=\"type\">int</span> ret = <span class=\"built_in\">func</span>((TVMValue*)args.values, (<span class=\"type\">int</span>*)args.type_codes, <span class=\"comment\">// NOLINT(*)</span></span><br><span class=\"line\">                         args.num_args, rv, resource_handle);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> dmlc::<span class=\"built_in\">Error</span>(<span class=\"built_in\">TVMGetLastError</span>() + ::dmlc::<span class=\"built_in\">StackTrace</span>());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">API_END</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后通过接口TVMFuncRegisterGlobal注册到全局的map中。下面是从Python中注册一个函数，并在Python中调用的例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targs = (<span class=\"number\">10</span>, <span class=\"number\">10.0</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@tvm.register_func</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_packed_func</span>(<span class=\"params\">*args</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(<span class=\"built_in\">tuple</span>(args) == targs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get it out from global function table</span></span><br><span class=\"line\">f = tvm.get_global_func(<span class=\"string\">&quot;my_packed_func&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(f, tvm.nd.Function)</span><br><span class=\"line\">y = f(*targs)</span><br><span class=\"line\"><span class=\"keyword\">assert</span> y == <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>"},{"title":"图替换","date":"2019-12-26T05:54:04.000Z","_content":"\n### 背景\n\n图替换（或者叫图改写）是一种重要的图优化技术，几乎在所有的开源框架（尤其是移动端框架）中都有应用。比如tensorflow r1.14版本中就包含了155个替换子，而且实现这些替换子的总代码量接近53k行。\n\n>一些常见的图优化技术：\n>\n>- DCE\n>\n>- CSE（公共子表达式消除）\n>- 常量折叠\n>- 数学公式简化\n>- Op融合\n>- Layout变换\n>- 内存优化（swap-in/swap-out、重计算）\n\n<!-- more -->\n\n由于目前的编译器技术通常基于low-level的中间表达，注重对局部计算的优化，对于跨多个粗粒度op的优化要不无能为力，要不就得增加编译器的分析难度并导致代码膨胀。一般来说AI框架支持的粗粒度op非常有限，而且这些op的组合常常也比较固定，比如convolution通常和bias_add、relu组合使用，因此基于高层中间表达的图替换成为一种比较可行的优化方案。经过图替换优化后的计算图再经过编译器的优化后，生成最终的硬件代码。\n\n目前主流开源框架的图替换都是基于经验和手工设置的替换子来实现的，在这里统称为经典图替换技术。\n\n### 经典图替换\n\n图替换是将原始计算图替换成另一个优化后的等价计算图，替换后的计算图通常是硬件友好的，比如可以消除中间结果，降低内存占用，减少访存和计算量，并且不影响最终的计算结果。\n\n在进行图替换之前，首先需要定义出源计算图到目标计算图的替换规则（替换子），由于这些替换规则往往需要依靠人的经验一条条手工去定义，因此称之为经典图替换。给出一条替换子，我们需要在原始计算图中不断地去匹配替换子的源计算子图，一旦匹配到满足要求的子图后，就将源计算子图重新映射为替换子中的目标计算图。\n\n在一些开源框架中，替换子的定义形式不尽相同。在TensorFlow中源图匹配和替换的定义是非常松散的，它甚至没有直接定义出替换子的源图，而是定义一系列约束来判断是否匹配。PaddlePaddle中则是将一个替换过程定义为一个pass，pass执行时动态构建相应的替换子源图，执行匹配算法并回调源图到目标图的替换函数。比如下面是TensorFlow中将Conv+BiasAdd替换成FusedConv的过程。\n\n- 定义匹配约束\n\n  ```c++\n  struct ContractionWithBiasAdd {\n    int constraction;\n    int bias_add;\n  }\n  // node为输入的grapper node， pattern为输出的ContractionWithBiasAdd.\n  bool FindContractionWithBias(node，*pattern) {\n    // 开始列举匹配的constractions.\n    1、如果node存在控制边，返回false\n    2、如果node不是BiasAdd，返回false\n    3、如果node的父节点不是Conv或MatMul，返回false\n    4、...\n    // 如果以上所有constructions都满足，则将需要替换的node id写到特定的pattern中。\n    pattern->constraction = node的父节点;\n    pattern->bias_add = node；\n    return true;\n  }\n  ```\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.03.21.png?raw=true\" style=\"zoom:33%;\" />\n\n- 定义替换过程\n\n  ```c++\n  // pattern为输入的ContractionWithBiasAdd，\n  void AddFusedContractionNode(pattern, *invalidated_nodes) {\n    1、创建一个新的node：fused_op\n    2、将Conv或MatMul的input和filter添加到fused_op的输入中，并将BiasAdd的bias加到fused_op的输入\n    3、根据Conv或MatMul的一些参数设置fused_op的参数，比如conv的kernel、channel、padding等等，以及matmul的transpose等\n    4、将fused_op加入到graph，同时将Conv或MatMul和BiasAdd加入到invalidated_nodes\n  }\n  ```\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.03.35.png?raw=true\" style=\"zoom:33%;\" />\n\nTensorFlow采用的定义匹配约束的方式与直接定义出子图的方式本质上是等价的，但相比后者可读性较差，而优点就是代码可复用性高，比如上面的FindContractionWithBias可以同时匹配Conv+BiasAdd和MatMul+BiasAdd两种子图，并且这些约束便于嵌套使用。\n\n无论是TensorFlow还是PaddlePaddle，图替换都是不完全的。比如说对于Conv+BiasAdd+BiasAdd这种计算图，第一次只能匹配到Conv+BiasAdd，替换后又变成了一个Conv+BiasAdd的计算图，因此TensorFlow中默认采用了两遍优化。根据TensorFlow公开的一些数据，基本上第二次优化的机会已经非常少了。\n\n- InceptionV3\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.29.51.png?raw=true\" style=\"zoom:40%;\" />\n\n- Seq2Seq\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.30.01.png?raw=true\" style=\"zoom:40%;\" />\n\n### 基于超优化的图替换\n\n超优化（Superoptimization）是现代编译器中的一种指令优化技术，其主要工作原理是通过随机生成指令序列以及暴力搜索的方式自动找到一组优化的指令序列，并等价替换原有的指令序列。1992年第一个Superoptimizer被集成到了GCC编译器，之后Google也为LLVM开发了一个Superoptimizer，取名为Souper。\n\n依靠人工设定的编译器往往对代码的优化不够彻底，给生成的code留下了大量的优化空隙，而且人工设定的优化规则往往没有经过充分验证，经常导致各种极端条件下的代码bug。Superoptimization将指令序列优化问题转换为自动搜索问题，并加入了自动化验证和一阶逻辑验证，在发现代码优化空隙的同时优化结果也更加可靠。\n\n[TASO](https://github.com/jiazhihao/TASO)（Tensor Algebra SuperOptimizer）将Superoptimization用于DNN高层中间表达的图优化，在大多数模型上取得了比XLA和TensorRT更优的效果。TASO的工作是MetaFlow（作者另一个基于人工规则的图替换框架）的延续，因此也采用了与MetaFlow一致的替换子定义。MetaFlow替换子的定义包括：源图、目标图、输入和输出的映射关系。\n\n<img src=\"https://github.com/jiazhihao/TASO/blob/master/figures/inference.png?raw=true\">\n\nTASO相比其他开源框架最大的区别就是不需要手工去设定各种各样的替换子，只需要像设计硬件指令一样设计出基本的算子定义（或者计算逻辑），之后系统会根据指定的算子集自动生成满足条件的替换子，经过验证的替换子最终作用于图替换过程。基于高度抽象的替换子定义，TASO可以独立于具体的训练或预测框架，离线完成替换子的生成和验证，并在图优化阶段加载到程序中进行图替换。尽管手工设计有很多弊端，但TASO在代码实现过程中并没有完全抛弃手工设计的方式，而是采用了手工设计和替换子自动生成相结合的方式。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2013.56.06.png?raw=true\" style=\"zoom:40%;\" />\n\n#### 替换子定义\n\n替换子包含三个部分，源图、目标图、输入和输出tensor的映射关系。并且替换子通常是与shape无关的，源图和目标图都是由算子构成的，每个算子都可以指定一些配置，比如kernel指定卷积核的大小、axis指定reduce的维度等等。\n\n但需要注意的是concat和split两个算子，在图替换中这两个算子通常用于算子融合，比如下图对两个不同的输入B和C进行相同的MatMul操作，就可以替换为先将输入B和C进行一次合并，然后调用一次MatMul后，对结果进行切分得到两个输出X和Y。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2016.24.40.png?raw=true\" style=\"zoom:50%;\" />\n\n为了能正确切分出X和Y，在Concat时我们需要给每个维度维护一个分割树（split tree）。一个行分割的例子如下，图中需要将A和B按照第0维进行concat，因此输入A在第0维有一个原始的分割树[0, $S_{A}$]，表示对于tensor A，第0维从0到$S_{A}$行都是A的数据区域。A和B concat后tensor的row变成了$S_{A}+S_{B}$，并且通过分割树可以知道第0到$S_{A}$行是A的数据，从$S_{A}$到$S_{A}+S_{B}$行是B的数据。根据分割树，Split非常容易地就可以将数据进行切分。TASO的分割树支持任意维度的切分和递归切分。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2016.37.22.png?raw=true\" style=\"zoom:70%;\" />\n\n#### 替换子生成\n\n替换子生成包含两个阶段：构建搜索空间，以及对潜在的替换子进行测试。\n\n- 构建搜索空间\n\n  搜索空间由任意合法的计算图构成，而计算图由给定的算子集中的算子组成。TASO向我们表明了一种暴力枚举、深度优先递归构建的方法。\n\n  给定算子集和初始化的input tensor集合，对于每一个输入tensor，每次从算子集中选择一个合法的算子构建graph，并计算当前graph的输出tensor，将输出tensor加入到input tensor集合， 保存graph以及graph的fingerprint（对输出tensor计算hash值），接着重复上面的过程继续加入算子，直到递归的深度达到设定的上限。\n\n  对于同样的输入tensor，如果构建的两个计算图的输出tensor相同，则这两个计算图构成了一个潜在的替换子。为了避免出现浮点计算异常的情况，构建计算图时所有的tensor都是int类型。\n\n- 测试潜在替换子\n\n  为了进一步验证潜在替换子的合法性，TASO设计了一系列cases来测试潜在替换子。每个测试case都使用随机初始化的输入tensor，当两个计算图结果一致时才认为测试通过，只有所有测试cases都通过的潜在替换子才是合法的替换子。\n\n  与构建计算图时使用int类型的tensor不一样，所有测试case的输入tensor都是-1到1之间的浮点数。由于relu对于所有小于0的值都返回0，因此可能导致非法的替换子通过测试cases，作者认为可以使用任意一个非线性函数来代替relu，TASO中使用$x(x+1)+1$。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2016.30.05.png?raw=true\" style=\"zoom:50%;\" />\n\n#### 替换子验证\n\nTASO同时使用一阶逻辑表达的算子属性对替换子进行进一步验证，这些属性通常是由人工定义，并且经过充分review和大量测试验证过的。\n\n在定义算子属性之前，首先需要对算子进行符号建模，算子模型通常包含参数和输入tensors。比如$conv(s, p, c, x, y)$表示conv算子的符号模型，$s$，$p$，$c$是conv的参数，分别表示stride、padding和activation，$x$和$y$是卷积操作的两个输入。如果activation是none，很显然conv就是一个线性操作，因此满足以下属性：\n$$\n\\begin{aligned}\n∀s,p,x,y,z. conv(s,p,Anone,ewadd(x,y),z) = \\\\\newadd(conv(s,p,Anone,x,z),conv(s,p,Anone,y,z))\n\\end{aligned}\n$$\nTASO定义了大量的算子属性，并且使用z3（一阶逻辑验证器）对所有合法的替换子进行验证。如果有合法的替换子无法被一阶逻辑验证，则需要根据替换子手动添加一条算子属性，以确保所有合法的替换子都能验证通过。\n\n#### 冗余替换子裁剪\n\n自动生成的替换子往往存在大量的冗余，TASO使用了两种策略消除冗余。\n\n- Input tensor renaming\n\n  对输入进行重命名的方式消除不同替换子之间的冗余。比如下面两个替换子，\n\n  替换子a:\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.14.31.png?raw=true\" style=\"zoom:40%;\" />\n\n  替换子b：\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.15.49.png?raw=true\" style=\"zoom:40%;\" />\n\n  将替换子a的一个输入tensor A改名为C，就得到了替换子b，说明这两个替换子存在冗余，因此最终只会保留更加通用的替换子b。\n\n- Common subgraph\n\n  如果替换子的源图和目标图包含同样的子图，则可以用一个相同的tensor替换掉公共子图。比如下面的一个替换子，\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.14.59.png?raw=true\" style=\"zoom:40%;\" />\n\n  source graph和target graph包含同一个子图（B x C），将source graph替换成target graph时，公共子图没有任何变化，因此可以将子图消除。\n\n实验结果显示，裁剪可以消除大量的冗余替换子。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.12.39.png?raw=true\" style=\"zoom:50%;\" />\n\n### 低精度和layout优化\n\n### 相关资料\n1. https://cs.stanford.edu/~zhihao/papers/sosp19.pdf   \n2. https://github.com/jiazhihao/TASO   \n3. TensorFlow Graph Optimizations, https://web.stanford.edu/class/cs245/slides/TFGraphOptimizationsStanford.pdf   \n4. https://github.com/google/souper\n","source":"_posts/图替换.md","raw":"---\ntitle: 图替换\n\ndate: 2019-12-26 13:54:04\n\ncategory: graph optimization, 图优化\n\ntags: [图替换, 超优化, graph optimization, super optimization, substitution]\n\n---\n\n### 背景\n\n图替换（或者叫图改写）是一种重要的图优化技术，几乎在所有的开源框架（尤其是移动端框架）中都有应用。比如tensorflow r1.14版本中就包含了155个替换子，而且实现这些替换子的总代码量接近53k行。\n\n>一些常见的图优化技术：\n>\n>- DCE\n>\n>- CSE（公共子表达式消除）\n>- 常量折叠\n>- 数学公式简化\n>- Op融合\n>- Layout变换\n>- 内存优化（swap-in/swap-out、重计算）\n\n<!-- more -->\n\n由于目前的编译器技术通常基于low-level的中间表达，注重对局部计算的优化，对于跨多个粗粒度op的优化要不无能为力，要不就得增加编译器的分析难度并导致代码膨胀。一般来说AI框架支持的粗粒度op非常有限，而且这些op的组合常常也比较固定，比如convolution通常和bias_add、relu组合使用，因此基于高层中间表达的图替换成为一种比较可行的优化方案。经过图替换优化后的计算图再经过编译器的优化后，生成最终的硬件代码。\n\n目前主流开源框架的图替换都是基于经验和手工设置的替换子来实现的，在这里统称为经典图替换技术。\n\n### 经典图替换\n\n图替换是将原始计算图替换成另一个优化后的等价计算图，替换后的计算图通常是硬件友好的，比如可以消除中间结果，降低内存占用，减少访存和计算量，并且不影响最终的计算结果。\n\n在进行图替换之前，首先需要定义出源计算图到目标计算图的替换规则（替换子），由于这些替换规则往往需要依靠人的经验一条条手工去定义，因此称之为经典图替换。给出一条替换子，我们需要在原始计算图中不断地去匹配替换子的源计算子图，一旦匹配到满足要求的子图后，就将源计算子图重新映射为替换子中的目标计算图。\n\n在一些开源框架中，替换子的定义形式不尽相同。在TensorFlow中源图匹配和替换的定义是非常松散的，它甚至没有直接定义出替换子的源图，而是定义一系列约束来判断是否匹配。PaddlePaddle中则是将一个替换过程定义为一个pass，pass执行时动态构建相应的替换子源图，执行匹配算法并回调源图到目标图的替换函数。比如下面是TensorFlow中将Conv+BiasAdd替换成FusedConv的过程。\n\n- 定义匹配约束\n\n  ```c++\n  struct ContractionWithBiasAdd {\n    int constraction;\n    int bias_add;\n  }\n  // node为输入的grapper node， pattern为输出的ContractionWithBiasAdd.\n  bool FindContractionWithBias(node，*pattern) {\n    // 开始列举匹配的constractions.\n    1、如果node存在控制边，返回false\n    2、如果node不是BiasAdd，返回false\n    3、如果node的父节点不是Conv或MatMul，返回false\n    4、...\n    // 如果以上所有constructions都满足，则将需要替换的node id写到特定的pattern中。\n    pattern->constraction = node的父节点;\n    pattern->bias_add = node；\n    return true;\n  }\n  ```\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.03.21.png?raw=true\" style=\"zoom:33%;\" />\n\n- 定义替换过程\n\n  ```c++\n  // pattern为输入的ContractionWithBiasAdd，\n  void AddFusedContractionNode(pattern, *invalidated_nodes) {\n    1、创建一个新的node：fused_op\n    2、将Conv或MatMul的input和filter添加到fused_op的输入中，并将BiasAdd的bias加到fused_op的输入\n    3、根据Conv或MatMul的一些参数设置fused_op的参数，比如conv的kernel、channel、padding等等，以及matmul的transpose等\n    4、将fused_op加入到graph，同时将Conv或MatMul和BiasAdd加入到invalidated_nodes\n  }\n  ```\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.03.35.png?raw=true\" style=\"zoom:33%;\" />\n\nTensorFlow采用的定义匹配约束的方式与直接定义出子图的方式本质上是等价的，但相比后者可读性较差，而优点就是代码可复用性高，比如上面的FindContractionWithBias可以同时匹配Conv+BiasAdd和MatMul+BiasAdd两种子图，并且这些约束便于嵌套使用。\n\n无论是TensorFlow还是PaddlePaddle，图替换都是不完全的。比如说对于Conv+BiasAdd+BiasAdd这种计算图，第一次只能匹配到Conv+BiasAdd，替换后又变成了一个Conv+BiasAdd的计算图，因此TensorFlow中默认采用了两遍优化。根据TensorFlow公开的一些数据，基本上第二次优化的机会已经非常少了。\n\n- InceptionV3\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.29.51.png?raw=true\" style=\"zoom:40%;\" />\n\n- Seq2Seq\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.30.01.png?raw=true\" style=\"zoom:40%;\" />\n\n### 基于超优化的图替换\n\n超优化（Superoptimization）是现代编译器中的一种指令优化技术，其主要工作原理是通过随机生成指令序列以及暴力搜索的方式自动找到一组优化的指令序列，并等价替换原有的指令序列。1992年第一个Superoptimizer被集成到了GCC编译器，之后Google也为LLVM开发了一个Superoptimizer，取名为Souper。\n\n依靠人工设定的编译器往往对代码的优化不够彻底，给生成的code留下了大量的优化空隙，而且人工设定的优化规则往往没有经过充分验证，经常导致各种极端条件下的代码bug。Superoptimization将指令序列优化问题转换为自动搜索问题，并加入了自动化验证和一阶逻辑验证，在发现代码优化空隙的同时优化结果也更加可靠。\n\n[TASO](https://github.com/jiazhihao/TASO)（Tensor Algebra SuperOptimizer）将Superoptimization用于DNN高层中间表达的图优化，在大多数模型上取得了比XLA和TensorRT更优的效果。TASO的工作是MetaFlow（作者另一个基于人工规则的图替换框架）的延续，因此也采用了与MetaFlow一致的替换子定义。MetaFlow替换子的定义包括：源图、目标图、输入和输出的映射关系。\n\n<img src=\"https://github.com/jiazhihao/TASO/blob/master/figures/inference.png?raw=true\">\n\nTASO相比其他开源框架最大的区别就是不需要手工去设定各种各样的替换子，只需要像设计硬件指令一样设计出基本的算子定义（或者计算逻辑），之后系统会根据指定的算子集自动生成满足条件的替换子，经过验证的替换子最终作用于图替换过程。基于高度抽象的替换子定义，TASO可以独立于具体的训练或预测框架，离线完成替换子的生成和验证，并在图优化阶段加载到程序中进行图替换。尽管手工设计有很多弊端，但TASO在代码实现过程中并没有完全抛弃手工设计的方式，而是采用了手工设计和替换子自动生成相结合的方式。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2013.56.06.png?raw=true\" style=\"zoom:40%;\" />\n\n#### 替换子定义\n\n替换子包含三个部分，源图、目标图、输入和输出tensor的映射关系。并且替换子通常是与shape无关的，源图和目标图都是由算子构成的，每个算子都可以指定一些配置，比如kernel指定卷积核的大小、axis指定reduce的维度等等。\n\n但需要注意的是concat和split两个算子，在图替换中这两个算子通常用于算子融合，比如下图对两个不同的输入B和C进行相同的MatMul操作，就可以替换为先将输入B和C进行一次合并，然后调用一次MatMul后，对结果进行切分得到两个输出X和Y。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2016.24.40.png?raw=true\" style=\"zoom:50%;\" />\n\n为了能正确切分出X和Y，在Concat时我们需要给每个维度维护一个分割树（split tree）。一个行分割的例子如下，图中需要将A和B按照第0维进行concat，因此输入A在第0维有一个原始的分割树[0, $S_{A}$]，表示对于tensor A，第0维从0到$S_{A}$行都是A的数据区域。A和B concat后tensor的row变成了$S_{A}+S_{B}$，并且通过分割树可以知道第0到$S_{A}$行是A的数据，从$S_{A}$到$S_{A}+S_{B}$行是B的数据。根据分割树，Split非常容易地就可以将数据进行切分。TASO的分割树支持任意维度的切分和递归切分。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2016.37.22.png?raw=true\" style=\"zoom:70%;\" />\n\n#### 替换子生成\n\n替换子生成包含两个阶段：构建搜索空间，以及对潜在的替换子进行测试。\n\n- 构建搜索空间\n\n  搜索空间由任意合法的计算图构成，而计算图由给定的算子集中的算子组成。TASO向我们表明了一种暴力枚举、深度优先递归构建的方法。\n\n  给定算子集和初始化的input tensor集合，对于每一个输入tensor，每次从算子集中选择一个合法的算子构建graph，并计算当前graph的输出tensor，将输出tensor加入到input tensor集合， 保存graph以及graph的fingerprint（对输出tensor计算hash值），接着重复上面的过程继续加入算子，直到递归的深度达到设定的上限。\n\n  对于同样的输入tensor，如果构建的两个计算图的输出tensor相同，则这两个计算图构成了一个潜在的替换子。为了避免出现浮点计算异常的情况，构建计算图时所有的tensor都是int类型。\n\n- 测试潜在替换子\n\n  为了进一步验证潜在替换子的合法性，TASO设计了一系列cases来测试潜在替换子。每个测试case都使用随机初始化的输入tensor，当两个计算图结果一致时才认为测试通过，只有所有测试cases都通过的潜在替换子才是合法的替换子。\n\n  与构建计算图时使用int类型的tensor不一样，所有测试case的输入tensor都是-1到1之间的浮点数。由于relu对于所有小于0的值都返回0，因此可能导致非法的替换子通过测试cases，作者认为可以使用任意一个非线性函数来代替relu，TASO中使用$x(x+1)+1$。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2016.30.05.png?raw=true\" style=\"zoom:50%;\" />\n\n#### 替换子验证\n\nTASO同时使用一阶逻辑表达的算子属性对替换子进行进一步验证，这些属性通常是由人工定义，并且经过充分review和大量测试验证过的。\n\n在定义算子属性之前，首先需要对算子进行符号建模，算子模型通常包含参数和输入tensors。比如$conv(s, p, c, x, y)$表示conv算子的符号模型，$s$，$p$，$c$是conv的参数，分别表示stride、padding和activation，$x$和$y$是卷积操作的两个输入。如果activation是none，很显然conv就是一个线性操作，因此满足以下属性：\n$$\n\\begin{aligned}\n∀s,p,x,y,z. conv(s,p,Anone,ewadd(x,y),z) = \\\\\newadd(conv(s,p,Anone,x,z),conv(s,p,Anone,y,z))\n\\end{aligned}\n$$\nTASO定义了大量的算子属性，并且使用z3（一阶逻辑验证器）对所有合法的替换子进行验证。如果有合法的替换子无法被一阶逻辑验证，则需要根据替换子手动添加一条算子属性，以确保所有合法的替换子都能验证通过。\n\n#### 冗余替换子裁剪\n\n自动生成的替换子往往存在大量的冗余，TASO使用了两种策略消除冗余。\n\n- Input tensor renaming\n\n  对输入进行重命名的方式消除不同替换子之间的冗余。比如下面两个替换子，\n\n  替换子a:\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.14.31.png?raw=true\" style=\"zoom:40%;\" />\n\n  替换子b：\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.15.49.png?raw=true\" style=\"zoom:40%;\" />\n\n  将替换子a的一个输入tensor A改名为C，就得到了替换子b，说明这两个替换子存在冗余，因此最终只会保留更加通用的替换子b。\n\n- Common subgraph\n\n  如果替换子的源图和目标图包含同样的子图，则可以用一个相同的tensor替换掉公共子图。比如下面的一个替换子，\n\n  <img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.14.59.png?raw=true\" style=\"zoom:40%;\" />\n\n  source graph和target graph包含同一个子图（B x C），将source graph替换成target graph时，公共子图没有任何变化，因此可以将子图消除。\n\n实验结果显示，裁剪可以消除大量的冗余替换子。\n\n<img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.12.39.png?raw=true\" style=\"zoom:50%;\" />\n\n### 低精度和layout优化\n\n### 相关资料\n1. https://cs.stanford.edu/~zhihao/papers/sosp19.pdf   \n2. https://github.com/jiazhihao/TASO   \n3. TensorFlow Graph Optimizations, https://web.stanford.edu/class/cs245/slides/TFGraphOptimizationsStanford.pdf   \n4. https://github.com/google/souper\n","slug":"图替换","published":1,"updated":"2023-01-03T14:05:42.560Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgb13un0005j6eq25mp4v55","content":"<h3 id=\"背景\">背景</h3>\n<p>图替换（或者叫图改写）是一种重要的图优化技术，几乎在所有的开源框架（尤其是移动端框架）中都有应用。比如tensorflow\nr1.14版本中就包含了155个替换子，而且实现这些替换子的总代码量接近53k行。</p>\n<blockquote>\n<p>一些常见的图优化技术：</p>\n<ul>\n<li><p>DCE</p></li>\n<li><p>CSE（公共子表达式消除）</p></li>\n<li><p>常量折叠</p></li>\n<li><p>数学公式简化</p></li>\n<li><p>Op融合</p></li>\n<li><p>Layout变换</p></li>\n<li><p>内存优化（swap-in/swap-out、重计算）</p></li>\n</ul>\n</blockquote>\n<span id=\"more\"></span>\n<p>由于目前的编译器技术通常基于low-level的中间表达，注重对局部计算的优化，对于跨多个粗粒度op的优化要不无能为力，要不就得增加编译器的分析难度并导致代码膨胀。一般来说AI框架支持的粗粒度op非常有限，而且这些op的组合常常也比较固定，比如convolution通常和bias_add、relu组合使用，因此基于高层中间表达的图替换成为一种比较可行的优化方案。经过图替换优化后的计算图再经过编译器的优化后，生成最终的硬件代码。</p>\n<p>目前主流开源框架的图替换都是基于经验和手工设置的替换子来实现的，在这里统称为经典图替换技术。</p>\n<h3 id=\"经典图替换\">经典图替换</h3>\n<p>图替换是将原始计算图替换成另一个优化后的等价计算图，替换后的计算图通常是硬件友好的，比如可以消除中间结果，降低内存占用，减少访存和计算量，并且不影响最终的计算结果。</p>\n<p>在进行图替换之前，首先需要定义出源计算图到目标计算图的替换规则（替换子），由于这些替换规则往往需要依靠人的经验一条条手工去定义，因此称之为经典图替换。给出一条替换子，我们需要在原始计算图中不断地去匹配替换子的源计算子图，一旦匹配到满足要求的子图后，就将源计算子图重新映射为替换子中的目标计算图。</p>\n<p>在一些开源框架中，替换子的定义形式不尽相同。在TensorFlow中源图匹配和替换的定义是非常松散的，它甚至没有直接定义出替换子的源图，而是定义一系列约束来判断是否匹配。PaddlePaddle中则是将一个替换过程定义为一个pass，pass执行时动态构建相应的替换子源图，执行匹配算法并回调源图到目标图的替换函数。比如下面是TensorFlow中将Conv+BiasAdd替换成FusedConv的过程。</p>\n<ul>\n<li><p>定义匹配约束</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContractionWithBiasAdd</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> constraction;</span><br><span class=\"line\">  <span class=\"type\">int</span> bias_add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// node为输入的grapper node， pattern为输出的ContractionWithBiasAdd.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">FindContractionWithBias</span><span class=\"params\">(node，*pattern)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 开始列举匹配的constractions.</span></span><br><span class=\"line\">  <span class=\"number\">1</span>、如果node存在控制边，返回<span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"number\">2</span>、如果node不是BiasAdd，返回<span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"number\">3</span>、如果node的父节点不是Conv或MatMul，返回<span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"number\">4</span>、...</span><br><span class=\"line\">  <span class=\"comment\">// 如果以上所有constructions都满足，则将需要替换的node id写到特定的pattern中。</span></span><br><span class=\"line\">  pattern-&gt;constraction = node的父节点;</span><br><span class=\"line\">  pattern-&gt;bias_add = node；</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.03.21.png?raw=true\" style=\"zoom:33%;\" /></p>\n<ul>\n<li><p>定义替换过程</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pattern为输入的ContractionWithBiasAdd，</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AddFusedContractionNode</span><span class=\"params\">(pattern, *invalidated_nodes)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>、创建一个新的node：fused_op</span><br><span class=\"line\">  <span class=\"number\">2</span>、将Conv或MatMul的input和filter添加到fused_op的输入中，并将BiasAdd的bias加到fused_op的输入</span><br><span class=\"line\">  <span class=\"number\">3</span>、根据Conv或MatMul的一些参数设置fused_op的参数，比如conv的kernel、channel、padding等等，以及matmul的transpose等</span><br><span class=\"line\">  <span class=\"number\">4</span>、将fused_op加入到graph，同时将Conv或MatMul和BiasAdd加入到invalidated_nodes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.03.35.png?raw=true\" style=\"zoom:33%;\" /></p>\n<p>TensorFlow采用的定义匹配约束的方式与直接定义出子图的方式本质上是等价的，但相比后者可读性较差，而优点就是代码可复用性高，比如上面的FindContractionWithBias可以同时匹配Conv+BiasAdd和MatMul+BiasAdd两种子图，并且这些约束便于嵌套使用。</p>\n<p>无论是TensorFlow还是PaddlePaddle，图替换都是不完全的。比如说对于Conv+BiasAdd+BiasAdd这种计算图，第一次只能匹配到Conv+BiasAdd，替换后又变成了一个Conv+BiasAdd的计算图，因此TensorFlow中默认采用了两遍优化。根据TensorFlow公开的一些数据，基本上第二次优化的机会已经非常少了。</p>\n<ul>\n<li><p>InceptionV3</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.29.51.png?raw=true\" style=\"zoom:40%;\" /></p></li>\n<li><p>Seq2Seq</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.30.01.png?raw=true\" style=\"zoom:40%;\" /></p></li>\n</ul>\n<h3 id=\"基于超优化的图替换\">基于超优化的图替换</h3>\n<p>超优化（Superoptimization）是现代编译器中的一种指令优化技术，其主要工作原理是通过随机生成指令序列以及暴力搜索的方式自动找到一组优化的指令序列，并等价替换原有的指令序列。1992年第一个Superoptimizer被集成到了GCC编译器，之后Google也为LLVM开发了一个Superoptimizer，取名为Souper。</p>\n<p>依靠人工设定的编译器往往对代码的优化不够彻底，给生成的code留下了大量的优化空隙，而且人工设定的优化规则往往没有经过充分验证，经常导致各种极端条件下的代码bug。Superoptimization将指令序列优化问题转换为自动搜索问题，并加入了自动化验证和一阶逻辑验证，在发现代码优化空隙的同时优化结果也更加可靠。</p>\n<p><a href=\"https://github.com/jiazhihao/TASO\">TASO</a>（Tensor Algebra\nSuperOptimizer）将Superoptimization用于DNN高层中间表达的图优化，在大多数模型上取得了比XLA和TensorRT更优的效果。TASO的工作是MetaFlow（作者另一个基于人工规则的图替换框架）的延续，因此也采用了与MetaFlow一致的替换子定义。MetaFlow替换子的定义包括：源图、目标图、输入和输出的映射关系。</p>\n<p><img src=\"https://github.com/jiazhihao/TASO/blob/master/figures/inference.png?raw=true\"></p>\n<p>TASO相比其他开源框架最大的区别就是不需要手工去设定各种各样的替换子，只需要像设计硬件指令一样设计出基本的算子定义（或者计算逻辑），之后系统会根据指定的算子集自动生成满足条件的替换子，经过验证的替换子最终作用于图替换过程。基于高度抽象的替换子定义，TASO可以独立于具体的训练或预测框架，离线完成替换子的生成和验证，并在图优化阶段加载到程序中进行图替换。尽管手工设计有很多弊端，但TASO在代码实现过程中并没有完全抛弃手工设计的方式，而是采用了手工设计和替换子自动生成相结合的方式。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2013.56.06.png?raw=true\" style=\"zoom:40%;\" /></p>\n<h4 id=\"替换子定义\">替换子定义</h4>\n<p>替换子包含三个部分，源图、目标图、输入和输出tensor的映射关系。并且替换子通常是与shape无关的，源图和目标图都是由算子构成的，每个算子都可以指定一些配置，比如kernel指定卷积核的大小、axis指定reduce的维度等等。</p>\n<p>但需要注意的是concat和split两个算子，在图替换中这两个算子通常用于算子融合，比如下图对两个不同的输入B和C进行相同的MatMul操作，就可以替换为先将输入B和C进行一次合并，然后调用一次MatMul后，对结果进行切分得到两个输出X和Y。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2016.24.40.png?raw=true\" style=\"zoom:50%;\" /></p>\n<p>为了能正确切分出X和Y，在Concat时我们需要给每个维度维护一个分割树（split\ntree）。一个行分割的例子如下，图中需要将A和B按照第0维进行concat，因此输入A在第0维有一个原始的分割树[0,\n<span class=\"math inline\">\\(S_{A}\\)</span>]，表示对于tensor\nA，第0维从0到<span\nclass=\"math inline\">\\(S_{A}\\)</span>行都是A的数据区域。A和B\nconcat后tensor的row变成了<span\nclass=\"math inline\">\\(S_{A}+S_{B}\\)</span>，并且通过分割树可以知道第0到<span\nclass=\"math inline\">\\(S_{A}\\)</span>行是A的数据，从<span\nclass=\"math inline\">\\(S_{A}\\)</span>到<span\nclass=\"math inline\">\\(S_{A}+S_{B}\\)</span>行是B的数据。根据分割树，Split非常容易地就可以将数据进行切分。TASO的分割树支持任意维度的切分和递归切分。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2016.37.22.png?raw=true\" style=\"zoom:70%;\" /></p>\n<h4 id=\"替换子生成\">替换子生成</h4>\n<p>替换子生成包含两个阶段：构建搜索空间，以及对潜在的替换子进行测试。</p>\n<ul>\n<li><p>构建搜索空间</p>\n<p>搜索空间由任意合法的计算图构成，而计算图由给定的算子集中的算子组成。TASO向我们表明了一种暴力枚举、深度优先递归构建的方法。</p>\n<p>给定算子集和初始化的input\ntensor集合，对于每一个输入tensor，每次从算子集中选择一个合法的算子构建graph，并计算当前graph的输出tensor，将输出tensor加入到input\ntensor集合，\n保存graph以及graph的fingerprint（对输出tensor计算hash值），接着重复上面的过程继续加入算子，直到递归的深度达到设定的上限。</p>\n<p>对于同样的输入tensor，如果构建的两个计算图的输出tensor相同，则这两个计算图构成了一个潜在的替换子。为了避免出现浮点计算异常的情况，构建计算图时所有的tensor都是int类型。</p></li>\n<li><p>测试潜在替换子</p>\n<p>为了进一步验证潜在替换子的合法性，TASO设计了一系列cases来测试潜在替换子。每个测试case都使用随机初始化的输入tensor，当两个计算图结果一致时才认为测试通过，只有所有测试cases都通过的潜在替换子才是合法的替换子。</p>\n<p>与构建计算图时使用int类型的tensor不一样，所有测试case的输入tensor都是-1到1之间的浮点数。由于relu对于所有小于0的值都返回0，因此可能导致非法的替换子通过测试cases，作者认为可以使用任意一个非线性函数来代替relu，TASO中使用<span\nclass=\"math inline\">\\(x(x+1)+1\\)</span>。</p></li>\n</ul>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2016.30.05.png?raw=true\" style=\"zoom:50%;\" /></p>\n<h4 id=\"替换子验证\">替换子验证</h4>\n<p>TASO同时使用一阶逻辑表达的算子属性对替换子进行进一步验证，这些属性通常是由人工定义，并且经过充分review和大量测试验证过的。</p>\n<p>在定义算子属性之前，首先需要对算子进行符号建模，算子模型通常包含参数和输入tensors。比如<span\nclass=\"math inline\">\\(conv(s, p, c, x,\ny)\\)</span>表示conv算子的符号模型，<span\nclass=\"math inline\">\\(s\\)</span>，<span\nclass=\"math inline\">\\(p\\)</span>，<span\nclass=\"math inline\">\\(c\\)</span>是conv的参数，分别表示stride、padding和activation，<span\nclass=\"math inline\">\\(x\\)</span>和<span\nclass=\"math inline\">\\(y\\)</span>是卷积操作的两个输入。如果activation是none，很显然conv就是一个线性操作，因此满足以下属性：\n<span class=\"math display\">\\[\n\\begin{aligned}\n∀s,p,x,y,z. conv(s,p,Anone,ewadd(x,y),z) = \\\\\newadd(conv(s,p,Anone,x,z),conv(s,p,Anone,y,z))\n\\end{aligned}\n\\]</span>\nTASO定义了大量的算子属性，并且使用z3（一阶逻辑验证器）对所有合法的替换子进行验证。如果有合法的替换子无法被一阶逻辑验证，则需要根据替换子手动添加一条算子属性，以确保所有合法的替换子都能验证通过。</p>\n<h4 id=\"冗余替换子裁剪\">冗余替换子裁剪</h4>\n<p>自动生成的替换子往往存在大量的冗余，TASO使用了两种策略消除冗余。</p>\n<ul>\n<li><p>Input tensor renaming</p>\n<p>对输入进行重命名的方式消除不同替换子之间的冗余。比如下面两个替换子，</p>\n<p>替换子a:</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.14.31.png?raw=true\" style=\"zoom:40%;\" /></p>\n<p>替换子b：</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.15.49.png?raw=true\" style=\"zoom:40%;\" /></p>\n<p>将替换子a的一个输入tensor\nA改名为C，就得到了替换子b，说明这两个替换子存在冗余，因此最终只会保留更加通用的替换子b。</p></li>\n<li><p>Common subgraph</p>\n<p>如果替换子的源图和目标图包含同样的子图，则可以用一个相同的tensor替换掉公共子图。比如下面的一个替换子，</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.14.59.png?raw=true\" style=\"zoom:40%;\" /></p>\n<p>source graph和target graph包含同一个子图（B x C），将source\ngraph替换成target\ngraph时，公共子图没有任何变化，因此可以将子图消除。</p></li>\n</ul>\n<p>实验结果显示，裁剪可以消除大量的冗余替换子。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.12.39.png?raw=true\" style=\"zoom:50%;\" /></p>\n<h3 id=\"低精度和layout优化\">低精度和layout优化</h3>\n<h3 id=\"相关资料\">相关资料</h3>\n<ol type=\"1\">\n<li>https://cs.stanford.edu/~zhihao/papers/sosp19.pdf<br />\n</li>\n<li>https://github.com/jiazhihao/TASO<br />\n</li>\n<li>TensorFlow Graph Optimizations,\nhttps://web.stanford.edu/class/cs245/slides/TFGraphOptimizationsStanford.pdf<br />\n</li>\n<li>https://github.com/google/souper</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"背景\">背景</h3>\n<p>图替换（或者叫图改写）是一种重要的图优化技术，几乎在所有的开源框架（尤其是移动端框架）中都有应用。比如tensorflow\nr1.14版本中就包含了155个替换子，而且实现这些替换子的总代码量接近53k行。</p>\n<blockquote>\n<p>一些常见的图优化技术：</p>\n<ul>\n<li><p>DCE</p></li>\n<li><p>CSE（公共子表达式消除）</p></li>\n<li><p>常量折叠</p></li>\n<li><p>数学公式简化</p></li>\n<li><p>Op融合</p></li>\n<li><p>Layout变换</p></li>\n<li><p>内存优化（swap-in/swap-out、重计算）</p></li>\n</ul>\n</blockquote>","more":"<p>由于目前的编译器技术通常基于low-level的中间表达，注重对局部计算的优化，对于跨多个粗粒度op的优化要不无能为力，要不就得增加编译器的分析难度并导致代码膨胀。一般来说AI框架支持的粗粒度op非常有限，而且这些op的组合常常也比较固定，比如convolution通常和bias_add、relu组合使用，因此基于高层中间表达的图替换成为一种比较可行的优化方案。经过图替换优化后的计算图再经过编译器的优化后，生成最终的硬件代码。</p>\n<p>目前主流开源框架的图替换都是基于经验和手工设置的替换子来实现的，在这里统称为经典图替换技术。</p>\n<h3 id=\"经典图替换\">经典图替换</h3>\n<p>图替换是将原始计算图替换成另一个优化后的等价计算图，替换后的计算图通常是硬件友好的，比如可以消除中间结果，降低内存占用，减少访存和计算量，并且不影响最终的计算结果。</p>\n<p>在进行图替换之前，首先需要定义出源计算图到目标计算图的替换规则（替换子），由于这些替换规则往往需要依靠人的经验一条条手工去定义，因此称之为经典图替换。给出一条替换子，我们需要在原始计算图中不断地去匹配替换子的源计算子图，一旦匹配到满足要求的子图后，就将源计算子图重新映射为替换子中的目标计算图。</p>\n<p>在一些开源框架中，替换子的定义形式不尽相同。在TensorFlow中源图匹配和替换的定义是非常松散的，它甚至没有直接定义出替换子的源图，而是定义一系列约束来判断是否匹配。PaddlePaddle中则是将一个替换过程定义为一个pass，pass执行时动态构建相应的替换子源图，执行匹配算法并回调源图到目标图的替换函数。比如下面是TensorFlow中将Conv+BiasAdd替换成FusedConv的过程。</p>\n<ul>\n<li><p>定义匹配约束</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContractionWithBiasAdd</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> constraction;</span><br><span class=\"line\">  <span class=\"type\">int</span> bias_add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// node为输入的grapper node， pattern为输出的ContractionWithBiasAdd.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">FindContractionWithBias</span><span class=\"params\">(node，*pattern)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 开始列举匹配的constractions.</span></span><br><span class=\"line\">  <span class=\"number\">1</span>、如果node存在控制边，返回<span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"number\">2</span>、如果node不是BiasAdd，返回<span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"number\">3</span>、如果node的父节点不是Conv或MatMul，返回<span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"number\">4</span>、...</span><br><span class=\"line\">  <span class=\"comment\">// 如果以上所有constructions都满足，则将需要替换的node id写到特定的pattern中。</span></span><br><span class=\"line\">  pattern-&gt;constraction = node的父节点;</span><br><span class=\"line\">  pattern-&gt;bias_add = node；</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.03.21.png?raw=true\" style=\"zoom:33%;\" /></p>\n<ul>\n<li><p>定义替换过程</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pattern为输入的ContractionWithBiasAdd，</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AddFusedContractionNode</span><span class=\"params\">(pattern, *invalidated_nodes)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>、创建一个新的node：fused_op</span><br><span class=\"line\">  <span class=\"number\">2</span>、将Conv或MatMul的input和filter添加到fused_op的输入中，并将BiasAdd的bias加到fused_op的输入</span><br><span class=\"line\">  <span class=\"number\">3</span>、根据Conv或MatMul的一些参数设置fused_op的参数，比如conv的kernel、channel、padding等等，以及matmul的transpose等</span><br><span class=\"line\">  <span class=\"number\">4</span>、将fused_op加入到graph，同时将Conv或MatMul和BiasAdd加入到invalidated_nodes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.03.35.png?raw=true\" style=\"zoom:33%;\" /></p>\n<p>TensorFlow采用的定义匹配约束的方式与直接定义出子图的方式本质上是等价的，但相比后者可读性较差，而优点就是代码可复用性高，比如上面的FindContractionWithBias可以同时匹配Conv+BiasAdd和MatMul+BiasAdd两种子图，并且这些约束便于嵌套使用。</p>\n<p>无论是TensorFlow还是PaddlePaddle，图替换都是不完全的。比如说对于Conv+BiasAdd+BiasAdd这种计算图，第一次只能匹配到Conv+BiasAdd，替换后又变成了一个Conv+BiasAdd的计算图，因此TensorFlow中默认采用了两遍优化。根据TensorFlow公开的一些数据，基本上第二次优化的机会已经非常少了。</p>\n<ul>\n<li><p>InceptionV3</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.29.51.png?raw=true\" style=\"zoom:40%;\" /></p></li>\n<li><p>Seq2Seq</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-26%2011.30.01.png?raw=true\" style=\"zoom:40%;\" /></p></li>\n</ul>\n<h3 id=\"基于超优化的图替换\">基于超优化的图替换</h3>\n<p>超优化（Superoptimization）是现代编译器中的一种指令优化技术，其主要工作原理是通过随机生成指令序列以及暴力搜索的方式自动找到一组优化的指令序列，并等价替换原有的指令序列。1992年第一个Superoptimizer被集成到了GCC编译器，之后Google也为LLVM开发了一个Superoptimizer，取名为Souper。</p>\n<p>依靠人工设定的编译器往往对代码的优化不够彻底，给生成的code留下了大量的优化空隙，而且人工设定的优化规则往往没有经过充分验证，经常导致各种极端条件下的代码bug。Superoptimization将指令序列优化问题转换为自动搜索问题，并加入了自动化验证和一阶逻辑验证，在发现代码优化空隙的同时优化结果也更加可靠。</p>\n<p><a href=\"https://github.com/jiazhihao/TASO\">TASO</a>（Tensor Algebra\nSuperOptimizer）将Superoptimization用于DNN高层中间表达的图优化，在大多数模型上取得了比XLA和TensorRT更优的效果。TASO的工作是MetaFlow（作者另一个基于人工规则的图替换框架）的延续，因此也采用了与MetaFlow一致的替换子定义。MetaFlow替换子的定义包括：源图、目标图、输入和输出的映射关系。</p>\n<p><img src=\"https://github.com/jiazhihao/TASO/blob/master/figures/inference.png?raw=true\"></p>\n<p>TASO相比其他开源框架最大的区别就是不需要手工去设定各种各样的替换子，只需要像设计硬件指令一样设计出基本的算子定义（或者计算逻辑），之后系统会根据指定的算子集自动生成满足条件的替换子，经过验证的替换子最终作用于图替换过程。基于高度抽象的替换子定义，TASO可以独立于具体的训练或预测框架，离线完成替换子的生成和验证，并在图优化阶段加载到程序中进行图替换。尽管手工设计有很多弊端，但TASO在代码实现过程中并没有完全抛弃手工设计的方式，而是采用了手工设计和替换子自动生成相结合的方式。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2013.56.06.png?raw=true\" style=\"zoom:40%;\" /></p>\n<h4 id=\"替换子定义\">替换子定义</h4>\n<p>替换子包含三个部分，源图、目标图、输入和输出tensor的映射关系。并且替换子通常是与shape无关的，源图和目标图都是由算子构成的，每个算子都可以指定一些配置，比如kernel指定卷积核的大小、axis指定reduce的维度等等。</p>\n<p>但需要注意的是concat和split两个算子，在图替换中这两个算子通常用于算子融合，比如下图对两个不同的输入B和C进行相同的MatMul操作，就可以替换为先将输入B和C进行一次合并，然后调用一次MatMul后，对结果进行切分得到两个输出X和Y。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2016.24.40.png?raw=true\" style=\"zoom:50%;\" /></p>\n<p>为了能正确切分出X和Y，在Concat时我们需要给每个维度维护一个分割树（split\ntree）。一个行分割的例子如下，图中需要将A和B按照第0维进行concat，因此输入A在第0维有一个原始的分割树[0,\n<span class=\"math inline\">\\(S_{A}\\)</span>]，表示对于tensor\nA，第0维从0到<span\nclass=\"math inline\">\\(S_{A}\\)</span>行都是A的数据区域。A和B\nconcat后tensor的row变成了<span\nclass=\"math inline\">\\(S_{A}+S_{B}\\)</span>，并且通过分割树可以知道第0到<span\nclass=\"math inline\">\\(S_{A}\\)</span>行是A的数据，从<span\nclass=\"math inline\">\\(S_{A}\\)</span>到<span\nclass=\"math inline\">\\(S_{A}+S_{B}\\)</span>行是B的数据。根据分割树，Split非常容易地就可以将数据进行切分。TASO的分割树支持任意维度的切分和递归切分。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-29%2016.37.22.png?raw=true\" style=\"zoom:70%;\" /></p>\n<h4 id=\"替换子生成\">替换子生成</h4>\n<p>替换子生成包含两个阶段：构建搜索空间，以及对潜在的替换子进行测试。</p>\n<ul>\n<li><p>构建搜索空间</p>\n<p>搜索空间由任意合法的计算图构成，而计算图由给定的算子集中的算子组成。TASO向我们表明了一种暴力枚举、深度优先递归构建的方法。</p>\n<p>给定算子集和初始化的input\ntensor集合，对于每一个输入tensor，每次从算子集中选择一个合法的算子构建graph，并计算当前graph的输出tensor，将输出tensor加入到input\ntensor集合，\n保存graph以及graph的fingerprint（对输出tensor计算hash值），接着重复上面的过程继续加入算子，直到递归的深度达到设定的上限。</p>\n<p>对于同样的输入tensor，如果构建的两个计算图的输出tensor相同，则这两个计算图构成了一个潜在的替换子。为了避免出现浮点计算异常的情况，构建计算图时所有的tensor都是int类型。</p></li>\n<li><p>测试潜在替换子</p>\n<p>为了进一步验证潜在替换子的合法性，TASO设计了一系列cases来测试潜在替换子。每个测试case都使用随机初始化的输入tensor，当两个计算图结果一致时才认为测试通过，只有所有测试cases都通过的潜在替换子才是合法的替换子。</p>\n<p>与构建计算图时使用int类型的tensor不一样，所有测试case的输入tensor都是-1到1之间的浮点数。由于relu对于所有小于0的值都返回0，因此可能导致非法的替换子通过测试cases，作者认为可以使用任意一个非线性函数来代替relu，TASO中使用<span\nclass=\"math inline\">\\(x(x+1)+1\\)</span>。</p></li>\n</ul>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2016.30.05.png?raw=true\" style=\"zoom:50%;\" /></p>\n<h4 id=\"替换子验证\">替换子验证</h4>\n<p>TASO同时使用一阶逻辑表达的算子属性对替换子进行进一步验证，这些属性通常是由人工定义，并且经过充分review和大量测试验证过的。</p>\n<p>在定义算子属性之前，首先需要对算子进行符号建模，算子模型通常包含参数和输入tensors。比如<span\nclass=\"math inline\">\\(conv(s, p, c, x,\ny)\\)</span>表示conv算子的符号模型，<span\nclass=\"math inline\">\\(s\\)</span>，<span\nclass=\"math inline\">\\(p\\)</span>，<span\nclass=\"math inline\">\\(c\\)</span>是conv的参数，分别表示stride、padding和activation，<span\nclass=\"math inline\">\\(x\\)</span>和<span\nclass=\"math inline\">\\(y\\)</span>是卷积操作的两个输入。如果activation是none，很显然conv就是一个线性操作，因此满足以下属性：\n<span class=\"math display\">\\[\n\\begin{aligned}\n∀s,p,x,y,z. conv(s,p,Anone,ewadd(x,y),z) = \\\\\newadd(conv(s,p,Anone,x,z),conv(s,p,Anone,y,z))\n\\end{aligned}\n\\]</span>\nTASO定义了大量的算子属性，并且使用z3（一阶逻辑验证器）对所有合法的替换子进行验证。如果有合法的替换子无法被一阶逻辑验证，则需要根据替换子手动添加一条算子属性，以确保所有合法的替换子都能验证通过。</p>\n<h4 id=\"冗余替换子裁剪\">冗余替换子裁剪</h4>\n<p>自动生成的替换子往往存在大量的冗余，TASO使用了两种策略消除冗余。</p>\n<ul>\n<li><p>Input tensor renaming</p>\n<p>对输入进行重命名的方式消除不同替换子之间的冗余。比如下面两个替换子，</p>\n<p>替换子a:</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.14.31.png?raw=true\" style=\"zoom:40%;\" /></p>\n<p>替换子b：</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.15.49.png?raw=true\" style=\"zoom:40%;\" /></p>\n<p>将替换子a的一个输入tensor\nA改名为C，就得到了替换子b，说明这两个替换子存在冗余，因此最终只会保留更加通用的替换子b。</p></li>\n<li><p>Common subgraph</p>\n<p>如果替换子的源图和目标图包含同样的子图，则可以用一个相同的tensor替换掉公共子图。比如下面的一个替换子，</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.14.59.png?raw=true\" style=\"zoom:40%;\" /></p>\n<p>source graph和target graph包含同一个子图（B x C），将source\ngraph替换成target\ngraph时，公共子图没有任何变化，因此可以将子图消除。</p></li>\n</ul>\n<p>实验结果显示，裁剪可以消除大量的冗余替换子。</p>\n<p><img src=\"https://github.com/hjchen2/personal/blob/master/blog/substitution/屏幕快照%202019-12-30%2018.12.39.png?raw=true\" style=\"zoom:50%;\" /></p>\n<h3 id=\"低精度和layout优化\">低精度和layout优化</h3>\n<h3 id=\"相关资料\">相关资料</h3>\n<ol type=\"1\">\n<li>https://cs.stanford.edu/~zhihao/papers/sosp19.pdf<br />\n</li>\n<li>https://github.com/jiazhihao/TASO<br />\n</li>\n<li>TensorFlow Graph Optimizations,\nhttps://web.stanford.edu/class/cs245/slides/TFGraphOptimizationsStanford.pdf<br />\n</li>\n<li>https://github.com/google/souper</li>\n</ol>"},{"title":"如何在XRT框架下添加自定义的后端引擎","date":"2020-02-25T08:06:18.000Z","_content":"\nXRT为不同的后端引擎提供了统一的上层功能和接口抽象，这些功能和接口包括：\n\n- 统一的DAG计算图表示\n- 统一的子图表达、切分和折叠过程\n- 统一的JIT子图编译接口和缓存机制\n- 统一的Executable Launch接口\n\n得益于上层统一的抽象和模块化的设计，后端引擎只需要处理一些差异化的接口，并且这些差异化通常只体现在子图的编译和executable launch接口的具体实现上。\n\n<!-- more -->\n\n我们把XRT的每个子图都看成是一个function，function包含输入和输出参数，以及对应的函数体（DAG表示的计算图），比如下面表示的是只包含一个relu节点的XRT子图。\n\n```txt\nfunction {\n  argument {\n    name: \"_input_argument_0\"\n    value: \"conv1/out\"\n  }\n  argument {\n    name: \"_output_argument_0\"\n    value: \"relu1/out\"\n  }\n  node {\n    name: \"relu1\"\n    device_type: kGPU\n    relu_conf {\n      in: \"conv1/out\"\n      out: \"out\"\n    }\n  }\n}\n```\n\n在runtime阶段function首先需要被编译成executable，执行function实际上就是feed对应的输入参数去launch这个编译好的executable，同时得到执行的结果，即function的返回值。\n\n在XRT框架下每个后端引擎都有一个与之相对应的executable（比如XLA的XlaExecutable和TensorRT的TrtExecutable），和将function编译成对应executable的compiler（比如XLA的XlaGraphCompiler和TensorRT的TrtGraphCompiler），因此添加一个新的后端引擎，通常只需要添加一个对应的executable和compiler。下面以添加一个自定义的后端引擎Test为例，详细介绍在XRT框架下支持新的后端引擎的具体过程。\n\n首先在xrt/types.proto文件中XrtEngine下增加一个Test引擎字段。\n\n```c++\nenum XrtEngine {\n  DEFAULT = 1;\n  XLA = 2;\n  TENSORRT = 3;\n  TVM = 4;\n  TEST = 5;  // For Test engine\n}\n```\n\n如果Test引擎针对的硬件不在XrtDevice中，则需要在XrtDevice中增加对应的设备字段。假设我们自定义的Test引擎只支持GPU_CUDA，因此这里就不需要修改XrtDevice了。\n\n接下来，与XLA和TensorRT一样，我们在xrt目录下创建一个test目录，其余所有与Test引擎相关的代码都将放在该目录下。\n\n## Test Executable\n\n在增加任何一个后端引擎之前，我们都需要仔细考虑该后端引擎所需的最小执行环境，一个最简单的执行环境包括输入输出、中间结果以及执行具体计算逻辑的硬件代码，这个代码可以是通过codegen自动生成的，也可以是手工实现的。\n\n接下来我们给自定义的Test引擎增加一个对应的TestExecutable。在xrt/test目录下，我们创建文件test_executable.h和test_executable.cpp。\n\ntest_executable.h中定义TestExecutable，TestExecutable必须继承自Executable，并实现Run接口。为了尽可能简单，TestExecutable只包含输出outputs、中间结果tmp_buffers和编排好的函数调用列表func_codes，以及每个函数的输入输出参数对应的buffer序号func_args_。\n\n```c++\n#ifndef ONEFLOW_XRT_TEST_TEST_EXECUTABLE_H_\n\n#include \"oneflow/xrt/executable.h\"\n#include \"oneflow/xrt/parameter.h\"\n\n#include <vector>\n#include <functional>\n\nnamespace oneflow {\nnamespace xrt {\n\ntypedef std::function<void(const std::vector<Parameter> &,\n                           const std::vector<Parameter> &)> FuncCode;\n\nstruct FuncArgumentIndices {\n  std::vector<int> inputs;\n  std::vector<int> outputs;\n};\n\nclass TestExecutable : public Executable {\n public:\n  TestExecutable(const std::string &name, const int num_inputs,\n                 const std::vector<Parameter> &outputs,\n                 const std::vector<Parameter> &temp_buffers,\n                 const std::vector<FuncCode> &func_codes,\n                 const std::vector<FuncArgumentIndices> &func_args);\n\n  bool Run(const std::vector<Parameter> &inputs,\n           const ExecutableRunOptions &run_options,\n           bool block_until_done = true) override;\n\n private:\n  int num_inputs_;\n  std::vector<Parameter> outputs_;\n  std::vector<Parameter> temp_buffers_;\n  std::vector<FuncCode> func_codes_;\n  std::vector<FuncArgumentIndices> func_args_;\n};\n\n}  // namespace xrt\n}  // namespace oneflow\n\n#endif  // ONEFLOW_XRT_TEST_TEST_EXECUTABLE_H_\n```\n\n在test_executable.cpp中实现Run方法，这里我们只是简单的顺序执行编排好的函数func_codes。\n\n```c++\n#include \"oneflow/xrt/test/test_executable.h\"\n\nnamespace oneflow {\nnamespace xrt {\n\nTestExecutable::TestExecutable(const std::string &name, const int num_inputs,\n                               const std::vector<Parameter> &outputs,\n                               const std::vector<Parameter> &temp_buffers,\n                               const std::vector<FuncCode> &func_codes,\n                               const std::vector<FuncArgumentIndices> &func_args)\n    : Executable(name, XrtEngine::TEST),\n      num_inputs_(num_inputs),\n      outputs_(outputs),\n      temp_buffers_(temp_buffers),\n      func_codes_(func_codes),\n      func_args_(func_args) {}\n\nbool TestExecutable::Run(const std::vector<Parameter> &inputs,\n                         const ExecutableRunOptions &run_options,\n                         bool block_until_done) {\n  auto PullArgs = [&](const std::vector<int> &indices) {\n    std::vector<Parameter> args;\n    for (int idx : indices) {\n      if (idx < num_inputs_) {\n        args.push_back(inputs[idx]);\n      } else if (idx < num_inputs_ + outputs_.size()) {\n        args.push_back(outputs_[idx - num_inputs_]);\n      } else {\n        idx -= (num_inputs_ + outputs_.size());\n        CHECK_GE(idx, 0);\n        CHECK_LT(idx, temp_buffers_.size());\n        args.push_back(temp_buffers_[idx]);\n      }\n    }\n    return std::move(args);\n  };\n\n  CHECK_EQ(inputs.size(), num_inputs_);\n\n  for (int i = 0; i < func_codes_.size(); ++i) {\n    auto in_args = PullArgs(func_args_[i].inputs);\n    auto out_args = PullArgs(func_args_[i].outputs);\n    func_codes_[i](in_args, out_args);\n  }\n\n  // Synchronize stream if block_until_done.\n  if (block_until_done) {\n    // TODO(hjchen2)\n  }\n\n  // All return params are the results of the executable.\n  this->results_ = run_options.return_params;\n  return true /*running status*/;\n}\n\n}  // namespace xrt\n}  // namespace oneflow\n```\n\n目前为止我们已经完成了一个最简单的运行时executable，这个executable甚至有点类似其他框架中提供的最简单的图执行器（graph executor）。接下来我们要介绍如何将一个XRT的子图编译成上面的TestExecutable。\n\n## Test Compiler\n\n每个后端引擎都对应一个compiler，当我们希望使用某个后端引擎来执行一个XRT子图时，就需要有一个对应的compiler将该子图编译成后端引擎对应的executable。Compiler通常都非常注重编译产物的执行性能，而性能以外的关切点也导致了不同的技术路线，比如对算法通用性、跨平台有高度关切的TVM和XLA采用了LLVM传统编译器的路线，而对于过分看重性能但硬件平台单一的TensorRT更多的则是采用手工优化和tuning相结合的策略。不过这两种技术路线并不是完全对立的，也是在不断地相互借鉴和融合。\n\n在XRT中，所有这些技术方案都是可以被兼容的，你可以根据实际情况自由切换，你也可以把XRT当成实验场所，实现一个自定义的compiler，并在同一套框架下对比不同compiler、不同技术方案的优劣。\n\n回到本文的主题，我们现在需要实现一个TestExecutable对应的compiler，我们也把该compiler叫做TestGraphCompiler。\n\n首先在xrt/test目录下新建两个文件test_graph_compiler.h和test_graph_compiler.cpp。在test_graph_compiler.h文件中定义类TestGraphCompiler，TestGraphCompiler必须继承自类GraphCompiler::Impl，并实现对应的Compile接口。\n\n```c++\nclass TestGraphCompiler : public GraphCompiler::Impl {\n public:\n  explicit TestGraphCompiler(const std::string &name)\n      : GraphCompiler::Impl(name) {}\n\n  virtual ~TestGraphCompiler() = default;\n\n  std::shared_ptr<Executable> Compile(\n      const XrtGraph *graph,\n      const std::vector<Parameter> &entry_params,\n      const std::vector<Parameter> &return_params,\n      const std::vector<InputOutputAlias> &aliases) override;\n};\n```\n\n在test_graph_compiler.cpp中实现Compile接口，并注册一个新的graph compiler。在动手实现该接口之前，有必要先解释一下该接口的参数列表，graph表示的是function子图，entry_params表示子图的输入，return_params表示子图的输出，aliases通常在包含模型更新操作时会用到，表明输出和输入是一对别名关系。被alias的输入将生命期延长到了整个子图，并且与对应的输出共享内存，实际上也就间接实现了in-place计算的目的。\n\n我们按拓扑顺序遍历子图中的每个节点（或op），依次将节点编译成具体的执行代码，并在合适的位置插入临时buffer。为了方便处理不同类型的op，我们在下面的代码中引入了TestOpContext和TestOpKernel的概念。\n\n```c++\n// Register a new graph compiler for TEST engine.\nREGISTER_GRAPH_COMPILER(XrtEngine::TEST, TestGraphCompiler);\n\n// Realize Compile interface.\nstd::shared_ptr<Executable> TestGraphCompiler::Compile(\n    const XrtGraph *graph,\n    const std::vector<Parameter> &entry_params,\n    const std::vector<Parameter> &return_params,\n    const std::vector<InputOutputAlias> &aliases) {\n  std::vector<Parameter> temp_buffers;\n  std::vector<FuncCode> func_codes;\n  std::vector<FuncArgumentIndices> func_args;\n\n  std::unordered_map<std::string, int> indices;\n  std::unordered_map<std::string, Parameter> all_params;\n  for (auto param : entry_params) {\n    indices.emplace(param.name(), indices.size());\n    all_params[param.name()] = param;\n  }\n  for (auto param : return_params) {\n    indices.emplace(param.name(), indices.size());\n    all_params[param.name()] = param;\n  }\n\n  algorithm::TopologyVisit(*graph, [&](const XrtNode *node) {\n    if (node->type() == \"Argument\") {\n      // Argument node is not computation node, so skip it.\n      return;\n    }\n\n    TestOpContext op_context(node, all_params);\n    auto op_kernel = BuildTestOpKernel(node->type());\n    op_kernel->Compile(&op_context);\n\n    func_codes.push_back(op_context.func_code_);\n\n    const auto &buffers = op_context.tmp_buffers_;\n    for (auto it = buffers.begin(); it != buffers.end(); ++it) {\n      all_params[it->first] = it->second;\n      temp_buffers.push_back(it->second);\n      indices.emplace(it->first, indices.size());\n    }\n\n    // Finalize argument indices for each function.\n    FuncArgumentIndices arg_indices;\n    for (const auto &arg : op_context.input_args_) {\n      arg_indices.inputs.push_back(indices.at(arg));\n    }\n    for (const auto &arg : op_context.output_args_) {\n      arg_indices.outputs.push_back(indices.at(arg));\n    }\n    func_args.push_back(std::move(arg_indices));\n  });\n\n  return std::make_shared<TestExecutable>(this->name_, entry_params.size(),\n                                          return_params, temp_buffers,\n                                          func_codes, func_args);\n}\n```\n\nTestOpContext临时存储编译需要的元信息和编译结果，为TestOpKernel提供必要的接口，TestOpKernel则根据op类型完成单个op的编译过程。上述代码中我们实现了一个将XRT子图编译成TestExecutable的最简单的graph compiler，下面我们将以ReLU op为例，介绍TestOpContext和TestOpKernel是如何对op进行编译的。\n\n## Test Kernels\n\n我们回过头再仔细研究一下TestGraphCompiler的Compile实现，TestOpContext接受两个输入，node和当前所有已经创建过的parameters，经过OpKernel编译后输出函数代码（func_code\\_）、中间buffer（tmp_buffers\\_），以及函数代码输入和输出对应的parameter names。因此在这个例子中，TestOpContext被设计成如下形式：\n\n```c++\nclass TestOpContext {\n public:\n  TestOpContext(const XrtNode *node,\n                const std::unordered_map<std::string, Parameter> &all_params)\n      : node_(node), all_params_(all_params) {}\n\n public:\n  const XrtNode *node_;\n  const std::unordered_map<std::string, Parameter> &all_params_;\n\n  std::function<void(const std::vector<Parameter>&,\n                     const std::vector<Parameter>&)> func_code_;\n  std::vector<std::string> input_args_;\n  std::vector<std::string> output_args_;\n  std::unordered_map<std::string, Parameter> tmp_buffers_;\n};\n```\n\n对于TestOpKernel，为了处理不同类型的op，我们采用工厂注册模式，并且这种模式还有另一个用处，就是在XRT划分子图时可以用来判断该引擎是否支持某个类型的op。XRT已经将kernel注册接口封装成了一个辅助类OpKernelRegistrar，但同时也要求TestOpKernel必须继承基类OpKernel。\n\n```c++\nclass TestOpKernel : public OpKernel<TestOpContext> {\n public:\n  virtual void Compile(TestOpContext *ctx) = 0;\n};\n```\n\n使用OpKernelRegistrar定义一个用来注册TestOpKernel的宏。\n\n```c++\n#define REGISTER_TEST_OP_KERNEL(OpName, KernelType)                 \\\n  static auto _test_op_kernel_##OpName##_ __attribute__((unused)) = \\\n      OpKernelRegistrar<TestOpContext>(#OpName)                     \\\n          .SetField(XrtEngine::TEST)                                \\\n          .SetDevice({XrtDevice::GPU_CUDA})                         \\\n          .SetFactory([]() -> OpKernel<TestOpContext> * {           \\\n                        return new KernelType;                      \\\n                      })\n```\n\n最后我们实现一个Relu的OpKernel，填充TestOpContext的func_code\\_、tmp_buffers\\_以及输入输出arguments。\n\n```c++\nvoid ComputeRelu(const Parameter &input, const Parameter &output) {\n  //TODO(hjchen2)\n}\n\nclass TestReluOpKernel : public TestOpKernel {\n public:\n  void Compile(TestOpContext *ctx) override {\n    ctx->func_code_ = [](const std::vector<Parameter> &inputs,\n                         const std::vector<Parameter> &outputs) {\n      CHECK_EQ(inputs.size(), 1);\n      CHECK_EQ(outputs.size(), 1);\n      ComputeRelu(inputs[0], outputs[0]);\n    };\n\n    for (const XrtEdge *edge : ctx->node_->in_edges()) {\n      const auto &name = edge->argument().name();\n      CHECK_GT(ctx->all_params_.count(name), 0);\n      // TODO(hjchen2): Filter duplicate input.\n      ctx->input_args_.push_back(name);\n    }\n\n    for (const XrtEdge *edge : ctx->node_->out_edges()) {\n      const auto &name = edge->argument().name();\n      // TODO(hjchen2): Filter duplicate output.\n      ctx->output_args_.push_back(name);\n      if (ctx->all_params_.count(name) == 0 &&\n          ctx->tmp_buffers_.count(name) == 0) {\n        auto param = CreateParameter(name /*argument name*/,\n                                     edge->argument().shape(),\n                                     edge->argument().data_type());\n        ctx->tmp_buffers_[name] = std::move(param);\n      }\n    }\n  }\n};\n```\n\n最后将TestReluOpKernel注册到Test引擎对应的OpKernel工厂下。\n\n```c++\nREGISTER_TEST_OP_KERNEL(Relu, TestReluOpKernel)\n    .EnableTrainPhase()\n    .Finalize();\n```\n\nEnableTrainPhase表示该op支持训练，OpKernelRegistrar也提供了其他一些接口，比如设置支持的device列表，mutable variables和是否是optimizer op（optimizer会影响子图划分）。\n\n## Python和C++ APIs\n\n引擎的开启或关闭可以通过Python接口和环境变量来设置，因此添加一个后端引擎时也需要在Python中添加相应的接口，在python/framework/function_util.py文件中增加如下代码，\n\n```python\n@oneflow_function_config('use_test')\ndef set_use_test(func_desc, value = True):\n    func_desc.job_config_proto.xrt_config.use_test = value\n```\n\n并且在xrt/api.cpp中增加一个gflags环境变量，并在该文件中修改相关接口。\n\n- 增加一个gflags环境变量\n\n  ```c++\n  DEFINE_bool(use_test, EnvToBool(FLAGS_use_test, false), \"It's optional to use test.\");\n  ```\n\n- 修改InitXrtConfigurations、XrtCompilationEnabled和CreateDefaultXrtPassOptions接口，增加对Test引擎的支持。\n\n## 完整代码\nhttps://github.com/Oneflow-Inc/oneflow/commit/50a74bc110f3aacfa853456d9b695f2ba80e9e0a\n","source":"_posts/如何在XRT框架下添加自定义的后端引擎.md","raw":"---\ntitle: 如何在XRT框架下添加自定义的后端引擎\n\ndate: 2020-02-25 16:06:18\n\ncategory: XRT\n\ntags: [XRT, Compiler, TensorFlow XLA, TensorRT]\n\n---\n\nXRT为不同的后端引擎提供了统一的上层功能和接口抽象，这些功能和接口包括：\n\n- 统一的DAG计算图表示\n- 统一的子图表达、切分和折叠过程\n- 统一的JIT子图编译接口和缓存机制\n- 统一的Executable Launch接口\n\n得益于上层统一的抽象和模块化的设计，后端引擎只需要处理一些差异化的接口，并且这些差异化通常只体现在子图的编译和executable launch接口的具体实现上。\n\n<!-- more -->\n\n我们把XRT的每个子图都看成是一个function，function包含输入和输出参数，以及对应的函数体（DAG表示的计算图），比如下面表示的是只包含一个relu节点的XRT子图。\n\n```txt\nfunction {\n  argument {\n    name: \"_input_argument_0\"\n    value: \"conv1/out\"\n  }\n  argument {\n    name: \"_output_argument_0\"\n    value: \"relu1/out\"\n  }\n  node {\n    name: \"relu1\"\n    device_type: kGPU\n    relu_conf {\n      in: \"conv1/out\"\n      out: \"out\"\n    }\n  }\n}\n```\n\n在runtime阶段function首先需要被编译成executable，执行function实际上就是feed对应的输入参数去launch这个编译好的executable，同时得到执行的结果，即function的返回值。\n\n在XRT框架下每个后端引擎都有一个与之相对应的executable（比如XLA的XlaExecutable和TensorRT的TrtExecutable），和将function编译成对应executable的compiler（比如XLA的XlaGraphCompiler和TensorRT的TrtGraphCompiler），因此添加一个新的后端引擎，通常只需要添加一个对应的executable和compiler。下面以添加一个自定义的后端引擎Test为例，详细介绍在XRT框架下支持新的后端引擎的具体过程。\n\n首先在xrt/types.proto文件中XrtEngine下增加一个Test引擎字段。\n\n```c++\nenum XrtEngine {\n  DEFAULT = 1;\n  XLA = 2;\n  TENSORRT = 3;\n  TVM = 4;\n  TEST = 5;  // For Test engine\n}\n```\n\n如果Test引擎针对的硬件不在XrtDevice中，则需要在XrtDevice中增加对应的设备字段。假设我们自定义的Test引擎只支持GPU_CUDA，因此这里就不需要修改XrtDevice了。\n\n接下来，与XLA和TensorRT一样，我们在xrt目录下创建一个test目录，其余所有与Test引擎相关的代码都将放在该目录下。\n\n## Test Executable\n\n在增加任何一个后端引擎之前，我们都需要仔细考虑该后端引擎所需的最小执行环境，一个最简单的执行环境包括输入输出、中间结果以及执行具体计算逻辑的硬件代码，这个代码可以是通过codegen自动生成的，也可以是手工实现的。\n\n接下来我们给自定义的Test引擎增加一个对应的TestExecutable。在xrt/test目录下，我们创建文件test_executable.h和test_executable.cpp。\n\ntest_executable.h中定义TestExecutable，TestExecutable必须继承自Executable，并实现Run接口。为了尽可能简单，TestExecutable只包含输出outputs、中间结果tmp_buffers和编排好的函数调用列表func_codes，以及每个函数的输入输出参数对应的buffer序号func_args_。\n\n```c++\n#ifndef ONEFLOW_XRT_TEST_TEST_EXECUTABLE_H_\n\n#include \"oneflow/xrt/executable.h\"\n#include \"oneflow/xrt/parameter.h\"\n\n#include <vector>\n#include <functional>\n\nnamespace oneflow {\nnamespace xrt {\n\ntypedef std::function<void(const std::vector<Parameter> &,\n                           const std::vector<Parameter> &)> FuncCode;\n\nstruct FuncArgumentIndices {\n  std::vector<int> inputs;\n  std::vector<int> outputs;\n};\n\nclass TestExecutable : public Executable {\n public:\n  TestExecutable(const std::string &name, const int num_inputs,\n                 const std::vector<Parameter> &outputs,\n                 const std::vector<Parameter> &temp_buffers,\n                 const std::vector<FuncCode> &func_codes,\n                 const std::vector<FuncArgumentIndices> &func_args);\n\n  bool Run(const std::vector<Parameter> &inputs,\n           const ExecutableRunOptions &run_options,\n           bool block_until_done = true) override;\n\n private:\n  int num_inputs_;\n  std::vector<Parameter> outputs_;\n  std::vector<Parameter> temp_buffers_;\n  std::vector<FuncCode> func_codes_;\n  std::vector<FuncArgumentIndices> func_args_;\n};\n\n}  // namespace xrt\n}  // namespace oneflow\n\n#endif  // ONEFLOW_XRT_TEST_TEST_EXECUTABLE_H_\n```\n\n在test_executable.cpp中实现Run方法，这里我们只是简单的顺序执行编排好的函数func_codes。\n\n```c++\n#include \"oneflow/xrt/test/test_executable.h\"\n\nnamespace oneflow {\nnamespace xrt {\n\nTestExecutable::TestExecutable(const std::string &name, const int num_inputs,\n                               const std::vector<Parameter> &outputs,\n                               const std::vector<Parameter> &temp_buffers,\n                               const std::vector<FuncCode> &func_codes,\n                               const std::vector<FuncArgumentIndices> &func_args)\n    : Executable(name, XrtEngine::TEST),\n      num_inputs_(num_inputs),\n      outputs_(outputs),\n      temp_buffers_(temp_buffers),\n      func_codes_(func_codes),\n      func_args_(func_args) {}\n\nbool TestExecutable::Run(const std::vector<Parameter> &inputs,\n                         const ExecutableRunOptions &run_options,\n                         bool block_until_done) {\n  auto PullArgs = [&](const std::vector<int> &indices) {\n    std::vector<Parameter> args;\n    for (int idx : indices) {\n      if (idx < num_inputs_) {\n        args.push_back(inputs[idx]);\n      } else if (idx < num_inputs_ + outputs_.size()) {\n        args.push_back(outputs_[idx - num_inputs_]);\n      } else {\n        idx -= (num_inputs_ + outputs_.size());\n        CHECK_GE(idx, 0);\n        CHECK_LT(idx, temp_buffers_.size());\n        args.push_back(temp_buffers_[idx]);\n      }\n    }\n    return std::move(args);\n  };\n\n  CHECK_EQ(inputs.size(), num_inputs_);\n\n  for (int i = 0; i < func_codes_.size(); ++i) {\n    auto in_args = PullArgs(func_args_[i].inputs);\n    auto out_args = PullArgs(func_args_[i].outputs);\n    func_codes_[i](in_args, out_args);\n  }\n\n  // Synchronize stream if block_until_done.\n  if (block_until_done) {\n    // TODO(hjchen2)\n  }\n\n  // All return params are the results of the executable.\n  this->results_ = run_options.return_params;\n  return true /*running status*/;\n}\n\n}  // namespace xrt\n}  // namespace oneflow\n```\n\n目前为止我们已经完成了一个最简单的运行时executable，这个executable甚至有点类似其他框架中提供的最简单的图执行器（graph executor）。接下来我们要介绍如何将一个XRT的子图编译成上面的TestExecutable。\n\n## Test Compiler\n\n每个后端引擎都对应一个compiler，当我们希望使用某个后端引擎来执行一个XRT子图时，就需要有一个对应的compiler将该子图编译成后端引擎对应的executable。Compiler通常都非常注重编译产物的执行性能，而性能以外的关切点也导致了不同的技术路线，比如对算法通用性、跨平台有高度关切的TVM和XLA采用了LLVM传统编译器的路线，而对于过分看重性能但硬件平台单一的TensorRT更多的则是采用手工优化和tuning相结合的策略。不过这两种技术路线并不是完全对立的，也是在不断地相互借鉴和融合。\n\n在XRT中，所有这些技术方案都是可以被兼容的，你可以根据实际情况自由切换，你也可以把XRT当成实验场所，实现一个自定义的compiler，并在同一套框架下对比不同compiler、不同技术方案的优劣。\n\n回到本文的主题，我们现在需要实现一个TestExecutable对应的compiler，我们也把该compiler叫做TestGraphCompiler。\n\n首先在xrt/test目录下新建两个文件test_graph_compiler.h和test_graph_compiler.cpp。在test_graph_compiler.h文件中定义类TestGraphCompiler，TestGraphCompiler必须继承自类GraphCompiler::Impl，并实现对应的Compile接口。\n\n```c++\nclass TestGraphCompiler : public GraphCompiler::Impl {\n public:\n  explicit TestGraphCompiler(const std::string &name)\n      : GraphCompiler::Impl(name) {}\n\n  virtual ~TestGraphCompiler() = default;\n\n  std::shared_ptr<Executable> Compile(\n      const XrtGraph *graph,\n      const std::vector<Parameter> &entry_params,\n      const std::vector<Parameter> &return_params,\n      const std::vector<InputOutputAlias> &aliases) override;\n};\n```\n\n在test_graph_compiler.cpp中实现Compile接口，并注册一个新的graph compiler。在动手实现该接口之前，有必要先解释一下该接口的参数列表，graph表示的是function子图，entry_params表示子图的输入，return_params表示子图的输出，aliases通常在包含模型更新操作时会用到，表明输出和输入是一对别名关系。被alias的输入将生命期延长到了整个子图，并且与对应的输出共享内存，实际上也就间接实现了in-place计算的目的。\n\n我们按拓扑顺序遍历子图中的每个节点（或op），依次将节点编译成具体的执行代码，并在合适的位置插入临时buffer。为了方便处理不同类型的op，我们在下面的代码中引入了TestOpContext和TestOpKernel的概念。\n\n```c++\n// Register a new graph compiler for TEST engine.\nREGISTER_GRAPH_COMPILER(XrtEngine::TEST, TestGraphCompiler);\n\n// Realize Compile interface.\nstd::shared_ptr<Executable> TestGraphCompiler::Compile(\n    const XrtGraph *graph,\n    const std::vector<Parameter> &entry_params,\n    const std::vector<Parameter> &return_params,\n    const std::vector<InputOutputAlias> &aliases) {\n  std::vector<Parameter> temp_buffers;\n  std::vector<FuncCode> func_codes;\n  std::vector<FuncArgumentIndices> func_args;\n\n  std::unordered_map<std::string, int> indices;\n  std::unordered_map<std::string, Parameter> all_params;\n  for (auto param : entry_params) {\n    indices.emplace(param.name(), indices.size());\n    all_params[param.name()] = param;\n  }\n  for (auto param : return_params) {\n    indices.emplace(param.name(), indices.size());\n    all_params[param.name()] = param;\n  }\n\n  algorithm::TopologyVisit(*graph, [&](const XrtNode *node) {\n    if (node->type() == \"Argument\") {\n      // Argument node is not computation node, so skip it.\n      return;\n    }\n\n    TestOpContext op_context(node, all_params);\n    auto op_kernel = BuildTestOpKernel(node->type());\n    op_kernel->Compile(&op_context);\n\n    func_codes.push_back(op_context.func_code_);\n\n    const auto &buffers = op_context.tmp_buffers_;\n    for (auto it = buffers.begin(); it != buffers.end(); ++it) {\n      all_params[it->first] = it->second;\n      temp_buffers.push_back(it->second);\n      indices.emplace(it->first, indices.size());\n    }\n\n    // Finalize argument indices for each function.\n    FuncArgumentIndices arg_indices;\n    for (const auto &arg : op_context.input_args_) {\n      arg_indices.inputs.push_back(indices.at(arg));\n    }\n    for (const auto &arg : op_context.output_args_) {\n      arg_indices.outputs.push_back(indices.at(arg));\n    }\n    func_args.push_back(std::move(arg_indices));\n  });\n\n  return std::make_shared<TestExecutable>(this->name_, entry_params.size(),\n                                          return_params, temp_buffers,\n                                          func_codes, func_args);\n}\n```\n\nTestOpContext临时存储编译需要的元信息和编译结果，为TestOpKernel提供必要的接口，TestOpKernel则根据op类型完成单个op的编译过程。上述代码中我们实现了一个将XRT子图编译成TestExecutable的最简单的graph compiler，下面我们将以ReLU op为例，介绍TestOpContext和TestOpKernel是如何对op进行编译的。\n\n## Test Kernels\n\n我们回过头再仔细研究一下TestGraphCompiler的Compile实现，TestOpContext接受两个输入，node和当前所有已经创建过的parameters，经过OpKernel编译后输出函数代码（func_code\\_）、中间buffer（tmp_buffers\\_），以及函数代码输入和输出对应的parameter names。因此在这个例子中，TestOpContext被设计成如下形式：\n\n```c++\nclass TestOpContext {\n public:\n  TestOpContext(const XrtNode *node,\n                const std::unordered_map<std::string, Parameter> &all_params)\n      : node_(node), all_params_(all_params) {}\n\n public:\n  const XrtNode *node_;\n  const std::unordered_map<std::string, Parameter> &all_params_;\n\n  std::function<void(const std::vector<Parameter>&,\n                     const std::vector<Parameter>&)> func_code_;\n  std::vector<std::string> input_args_;\n  std::vector<std::string> output_args_;\n  std::unordered_map<std::string, Parameter> tmp_buffers_;\n};\n```\n\n对于TestOpKernel，为了处理不同类型的op，我们采用工厂注册模式，并且这种模式还有另一个用处，就是在XRT划分子图时可以用来判断该引擎是否支持某个类型的op。XRT已经将kernel注册接口封装成了一个辅助类OpKernelRegistrar，但同时也要求TestOpKernel必须继承基类OpKernel。\n\n```c++\nclass TestOpKernel : public OpKernel<TestOpContext> {\n public:\n  virtual void Compile(TestOpContext *ctx) = 0;\n};\n```\n\n使用OpKernelRegistrar定义一个用来注册TestOpKernel的宏。\n\n```c++\n#define REGISTER_TEST_OP_KERNEL(OpName, KernelType)                 \\\n  static auto _test_op_kernel_##OpName##_ __attribute__((unused)) = \\\n      OpKernelRegistrar<TestOpContext>(#OpName)                     \\\n          .SetField(XrtEngine::TEST)                                \\\n          .SetDevice({XrtDevice::GPU_CUDA})                         \\\n          .SetFactory([]() -> OpKernel<TestOpContext> * {           \\\n                        return new KernelType;                      \\\n                      })\n```\n\n最后我们实现一个Relu的OpKernel，填充TestOpContext的func_code\\_、tmp_buffers\\_以及输入输出arguments。\n\n```c++\nvoid ComputeRelu(const Parameter &input, const Parameter &output) {\n  //TODO(hjchen2)\n}\n\nclass TestReluOpKernel : public TestOpKernel {\n public:\n  void Compile(TestOpContext *ctx) override {\n    ctx->func_code_ = [](const std::vector<Parameter> &inputs,\n                         const std::vector<Parameter> &outputs) {\n      CHECK_EQ(inputs.size(), 1);\n      CHECK_EQ(outputs.size(), 1);\n      ComputeRelu(inputs[0], outputs[0]);\n    };\n\n    for (const XrtEdge *edge : ctx->node_->in_edges()) {\n      const auto &name = edge->argument().name();\n      CHECK_GT(ctx->all_params_.count(name), 0);\n      // TODO(hjchen2): Filter duplicate input.\n      ctx->input_args_.push_back(name);\n    }\n\n    for (const XrtEdge *edge : ctx->node_->out_edges()) {\n      const auto &name = edge->argument().name();\n      // TODO(hjchen2): Filter duplicate output.\n      ctx->output_args_.push_back(name);\n      if (ctx->all_params_.count(name) == 0 &&\n          ctx->tmp_buffers_.count(name) == 0) {\n        auto param = CreateParameter(name /*argument name*/,\n                                     edge->argument().shape(),\n                                     edge->argument().data_type());\n        ctx->tmp_buffers_[name] = std::move(param);\n      }\n    }\n  }\n};\n```\n\n最后将TestReluOpKernel注册到Test引擎对应的OpKernel工厂下。\n\n```c++\nREGISTER_TEST_OP_KERNEL(Relu, TestReluOpKernel)\n    .EnableTrainPhase()\n    .Finalize();\n```\n\nEnableTrainPhase表示该op支持训练，OpKernelRegistrar也提供了其他一些接口，比如设置支持的device列表，mutable variables和是否是optimizer op（optimizer会影响子图划分）。\n\n## Python和C++ APIs\n\n引擎的开启或关闭可以通过Python接口和环境变量来设置，因此添加一个后端引擎时也需要在Python中添加相应的接口，在python/framework/function_util.py文件中增加如下代码，\n\n```python\n@oneflow_function_config('use_test')\ndef set_use_test(func_desc, value = True):\n    func_desc.job_config_proto.xrt_config.use_test = value\n```\n\n并且在xrt/api.cpp中增加一个gflags环境变量，并在该文件中修改相关接口。\n\n- 增加一个gflags环境变量\n\n  ```c++\n  DEFINE_bool(use_test, EnvToBool(FLAGS_use_test, false), \"It's optional to use test.\");\n  ```\n\n- 修改InitXrtConfigurations、XrtCompilationEnabled和CreateDefaultXrtPassOptions接口，增加对Test引擎的支持。\n\n## 完整代码\nhttps://github.com/Oneflow-Inc/oneflow/commit/50a74bc110f3aacfa853456d9b695f2ba80e9e0a\n","slug":"如何在XRT框架下添加自定义的后端引擎","published":1,"updated":"2023-01-03T14:05:58.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcgb13uo0006j6eqfpxxew8z","content":"<p>XRT为不同的后端引擎提供了统一的上层功能和接口抽象，这些功能和接口包括：</p>\n<ul>\n<li>统一的DAG计算图表示</li>\n<li>统一的子图表达、切分和折叠过程</li>\n<li>统一的JIT子图编译接口和缓存机制</li>\n<li>统一的Executable Launch接口</li>\n</ul>\n<p>得益于上层统一的抽象和模块化的设计，后端引擎只需要处理一些差异化的接口，并且这些差异化通常只体现在子图的编译和executable\nlaunch接口的具体实现上。</p>\n<span id=\"more\"></span>\n<p>我们把XRT的每个子图都看成是一个function，function包含输入和输出参数，以及对应的函数体（DAG表示的计算图），比如下面表示的是只包含一个relu节点的XRT子图。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function &#123;</span><br><span class=\"line\">  argument &#123;</span><br><span class=\"line\">    name: &quot;_input_argument_0&quot;</span><br><span class=\"line\">    value: &quot;conv1/out&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  argument &#123;</span><br><span class=\"line\">    name: &quot;_output_argument_0&quot;</span><br><span class=\"line\">    value: &quot;relu1/out&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  node &#123;</span><br><span class=\"line\">    name: &quot;relu1&quot;</span><br><span class=\"line\">    device_type: kGPU</span><br><span class=\"line\">    relu_conf &#123;</span><br><span class=\"line\">      in: &quot;conv1/out&quot;</span><br><span class=\"line\">      out: &quot;out&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在runtime阶段function首先需要被编译成executable，执行function实际上就是feed对应的输入参数去launch这个编译好的executable，同时得到执行的结果，即function的返回值。</p>\n<p>在XRT框架下每个后端引擎都有一个与之相对应的executable（比如XLA的XlaExecutable和TensorRT的TrtExecutable），和将function编译成对应executable的compiler（比如XLA的XlaGraphCompiler和TensorRT的TrtGraphCompiler），因此添加一个新的后端引擎，通常只需要添加一个对应的executable和compiler。下面以添加一个自定义的后端引擎Test为例，详细介绍在XRT框架下支持新的后端引擎的具体过程。</p>\n<p>首先在xrt/types.proto文件中XrtEngine下增加一个Test引擎字段。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">XrtEngine</span> &#123;</span><br><span class=\"line\">  DEFAULT = <span class=\"number\">1</span>;</span><br><span class=\"line\">  XLA = <span class=\"number\">2</span>;</span><br><span class=\"line\">  TENSORRT = <span class=\"number\">3</span>;</span><br><span class=\"line\">  TVM = <span class=\"number\">4</span>;</span><br><span class=\"line\">  TEST = <span class=\"number\">5</span>;  <span class=\"comment\">// For Test engine</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果Test引擎针对的硬件不在XrtDevice中，则需要在XrtDevice中增加对应的设备字段。假设我们自定义的Test引擎只支持GPU_CUDA，因此这里就不需要修改XrtDevice了。</p>\n<p>接下来，与XLA和TensorRT一样，我们在xrt目录下创建一个test目录，其余所有与Test引擎相关的代码都将放在该目录下。</p>\n<h2 id=\"test-executable\">Test Executable</h2>\n<p>在增加任何一个后端引擎之前，我们都需要仔细考虑该后端引擎所需的最小执行环境，一个最简单的执行环境包括输入输出、中间结果以及执行具体计算逻辑的硬件代码，这个代码可以是通过codegen自动生成的，也可以是手工实现的。</p>\n<p>接下来我们给自定义的Test引擎增加一个对应的TestExecutable。在xrt/test目录下，我们创建文件test_executable.h和test_executable.cpp。</p>\n<p>test_executable.h中定义TestExecutable，TestExecutable必须继承自Executable，并实现Run接口。为了尽可能简单，TestExecutable只包含输出outputs、中间结果tmp_buffers和编排好的函数调用列表func_codes，以及每个函数的输入输出参数对应的buffer序号func_args_。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> ONEFLOW_XRT_TEST_TEST_EXECUTABLE_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;oneflow/xrt/executable.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;oneflow/xrt/parameter.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> oneflow &#123;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> xrt &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(<span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;,</span><br><span class=\"line\">                           <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;)&gt; FuncCode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">FuncArgumentIndices</span> &#123;</span><br><span class=\"line\">  std::vector&lt;<span class=\"type\">int</span>&gt; inputs;</span><br><span class=\"line\">  std::vector&lt;<span class=\"type\">int</span>&gt; outputs;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestExecutable</span> : <span class=\"keyword\">public</span> Executable &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">TestExecutable</span>(<span class=\"type\">const</span> std::string &amp;name, <span class=\"type\">const</span> <span class=\"type\">int</span> num_inputs,</span><br><span class=\"line\">                 <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;outputs,</span><br><span class=\"line\">                 <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;temp_buffers,</span><br><span class=\"line\">                 <span class=\"type\">const</span> std::vector&lt;FuncCode&gt; &amp;func_codes,</span><br><span class=\"line\">                 <span class=\"type\">const</span> std::vector&lt;FuncArgumentIndices&gt; &amp;func_args);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Run</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;inputs,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">const</span> ExecutableRunOptions &amp;run_options,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">bool</span> block_until_done = <span class=\"literal\">true</span>)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> num_inputs_;</span><br><span class=\"line\">  std::vector&lt;Parameter&gt; outputs_;</span><br><span class=\"line\">  std::vector&lt;Parameter&gt; temp_buffers_;</span><br><span class=\"line\">  std::vector&lt;FuncCode&gt; func_codes_;</span><br><span class=\"line\">  std::vector&lt;FuncArgumentIndices&gt; func_args_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace xrt</span></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace oneflow</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span>  <span class=\"comment\">// ONEFLOW_XRT_TEST_TEST_EXECUTABLE_H_</span></span></span><br></pre></td></tr></table></figure>\n<p>在test_executable.cpp中实现Run方法，这里我们只是简单的顺序执行编排好的函数func_codes。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;oneflow/xrt/test/test_executable.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> oneflow &#123;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> xrt &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">TestExecutable::<span class=\"built_in\">TestExecutable</span>(<span class=\"type\">const</span> std::string &amp;name, <span class=\"type\">const</span> <span class=\"type\">int</span> num_inputs,</span><br><span class=\"line\">                               <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;outputs,</span><br><span class=\"line\">                               <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;temp_buffers,</span><br><span class=\"line\">                               <span class=\"type\">const</span> std::vector&lt;FuncCode&gt; &amp;func_codes,</span><br><span class=\"line\">                               <span class=\"type\">const</span> std::vector&lt;FuncArgumentIndices&gt; &amp;func_args)</span><br><span class=\"line\">    : <span class=\"built_in\">Executable</span>(name, XrtEngine::TEST),</span><br><span class=\"line\">      <span class=\"built_in\">num_inputs_</span>(num_inputs),</span><br><span class=\"line\">      <span class=\"built_in\">outputs_</span>(outputs),</span><br><span class=\"line\">      <span class=\"built_in\">temp_buffers_</span>(temp_buffers),</span><br><span class=\"line\">      <span class=\"built_in\">func_codes_</span>(func_codes),</span><br><span class=\"line\">      <span class=\"built_in\">func_args_</span>(func_args) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TestExecutable::Run</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;inputs,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                         <span class=\"type\">const</span> ExecutableRunOptions &amp;run_options,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                         <span class=\"type\">bool</span> block_until_done)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> PullArgs = [&amp;](<span class=\"type\">const</span> std::vector&lt;<span class=\"type\">int</span>&gt; &amp;indices) &#123;</span><br><span class=\"line\">    std::vector&lt;Parameter&gt; args;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> idx : indices) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (idx &lt; num_inputs_) &#123;</span><br><span class=\"line\">        args.<span class=\"built_in\">push_back</span>(inputs[idx]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (idx &lt; num_inputs_ + outputs_.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        args.<span class=\"built_in\">push_back</span>(outputs_[idx - num_inputs_]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        idx -= (num_inputs_ + outputs_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"built_in\">CHECK_GE</span>(idx, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">CHECK_LT</span>(idx, temp_buffers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        args.<span class=\"built_in\">push_back</span>(temp_buffers_[idx]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">move</span>(args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">CHECK_EQ</span>(inputs.<span class=\"built_in\">size</span>(), num_inputs_);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; func_codes_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> in_args = <span class=\"built_in\">PullArgs</span>(func_args_[i].inputs);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> out_args = <span class=\"built_in\">PullArgs</span>(func_args_[i].outputs);</span><br><span class=\"line\">    func_codes_[i](in_args, out_args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Synchronize stream if block_until_done.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (block_until_done) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO(hjchen2)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// All return params are the results of the executable.</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;results_ = run_options.return_params;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"comment\">/*running status*/</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace xrt</span></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace oneflow</span></span><br></pre></td></tr></table></figure>\n<p>目前为止我们已经完成了一个最简单的运行时executable，这个executable甚至有点类似其他框架中提供的最简单的图执行器（graph\nexecutor）。接下来我们要介绍如何将一个XRT的子图编译成上面的TestExecutable。</p>\n<h2 id=\"test-compiler\">Test Compiler</h2>\n<p>每个后端引擎都对应一个compiler，当我们希望使用某个后端引擎来执行一个XRT子图时，就需要有一个对应的compiler将该子图编译成后端引擎对应的executable。Compiler通常都非常注重编译产物的执行性能，而性能以外的关切点也导致了不同的技术路线，比如对算法通用性、跨平台有高度关切的TVM和XLA采用了LLVM传统编译器的路线，而对于过分看重性能但硬件平台单一的TensorRT更多的则是采用手工优化和tuning相结合的策略。不过这两种技术路线并不是完全对立的，也是在不断地相互借鉴和融合。</p>\n<p>在XRT中，所有这些技术方案都是可以被兼容的，你可以根据实际情况自由切换，你也可以把XRT当成实验场所，实现一个自定义的compiler，并在同一套框架下对比不同compiler、不同技术方案的优劣。</p>\n<p>回到本文的主题，我们现在需要实现一个TestExecutable对应的compiler，我们也把该compiler叫做TestGraphCompiler。</p>\n<p>首先在xrt/test目录下新建两个文件test_graph_compiler.h和test_graph_compiler.cpp。在test_graph_compiler.h文件中定义类TestGraphCompiler，TestGraphCompiler必须继承自类GraphCompiler::Impl，并实现对应的Compile接口。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestGraphCompiler</span> : <span class=\"keyword\">public</span> GraphCompiler::Impl &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">TestGraphCompiler</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;name)</span></span></span><br><span class=\"line\"><span class=\"function\">      : GraphCompiler::Impl(name) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">TestGraphCompiler</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">std::shared_ptr&lt;Executable&gt; <span class=\"title\">Compile</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"type\">const</span> XrtGraph *graph,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;entry_params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;return_params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"type\">const</span> std::vector&lt;InputOutputAlias&gt; &amp;aliases)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在test_graph_compiler.cpp中实现Compile接口，并注册一个新的graph\ncompiler。在动手实现该接口之前，有必要先解释一下该接口的参数列表，graph表示的是function子图，entry_params表示子图的输入，return_params表示子图的输出，aliases通常在包含模型更新操作时会用到，表明输出和输入是一对别名关系。被alias的输入将生命期延长到了整个子图，并且与对应的输出共享内存，实际上也就间接实现了in-place计算的目的。</p>\n<p>我们按拓扑顺序遍历子图中的每个节点（或op），依次将节点编译成具体的执行代码，并在合适的位置插入临时buffer。为了方便处理不同类型的op，我们在下面的代码中引入了TestOpContext和TestOpKernel的概念。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Register a new graph compiler for TEST engine.</span></span><br><span class=\"line\"><span class=\"built_in\">REGISTER_GRAPH_COMPILER</span>(XrtEngine::TEST, TestGraphCompiler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Realize Compile interface.</span></span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;Executable&gt; <span class=\"title\">TestGraphCompiler::Compile</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> XrtGraph *graph,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;entry_params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;return_params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> std::vector&lt;InputOutputAlias&gt; &amp;aliases)</span> </span>&#123;</span><br><span class=\"line\">  std::vector&lt;Parameter&gt; temp_buffers;</span><br><span class=\"line\">  std::vector&lt;FuncCode&gt; func_codes;</span><br><span class=\"line\">  std::vector&lt;FuncArgumentIndices&gt; func_args;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::unordered_map&lt;std::string, <span class=\"type\">int</span>&gt; indices;</span><br><span class=\"line\">  std::unordered_map&lt;std::string, Parameter&gt; all_params;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> param : entry_params) &#123;</span><br><span class=\"line\">    indices.<span class=\"built_in\">emplace</span>(param.<span class=\"built_in\">name</span>(), indices.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    all_params[param.<span class=\"built_in\">name</span>()] = param;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> param : return_params) &#123;</span><br><span class=\"line\">    indices.<span class=\"built_in\">emplace</span>(param.<span class=\"built_in\">name</span>(), indices.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    all_params[param.<span class=\"built_in\">name</span>()] = param;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  algorithm::<span class=\"built_in\">TopologyVisit</span>(*graph, [&amp;](<span class=\"type\">const</span> XrtNode *node) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;<span class=\"built_in\">type</span>() == <span class=\"string\">&quot;Argument&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Argument node is not computation node, so skip it.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    TestOpContext <span class=\"built_in\">op_context</span>(node, all_params);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> op_kernel = <span class=\"built_in\">BuildTestOpKernel</span>(node-&gt;<span class=\"built_in\">type</span>());</span><br><span class=\"line\">    op_kernel-&gt;<span class=\"built_in\">Compile</span>(&amp;op_context);</span><br><span class=\"line\"></span><br><span class=\"line\">    func_codes.<span class=\"built_in\">push_back</span>(op_context.func_code_);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;buffers = op_context.tmp_buffers_;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = buffers.<span class=\"built_in\">begin</span>(); it != buffers.<span class=\"built_in\">end</span>(); ++it) &#123;</span><br><span class=\"line\">      all_params[it-&gt;first] = it-&gt;second;</span><br><span class=\"line\">      temp_buffers.<span class=\"built_in\">push_back</span>(it-&gt;second);</span><br><span class=\"line\">      indices.<span class=\"built_in\">emplace</span>(it-&gt;first, indices.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Finalize argument indices for each function.</span></span><br><span class=\"line\">    FuncArgumentIndices arg_indices;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;arg : op_context.input_args_) &#123;</span><br><span class=\"line\">      arg_indices.inputs.<span class=\"built_in\">push_back</span>(indices.<span class=\"built_in\">at</span>(arg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;arg : op_context.output_args_) &#123;</span><br><span class=\"line\">      arg_indices.outputs.<span class=\"built_in\">push_back</span>(indices.<span class=\"built_in\">at</span>(arg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    func_args.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(arg_indices));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;TestExecutable&gt;(<span class=\"keyword\">this</span>-&gt;name_, entry_params.<span class=\"built_in\">size</span>(),</span><br><span class=\"line\">                                          return_params, temp_buffers,</span><br><span class=\"line\">                                          func_codes, func_args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TestOpContext临时存储编译需要的元信息和编译结果，为TestOpKernel提供必要的接口，TestOpKernel则根据op类型完成单个op的编译过程。上述代码中我们实现了一个将XRT子图编译成TestExecutable的最简单的graph\ncompiler，下面我们将以ReLU\nop为例，介绍TestOpContext和TestOpKernel是如何对op进行编译的。</p>\n<h2 id=\"test-kernels\">Test Kernels</h2>\n<p>我们回过头再仔细研究一下TestGraphCompiler的Compile实现，TestOpContext接受两个输入，node和当前所有已经创建过的parameters，经过OpKernel编译后输出函数代码（func_code_）、中间buffer（tmp_buffers_），以及函数代码输入和输出对应的parameter\nnames。因此在这个例子中，TestOpContext被设计成如下形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestOpContext</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">TestOpContext</span>(<span class=\"type\">const</span> XrtNode *node,</span><br><span class=\"line\">                <span class=\"type\">const</span> std::unordered_map&lt;std::string, Parameter&gt; &amp;all_params)</span><br><span class=\"line\">      : <span class=\"built_in\">node_</span>(node), <span class=\"built_in\">all_params_</span>(all_params) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">const</span> XrtNode *node_;</span><br><span class=\"line\">  <span class=\"type\">const</span> std::unordered_map&lt;std::string, Parameter&gt; &amp;all_params_;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::function&lt;<span class=\"type\">void</span>(<span class=\"type\">const</span> std::vector&lt;Parameter&gt;&amp;,</span><br><span class=\"line\">                     <span class=\"type\">const</span> std::vector&lt;Parameter&gt;&amp;)&gt; func_code_;</span><br><span class=\"line\">  std::vector&lt;std::string&gt; input_args_;</span><br><span class=\"line\">  std::vector&lt;std::string&gt; output_args_;</span><br><span class=\"line\">  std::unordered_map&lt;std::string, Parameter&gt; tmp_buffers_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对于TestOpKernel，为了处理不同类型的op，我们采用工厂注册模式，并且这种模式还有另一个用处，就是在XRT划分子图时可以用来判断该引擎是否支持某个类型的op。XRT已经将kernel注册接口封装成了一个辅助类OpKernelRegistrar，但同时也要求TestOpKernel必须继承基类OpKernel。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestOpKernel</span> : <span class=\"keyword\">public</span> OpKernel&lt;TestOpContext&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Compile</span><span class=\"params\">(TestOpContext *ctx)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用OpKernelRegistrar定义一个用来注册TestOpKernel的宏。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REGISTER_TEST_OP_KERNEL(OpName, KernelType)                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  static auto _test_op_kernel_##OpName##_ __attribute__((unused)) = \\</span></span><br><span class=\"line\"><span class=\"meta\">      OpKernelRegistrar<span class=\"string\">&lt;TestOpContext&gt;</span>(#OpName)                     \\</span></span><br><span class=\"line\"><span class=\"meta\">          .SetField(XrtEngine::TEST)                                \\</span></span><br><span class=\"line\"><span class=\"meta\">          .SetDevice(&#123;XrtDevice::GPU_CUDA&#125;)                         \\</span></span><br><span class=\"line\"><span class=\"meta\">          .SetFactory([]() -&gt; OpKernel<span class=\"string\">&lt;TestOpContext&gt;</span> * &#123;           \\</span></span><br><span class=\"line\"><span class=\"meta\">                        return new KernelType;                      \\</span></span><br><span class=\"line\"><span class=\"meta\">                      &#125;)</span></span><br></pre></td></tr></table></figure>\n<p>最后我们实现一个Relu的OpKernel，填充TestOpContext的func_code_、tmp_buffers_以及输入输出arguments。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ComputeRelu</span><span class=\"params\">(<span class=\"type\">const</span> Parameter &amp;input, <span class=\"type\">const</span> Parameter &amp;output)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//TODO(hjchen2)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestReluOpKernel</span> : <span class=\"keyword\">public</span> TestOpKernel &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Compile</span><span class=\"params\">(TestOpContext *ctx)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    ctx-&gt;func_code_ = [](<span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;inputs,</span><br><span class=\"line\">                         <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;outputs) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">CHECK_EQ</span>(inputs.<span class=\"built_in\">size</span>(), <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"built_in\">CHECK_EQ</span>(outputs.<span class=\"built_in\">size</span>(), <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"built_in\">ComputeRelu</span>(inputs[<span class=\"number\">0</span>], outputs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> XrtEdge *edge : ctx-&gt;node_-&gt;<span class=\"built_in\">in_edges</span>()) &#123;</span><br><span class=\"line\">      <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;name = edge-&gt;<span class=\"built_in\">argument</span>().<span class=\"built_in\">name</span>();</span><br><span class=\"line\">      <span class=\"built_in\">CHECK_GT</span>(ctx-&gt;all_params_.<span class=\"built_in\">count</span>(name), <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"comment\">// TODO(hjchen2): Filter duplicate input.</span></span><br><span class=\"line\">      ctx-&gt;input_args_.<span class=\"built_in\">push_back</span>(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> XrtEdge *edge : ctx-&gt;node_-&gt;<span class=\"built_in\">out_edges</span>()) &#123;</span><br><span class=\"line\">      <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;name = edge-&gt;<span class=\"built_in\">argument</span>().<span class=\"built_in\">name</span>();</span><br><span class=\"line\">      <span class=\"comment\">// TODO(hjchen2): Filter duplicate output.</span></span><br><span class=\"line\">      ctx-&gt;output_args_.<span class=\"built_in\">push_back</span>(name);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ctx-&gt;all_params_.<span class=\"built_in\">count</span>(name) == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">          ctx-&gt;tmp_buffers_.<span class=\"built_in\">count</span>(name) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> param = <span class=\"built_in\">CreateParameter</span>(name <span class=\"comment\">/*argument name*/</span>,</span><br><span class=\"line\">                                     edge-&gt;<span class=\"built_in\">argument</span>().<span class=\"built_in\">shape</span>(),</span><br><span class=\"line\">                                     edge-&gt;<span class=\"built_in\">argument</span>().<span class=\"built_in\">data_type</span>());</span><br><span class=\"line\">        ctx-&gt;tmp_buffers_[name] = std::<span class=\"built_in\">move</span>(param);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最后将TestReluOpKernel注册到Test引擎对应的OpKernel工厂下。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">REGISTER_TEST_OP_KERNEL</span>(Relu, TestReluOpKernel)</span><br><span class=\"line\">    .<span class=\"built_in\">EnableTrainPhase</span>()</span><br><span class=\"line\">    .<span class=\"built_in\">Finalize</span>();</span><br></pre></td></tr></table></figure>\n<p>EnableTrainPhase表示该op支持训练，OpKernelRegistrar也提供了其他一些接口，比如设置支持的device列表，mutable\nvariables和是否是optimizer op（optimizer会影响子图划分）。</p>\n<h2 id=\"python和c-apis\">Python和C++ APIs</h2>\n<p>引擎的开启或关闭可以通过Python接口和环境变量来设置，因此添加一个后端引擎时也需要在Python中添加相应的接口，在python/framework/function_util.py文件中增加如下代码，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@oneflow_function_config(<span class=\"params\"><span class=\"string\">&#x27;use_test&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">set_use_test</span>(<span class=\"params\">func_desc, value = <span class=\"literal\">True</span></span>):</span><br><span class=\"line\">    func_desc.job_config_proto.xrt_config.use_test = value</span><br></pre></td></tr></table></figure>\n<p>并且在xrt/api.cpp中增加一个gflags环境变量，并在该文件中修改相关接口。</p>\n<ul>\n<li><p>增加一个gflags环境变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">DEFINE_bool</span>(use_test, <span class=\"built_in\">EnvToBool</span>(FLAGS_use_test, <span class=\"literal\">false</span>), <span class=\"string\">&quot;It&#x27;s optional to use test.&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p>修改InitXrtConfigurations、XrtCompilationEnabled和CreateDefaultXrtPassOptions接口，增加对Test引擎的支持。</p></li>\n</ul>\n<h2 id=\"完整代码\">完整代码</h2>\n<p>https://github.com/Oneflow-Inc/oneflow/commit/50a74bc110f3aacfa853456d9b695f2ba80e9e0a</p>\n","site":{"data":{}},"excerpt":"<p>XRT为不同的后端引擎提供了统一的上层功能和接口抽象，这些功能和接口包括：</p>\n<ul>\n<li>统一的DAG计算图表示</li>\n<li>统一的子图表达、切分和折叠过程</li>\n<li>统一的JIT子图编译接口和缓存机制</li>\n<li>统一的Executable Launch接口</li>\n</ul>\n<p>得益于上层统一的抽象和模块化的设计，后端引擎只需要处理一些差异化的接口，并且这些差异化通常只体现在子图的编译和executable\nlaunch接口的具体实现上。</p>","more":"<p>我们把XRT的每个子图都看成是一个function，function包含输入和输出参数，以及对应的函数体（DAG表示的计算图），比如下面表示的是只包含一个relu节点的XRT子图。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function &#123;</span><br><span class=\"line\">  argument &#123;</span><br><span class=\"line\">    name: &quot;_input_argument_0&quot;</span><br><span class=\"line\">    value: &quot;conv1/out&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  argument &#123;</span><br><span class=\"line\">    name: &quot;_output_argument_0&quot;</span><br><span class=\"line\">    value: &quot;relu1/out&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  node &#123;</span><br><span class=\"line\">    name: &quot;relu1&quot;</span><br><span class=\"line\">    device_type: kGPU</span><br><span class=\"line\">    relu_conf &#123;</span><br><span class=\"line\">      in: &quot;conv1/out&quot;</span><br><span class=\"line\">      out: &quot;out&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在runtime阶段function首先需要被编译成executable，执行function实际上就是feed对应的输入参数去launch这个编译好的executable，同时得到执行的结果，即function的返回值。</p>\n<p>在XRT框架下每个后端引擎都有一个与之相对应的executable（比如XLA的XlaExecutable和TensorRT的TrtExecutable），和将function编译成对应executable的compiler（比如XLA的XlaGraphCompiler和TensorRT的TrtGraphCompiler），因此添加一个新的后端引擎，通常只需要添加一个对应的executable和compiler。下面以添加一个自定义的后端引擎Test为例，详细介绍在XRT框架下支持新的后端引擎的具体过程。</p>\n<p>首先在xrt/types.proto文件中XrtEngine下增加一个Test引擎字段。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">XrtEngine</span> &#123;</span><br><span class=\"line\">  DEFAULT = <span class=\"number\">1</span>;</span><br><span class=\"line\">  XLA = <span class=\"number\">2</span>;</span><br><span class=\"line\">  TENSORRT = <span class=\"number\">3</span>;</span><br><span class=\"line\">  TVM = <span class=\"number\">4</span>;</span><br><span class=\"line\">  TEST = <span class=\"number\">5</span>;  <span class=\"comment\">// For Test engine</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果Test引擎针对的硬件不在XrtDevice中，则需要在XrtDevice中增加对应的设备字段。假设我们自定义的Test引擎只支持GPU_CUDA，因此这里就不需要修改XrtDevice了。</p>\n<p>接下来，与XLA和TensorRT一样，我们在xrt目录下创建一个test目录，其余所有与Test引擎相关的代码都将放在该目录下。</p>\n<h2 id=\"test-executable\">Test Executable</h2>\n<p>在增加任何一个后端引擎之前，我们都需要仔细考虑该后端引擎所需的最小执行环境，一个最简单的执行环境包括输入输出、中间结果以及执行具体计算逻辑的硬件代码，这个代码可以是通过codegen自动生成的，也可以是手工实现的。</p>\n<p>接下来我们给自定义的Test引擎增加一个对应的TestExecutable。在xrt/test目录下，我们创建文件test_executable.h和test_executable.cpp。</p>\n<p>test_executable.h中定义TestExecutable，TestExecutable必须继承自Executable，并实现Run接口。为了尽可能简单，TestExecutable只包含输出outputs、中间结果tmp_buffers和编排好的函数调用列表func_codes，以及每个函数的输入输出参数对应的buffer序号func_args_。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> ONEFLOW_XRT_TEST_TEST_EXECUTABLE_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;oneflow/xrt/executable.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;oneflow/xrt/parameter.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> oneflow &#123;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> xrt &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>(<span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;,</span><br><span class=\"line\">                           <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;)&gt; FuncCode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">FuncArgumentIndices</span> &#123;</span><br><span class=\"line\">  std::vector&lt;<span class=\"type\">int</span>&gt; inputs;</span><br><span class=\"line\">  std::vector&lt;<span class=\"type\">int</span>&gt; outputs;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestExecutable</span> : <span class=\"keyword\">public</span> Executable &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">TestExecutable</span>(<span class=\"type\">const</span> std::string &amp;name, <span class=\"type\">const</span> <span class=\"type\">int</span> num_inputs,</span><br><span class=\"line\">                 <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;outputs,</span><br><span class=\"line\">                 <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;temp_buffers,</span><br><span class=\"line\">                 <span class=\"type\">const</span> std::vector&lt;FuncCode&gt; &amp;func_codes,</span><br><span class=\"line\">                 <span class=\"type\">const</span> std::vector&lt;FuncArgumentIndices&gt; &amp;func_args);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Run</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;inputs,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">const</span> ExecutableRunOptions &amp;run_options,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"type\">bool</span> block_until_done = <span class=\"literal\">true</span>)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> num_inputs_;</span><br><span class=\"line\">  std::vector&lt;Parameter&gt; outputs_;</span><br><span class=\"line\">  std::vector&lt;Parameter&gt; temp_buffers_;</span><br><span class=\"line\">  std::vector&lt;FuncCode&gt; func_codes_;</span><br><span class=\"line\">  std::vector&lt;FuncArgumentIndices&gt; func_args_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace xrt</span></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace oneflow</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span>  <span class=\"comment\">// ONEFLOW_XRT_TEST_TEST_EXECUTABLE_H_</span></span></span><br></pre></td></tr></table></figure>\n<p>在test_executable.cpp中实现Run方法，这里我们只是简单的顺序执行编排好的函数func_codes。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;oneflow/xrt/test/test_executable.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> oneflow &#123;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> xrt &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">TestExecutable::<span class=\"built_in\">TestExecutable</span>(<span class=\"type\">const</span> std::string &amp;name, <span class=\"type\">const</span> <span class=\"type\">int</span> num_inputs,</span><br><span class=\"line\">                               <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;outputs,</span><br><span class=\"line\">                               <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;temp_buffers,</span><br><span class=\"line\">                               <span class=\"type\">const</span> std::vector&lt;FuncCode&gt; &amp;func_codes,</span><br><span class=\"line\">                               <span class=\"type\">const</span> std::vector&lt;FuncArgumentIndices&gt; &amp;func_args)</span><br><span class=\"line\">    : <span class=\"built_in\">Executable</span>(name, XrtEngine::TEST),</span><br><span class=\"line\">      <span class=\"built_in\">num_inputs_</span>(num_inputs),</span><br><span class=\"line\">      <span class=\"built_in\">outputs_</span>(outputs),</span><br><span class=\"line\">      <span class=\"built_in\">temp_buffers_</span>(temp_buffers),</span><br><span class=\"line\">      <span class=\"built_in\">func_codes_</span>(func_codes),</span><br><span class=\"line\">      <span class=\"built_in\">func_args_</span>(func_args) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TestExecutable::Run</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;inputs,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                         <span class=\"type\">const</span> ExecutableRunOptions &amp;run_options,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                         <span class=\"type\">bool</span> block_until_done)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> PullArgs = [&amp;](<span class=\"type\">const</span> std::vector&lt;<span class=\"type\">int</span>&gt; &amp;indices) &#123;</span><br><span class=\"line\">    std::vector&lt;Parameter&gt; args;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> idx : indices) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (idx &lt; num_inputs_) &#123;</span><br><span class=\"line\">        args.<span class=\"built_in\">push_back</span>(inputs[idx]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (idx &lt; num_inputs_ + outputs_.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        args.<span class=\"built_in\">push_back</span>(outputs_[idx - num_inputs_]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        idx -= (num_inputs_ + outputs_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"built_in\">CHECK_GE</span>(idx, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">CHECK_LT</span>(idx, temp_buffers_.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        args.<span class=\"built_in\">push_back</span>(temp_buffers_[idx]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">move</span>(args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">CHECK_EQ</span>(inputs.<span class=\"built_in\">size</span>(), num_inputs_);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; func_codes_.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> in_args = <span class=\"built_in\">PullArgs</span>(func_args_[i].inputs);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> out_args = <span class=\"built_in\">PullArgs</span>(func_args_[i].outputs);</span><br><span class=\"line\">    func_codes_[i](in_args, out_args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Synchronize stream if block_until_done.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (block_until_done) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO(hjchen2)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// All return params are the results of the executable.</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;results_ = run_options.return_params;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"comment\">/*running status*/</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace xrt</span></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace oneflow</span></span><br></pre></td></tr></table></figure>\n<p>目前为止我们已经完成了一个最简单的运行时executable，这个executable甚至有点类似其他框架中提供的最简单的图执行器（graph\nexecutor）。接下来我们要介绍如何将一个XRT的子图编译成上面的TestExecutable。</p>\n<h2 id=\"test-compiler\">Test Compiler</h2>\n<p>每个后端引擎都对应一个compiler，当我们希望使用某个后端引擎来执行一个XRT子图时，就需要有一个对应的compiler将该子图编译成后端引擎对应的executable。Compiler通常都非常注重编译产物的执行性能，而性能以外的关切点也导致了不同的技术路线，比如对算法通用性、跨平台有高度关切的TVM和XLA采用了LLVM传统编译器的路线，而对于过分看重性能但硬件平台单一的TensorRT更多的则是采用手工优化和tuning相结合的策略。不过这两种技术路线并不是完全对立的，也是在不断地相互借鉴和融合。</p>\n<p>在XRT中，所有这些技术方案都是可以被兼容的，你可以根据实际情况自由切换，你也可以把XRT当成实验场所，实现一个自定义的compiler，并在同一套框架下对比不同compiler、不同技术方案的优劣。</p>\n<p>回到本文的主题，我们现在需要实现一个TestExecutable对应的compiler，我们也把该compiler叫做TestGraphCompiler。</p>\n<p>首先在xrt/test目录下新建两个文件test_graph_compiler.h和test_graph_compiler.cpp。在test_graph_compiler.h文件中定义类TestGraphCompiler，TestGraphCompiler必须继承自类GraphCompiler::Impl，并实现对应的Compile接口。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestGraphCompiler</span> : <span class=\"keyword\">public</span> GraphCompiler::Impl &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">TestGraphCompiler</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;name)</span></span></span><br><span class=\"line\"><span class=\"function\">      : GraphCompiler::Impl(name) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">TestGraphCompiler</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">std::shared_ptr&lt;Executable&gt; <span class=\"title\">Compile</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"type\">const</span> XrtGraph *graph,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;entry_params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;return_params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"type\">const</span> std::vector&lt;InputOutputAlias&gt; &amp;aliases)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在test_graph_compiler.cpp中实现Compile接口，并注册一个新的graph\ncompiler。在动手实现该接口之前，有必要先解释一下该接口的参数列表，graph表示的是function子图，entry_params表示子图的输入，return_params表示子图的输出，aliases通常在包含模型更新操作时会用到，表明输出和输入是一对别名关系。被alias的输入将生命期延长到了整个子图，并且与对应的输出共享内存，实际上也就间接实现了in-place计算的目的。</p>\n<p>我们按拓扑顺序遍历子图中的每个节点（或op），依次将节点编译成具体的执行代码，并在合适的位置插入临时buffer。为了方便处理不同类型的op，我们在下面的代码中引入了TestOpContext和TestOpKernel的概念。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Register a new graph compiler for TEST engine.</span></span><br><span class=\"line\"><span class=\"built_in\">REGISTER_GRAPH_COMPILER</span>(XrtEngine::TEST, TestGraphCompiler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Realize Compile interface.</span></span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;Executable&gt; <span class=\"title\">TestGraphCompiler::Compile</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> XrtGraph *graph,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;entry_params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;return_params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> std::vector&lt;InputOutputAlias&gt; &amp;aliases)</span> </span>&#123;</span><br><span class=\"line\">  std::vector&lt;Parameter&gt; temp_buffers;</span><br><span class=\"line\">  std::vector&lt;FuncCode&gt; func_codes;</span><br><span class=\"line\">  std::vector&lt;FuncArgumentIndices&gt; func_args;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::unordered_map&lt;std::string, <span class=\"type\">int</span>&gt; indices;</span><br><span class=\"line\">  std::unordered_map&lt;std::string, Parameter&gt; all_params;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> param : entry_params) &#123;</span><br><span class=\"line\">    indices.<span class=\"built_in\">emplace</span>(param.<span class=\"built_in\">name</span>(), indices.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    all_params[param.<span class=\"built_in\">name</span>()] = param;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> param : return_params) &#123;</span><br><span class=\"line\">    indices.<span class=\"built_in\">emplace</span>(param.<span class=\"built_in\">name</span>(), indices.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    all_params[param.<span class=\"built_in\">name</span>()] = param;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  algorithm::<span class=\"built_in\">TopologyVisit</span>(*graph, [&amp;](<span class=\"type\">const</span> XrtNode *node) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;<span class=\"built_in\">type</span>() == <span class=\"string\">&quot;Argument&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Argument node is not computation node, so skip it.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    TestOpContext <span class=\"built_in\">op_context</span>(node, all_params);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> op_kernel = <span class=\"built_in\">BuildTestOpKernel</span>(node-&gt;<span class=\"built_in\">type</span>());</span><br><span class=\"line\">    op_kernel-&gt;<span class=\"built_in\">Compile</span>(&amp;op_context);</span><br><span class=\"line\"></span><br><span class=\"line\">    func_codes.<span class=\"built_in\">push_back</span>(op_context.func_code_);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;buffers = op_context.tmp_buffers_;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = buffers.<span class=\"built_in\">begin</span>(); it != buffers.<span class=\"built_in\">end</span>(); ++it) &#123;</span><br><span class=\"line\">      all_params[it-&gt;first] = it-&gt;second;</span><br><span class=\"line\">      temp_buffers.<span class=\"built_in\">push_back</span>(it-&gt;second);</span><br><span class=\"line\">      indices.<span class=\"built_in\">emplace</span>(it-&gt;first, indices.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Finalize argument indices for each function.</span></span><br><span class=\"line\">    FuncArgumentIndices arg_indices;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;arg : op_context.input_args_) &#123;</span><br><span class=\"line\">      arg_indices.inputs.<span class=\"built_in\">push_back</span>(indices.<span class=\"built_in\">at</span>(arg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;arg : op_context.output_args_) &#123;</span><br><span class=\"line\">      arg_indices.outputs.<span class=\"built_in\">push_back</span>(indices.<span class=\"built_in\">at</span>(arg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    func_args.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(arg_indices));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_shared</span>&lt;TestExecutable&gt;(<span class=\"keyword\">this</span>-&gt;name_, entry_params.<span class=\"built_in\">size</span>(),</span><br><span class=\"line\">                                          return_params, temp_buffers,</span><br><span class=\"line\">                                          func_codes, func_args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TestOpContext临时存储编译需要的元信息和编译结果，为TestOpKernel提供必要的接口，TestOpKernel则根据op类型完成单个op的编译过程。上述代码中我们实现了一个将XRT子图编译成TestExecutable的最简单的graph\ncompiler，下面我们将以ReLU\nop为例，介绍TestOpContext和TestOpKernel是如何对op进行编译的。</p>\n<h2 id=\"test-kernels\">Test Kernels</h2>\n<p>我们回过头再仔细研究一下TestGraphCompiler的Compile实现，TestOpContext接受两个输入，node和当前所有已经创建过的parameters，经过OpKernel编译后输出函数代码（func_code_）、中间buffer（tmp_buffers_），以及函数代码输入和输出对应的parameter\nnames。因此在这个例子中，TestOpContext被设计成如下形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestOpContext</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">TestOpContext</span>(<span class=\"type\">const</span> XrtNode *node,</span><br><span class=\"line\">                <span class=\"type\">const</span> std::unordered_map&lt;std::string, Parameter&gt; &amp;all_params)</span><br><span class=\"line\">      : <span class=\"built_in\">node_</span>(node), <span class=\"built_in\">all_params_</span>(all_params) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"type\">const</span> XrtNode *node_;</span><br><span class=\"line\">  <span class=\"type\">const</span> std::unordered_map&lt;std::string, Parameter&gt; &amp;all_params_;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::function&lt;<span class=\"type\">void</span>(<span class=\"type\">const</span> std::vector&lt;Parameter&gt;&amp;,</span><br><span class=\"line\">                     <span class=\"type\">const</span> std::vector&lt;Parameter&gt;&amp;)&gt; func_code_;</span><br><span class=\"line\">  std::vector&lt;std::string&gt; input_args_;</span><br><span class=\"line\">  std::vector&lt;std::string&gt; output_args_;</span><br><span class=\"line\">  std::unordered_map&lt;std::string, Parameter&gt; tmp_buffers_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对于TestOpKernel，为了处理不同类型的op，我们采用工厂注册模式，并且这种模式还有另一个用处，就是在XRT划分子图时可以用来判断该引擎是否支持某个类型的op。XRT已经将kernel注册接口封装成了一个辅助类OpKernelRegistrar，但同时也要求TestOpKernel必须继承基类OpKernel。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestOpKernel</span> : <span class=\"keyword\">public</span> OpKernel&lt;TestOpContext&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Compile</span><span class=\"params\">(TestOpContext *ctx)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用OpKernelRegistrar定义一个用来注册TestOpKernel的宏。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REGISTER_TEST_OP_KERNEL(OpName, KernelType)                 \\</span></span><br><span class=\"line\"><span class=\"meta\">  static auto _test_op_kernel_##OpName##_ __attribute__((unused)) = \\</span></span><br><span class=\"line\"><span class=\"meta\">      OpKernelRegistrar<span class=\"string\">&lt;TestOpContext&gt;</span>(#OpName)                     \\</span></span><br><span class=\"line\"><span class=\"meta\">          .SetField(XrtEngine::TEST)                                \\</span></span><br><span class=\"line\"><span class=\"meta\">          .SetDevice(&#123;XrtDevice::GPU_CUDA&#125;)                         \\</span></span><br><span class=\"line\"><span class=\"meta\">          .SetFactory([]() -&gt; OpKernel<span class=\"string\">&lt;TestOpContext&gt;</span> * &#123;           \\</span></span><br><span class=\"line\"><span class=\"meta\">                        return new KernelType;                      \\</span></span><br><span class=\"line\"><span class=\"meta\">                      &#125;)</span></span><br></pre></td></tr></table></figure>\n<p>最后我们实现一个Relu的OpKernel，填充TestOpContext的func_code_、tmp_buffers_以及输入输出arguments。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ComputeRelu</span><span class=\"params\">(<span class=\"type\">const</span> Parameter &amp;input, <span class=\"type\">const</span> Parameter &amp;output)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//TODO(hjchen2)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestReluOpKernel</span> : <span class=\"keyword\">public</span> TestOpKernel &#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Compile</span><span class=\"params\">(TestOpContext *ctx)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">    ctx-&gt;func_code_ = [](<span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;inputs,</span><br><span class=\"line\">                         <span class=\"type\">const</span> std::vector&lt;Parameter&gt; &amp;outputs) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">CHECK_EQ</span>(inputs.<span class=\"built_in\">size</span>(), <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"built_in\">CHECK_EQ</span>(outputs.<span class=\"built_in\">size</span>(), <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"built_in\">ComputeRelu</span>(inputs[<span class=\"number\">0</span>], outputs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> XrtEdge *edge : ctx-&gt;node_-&gt;<span class=\"built_in\">in_edges</span>()) &#123;</span><br><span class=\"line\">      <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;name = edge-&gt;<span class=\"built_in\">argument</span>().<span class=\"built_in\">name</span>();</span><br><span class=\"line\">      <span class=\"built_in\">CHECK_GT</span>(ctx-&gt;all_params_.<span class=\"built_in\">count</span>(name), <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"comment\">// TODO(hjchen2): Filter duplicate input.</span></span><br><span class=\"line\">      ctx-&gt;input_args_.<span class=\"built_in\">push_back</span>(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> XrtEdge *edge : ctx-&gt;node_-&gt;<span class=\"built_in\">out_edges</span>()) &#123;</span><br><span class=\"line\">      <span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;name = edge-&gt;<span class=\"built_in\">argument</span>().<span class=\"built_in\">name</span>();</span><br><span class=\"line\">      <span class=\"comment\">// TODO(hjchen2): Filter duplicate output.</span></span><br><span class=\"line\">      ctx-&gt;output_args_.<span class=\"built_in\">push_back</span>(name);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ctx-&gt;all_params_.<span class=\"built_in\">count</span>(name) == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">          ctx-&gt;tmp_buffers_.<span class=\"built_in\">count</span>(name) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> param = <span class=\"built_in\">CreateParameter</span>(name <span class=\"comment\">/*argument name*/</span>,</span><br><span class=\"line\">                                     edge-&gt;<span class=\"built_in\">argument</span>().<span class=\"built_in\">shape</span>(),</span><br><span class=\"line\">                                     edge-&gt;<span class=\"built_in\">argument</span>().<span class=\"built_in\">data_type</span>());</span><br><span class=\"line\">        ctx-&gt;tmp_buffers_[name] = std::<span class=\"built_in\">move</span>(param);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最后将TestReluOpKernel注册到Test引擎对应的OpKernel工厂下。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">REGISTER_TEST_OP_KERNEL</span>(Relu, TestReluOpKernel)</span><br><span class=\"line\">    .<span class=\"built_in\">EnableTrainPhase</span>()</span><br><span class=\"line\">    .<span class=\"built_in\">Finalize</span>();</span><br></pre></td></tr></table></figure>\n<p>EnableTrainPhase表示该op支持训练，OpKernelRegistrar也提供了其他一些接口，比如设置支持的device列表，mutable\nvariables和是否是optimizer op（optimizer会影响子图划分）。</p>\n<h2 id=\"python和c-apis\">Python和C++ APIs</h2>\n<p>引擎的开启或关闭可以通过Python接口和环境变量来设置，因此添加一个后端引擎时也需要在Python中添加相应的接口，在python/framework/function_util.py文件中增加如下代码，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@oneflow_function_config(<span class=\"params\"><span class=\"string\">&#x27;use_test&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">set_use_test</span>(<span class=\"params\">func_desc, value = <span class=\"literal\">True</span></span>):</span><br><span class=\"line\">    func_desc.job_config_proto.xrt_config.use_test = value</span><br></pre></td></tr></table></figure>\n<p>并且在xrt/api.cpp中增加一个gflags环境变量，并在该文件中修改相关接口。</p>\n<ul>\n<li><p>增加一个gflags环境变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">DEFINE_bool</span>(use_test, <span class=\"built_in\">EnvToBool</span>(FLAGS_use_test, <span class=\"literal\">false</span>), <span class=\"string\">&quot;It&#x27;s optional to use test.&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p>修改InitXrtConfigurations、XrtCompilationEnabled和CreateDefaultXrtPassOptions接口，增加对Test引擎的支持。</p></li>\n</ul>\n<h2 id=\"完整代码\">完整代码</h2>\n<p>https://github.com/Oneflow-Inc/oneflow/commit/50a74bc110f3aacfa853456d9b695f2ba80e9e0a</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"clcgavftf0001hbeq4w698lua","category_id":"clcgavftk0004hbeqesxbg8qv","_id":"clcgavftr000fhbeq99hcd674"},{"post_id":"clcgavfti0003hbeq3jgohwl0","category_id":"clcgavftp000bhbeqhj4feo2v","_id":"clcgavftt000khbeq94487qq8"},{"post_id":"clcgavftm0007hbeqcugw52tj","category_id":"clcgavftr000ghbeq4v6t94oj","_id":"clcgavftx000shbeqa3mhg8rj"},{"post_id":"clcgavfto0009hbeq1dpe2x8p","category_id":"clcgavftp000bhbeqhj4feo2v","_id":"clcgavfty000vhbeqbgc3070i"},{"post_id":"clcgavfto000ahbeq6hqteqcv","category_id":"clcgavftx000rhbeqb11dc7rw","_id":"clcgavfty000zhbeq66lm6mjc"},{"post_id":"clcgavftq000dhbeqdnb8d1ka","category_id":"clcgavfty000whbeq4rio6iuo","_id":"clcgavftz0014hbeq5lap2a6x"},{"post_id":"clcgavftr000ehbeq2z92hvfe","category_id":"clcgavftz0011hbeqd5lw01r4","_id":"clcgavfu00018hbeq6emia2u7"},{"post_id":"clcgavfts000ihbeqbnbrgs8j","category_id":"clcgavfty000whbeq4rio6iuo","_id":"clcgavfu1001bhbeq1ccua91w"},{"post_id":"clcgavftt000jhbeqfm8r5aqq","category_id":"clcgavfu00017hbeq9nrn4zl9","_id":"clcgavfu1001ghbeqhgkg7k7b"},{"post_id":"clcgavftv000nhbeqeoh4hj46","category_id":"clcgavfu1001dhbeq75qs20f4","_id":"clcgavfu2001jhbeqa0tsa26g"},{"post_id":"clcgavftw000phbeq2ygb1akb","category_id":"clcgavfty000whbeq4rio6iuo","_id":"clcgavfu2001mhbeq3uwmex0s"},{"post_id":"clcgb13ud0000j6eqcpb90er7","category_id":"clcgb13uj0002j6eq2scfhv71","_id":"clcgb13ut0009j6eq7g7g1th4"},{"post_id":"clcgb13uh0001j6eqcl1d209z","category_id":"clcgb13up0007j6eq8u9d2429","_id":"clcgb13uu000cj6eqg3x2g1bs"},{"post_id":"clcgb13um0004j6eq25msh21k","category_id":"clcgb13ut000aj6eqg29b4trk","_id":"clcgb13uv000hj6eqfxxj5a6g"},{"post_id":"clcgb13un0005j6eq25mp4v55","category_id":"clcgb13uu000dj6eqfvidf5y2","_id":"clcgb13uv000lj6eqhi1e0q8d"},{"post_id":"clcgb13uo0006j6eqfpxxew8z","category_id":"clcgb13uv000ij6eq69ca8xtn","_id":"clcgb13uw000nj6eqc5gu51de"}],"PostTag":[{"post_id":"clcgavftf0001hbeq4w698lua","tag_id":"clcgavftl0005hbeq36zfeo5i","_id":"clcgavftw000ohbeq6urg69xh"},{"post_id":"clcgavftf0001hbeq4w698lua","tag_id":"clcgavftp000chbeqew9o7qz5","_id":"clcgavftx000qhbeqazc8a0ix"},{"post_id":"clcgavftf0001hbeq4w698lua","tag_id":"clcgavftr000hhbeqaul1bms8","_id":"clcgavfty000uhbeq55itfh43"},{"post_id":"clcgavfti0003hbeq3jgohwl0","tag_id":"clcgavftu000mhbeq3ggs4j47","_id":"clcgavfty000yhbeq8ym6djpi"},{"post_id":"clcgavfti0003hbeq3jgohwl0","tag_id":"clcgavftx000thbeq82b3csbs","_id":"clcgavftz0010hbeqbqqwbgt1"},{"post_id":"clcgavftm0007hbeqcugw52tj","tag_id":"clcgavfty000xhbeq12dh7d9f","_id":"clcgavftz0013hbeq6c07btg0"},{"post_id":"clcgavfto0009hbeq1dpe2x8p","tag_id":"clcgavftl0005hbeq36zfeo5i","_id":"clcgavfu1001ahbeqbhbvb45e"},{"post_id":"clcgavfto0009hbeq1dpe2x8p","tag_id":"clcgavftp000chbeqew9o7qz5","_id":"clcgavfu1001chbeq1j592c8g"},{"post_id":"clcgavfto0009hbeq1dpe2x8p","tag_id":"clcgavftz0016hbeqdtfkdgb1","_id":"clcgavfu1001fhbeq2v3q6266"},{"post_id":"clcgavfto000ahbeq6hqteqcv","tag_id":"clcgavfu00019hbeqeofi1ll6","_id":"clcgavfu2001lhbeq3c2d2i22"},{"post_id":"clcgavfto000ahbeq6hqteqcv","tag_id":"clcgavfu1001ehbeq29tg99lq","_id":"clcgavfu2001nhbeqdngehdez"},{"post_id":"clcgavfto000ahbeq6hqteqcv","tag_id":"clcgavfu2001ihbeq61nf33e2","_id":"clcgavfu3001phbeqctmuagkp"},{"post_id":"clcgavftq000dhbeqdnb8d1ka","tag_id":"clcgavfu2001khbeqepuxaev3","_id":"clcgavfu3001rhbeqhdxqdu7g"},{"post_id":"clcgavftq000dhbeqdnb8d1ka","tag_id":"clcgavfu3001ohbeqbmj8hwxz","_id":"clcgavfu3001shbeq7lauf5v2"},{"post_id":"clcgavftr000ehbeq2z92hvfe","tag_id":"clcgavfu3001qhbeq3xvf4ih3","_id":"clcgavfu4001xhbeqg69q2e2y"},{"post_id":"clcgavftr000ehbeq2z92hvfe","tag_id":"clcgavfu3001thbeq5diw2wp2","_id":"clcgavfu4001yhbeq0h640vhe"},{"post_id":"clcgavftr000ehbeq2z92hvfe","tag_id":"clcgavfu3001uhbeq3yxkcgv6","_id":"clcgavfu40020hbeqbjw94ezs"},{"post_id":"clcgavftr000ehbeq2z92hvfe","tag_id":"clcgavfu4001vhbeq8sbg711i","_id":"clcgavfu40021hbeq1sio8mt5"},{"post_id":"clcgavfts000ihbeqbnbrgs8j","tag_id":"clcgavfu2001khbeqepuxaev3","_id":"clcgavfu50023hbeq48lm3ere"},{"post_id":"clcgavfts000ihbeqbnbrgs8j","tag_id":"clcgavfu4001zhbeqd9tn0n50","_id":"clcgavfu50024hbeq92yff06u"},{"post_id":"clcgavftt000jhbeqfm8r5aqq","tag_id":"clcgavfu40022hbeqg9veb0tj","_id":"clcgavfu70026hbeqbndbfn5q"},{"post_id":"clcgavftv000nhbeqeoh4hj46","tag_id":"clcgavfu70025hbeqa5b41dh3","_id":"clcgavfu9002chbeq8i81b20z"},{"post_id":"clcgavftv000nhbeqeoh4hj46","tag_id":"clcgavfu70027hbeq7r6u6td4","_id":"clcgavfu9002dhbeqbvhg659a"},{"post_id":"clcgavftv000nhbeqeoh4hj46","tag_id":"clcgavfu80028hbeqfqbv7jsm","_id":"clcgavfua002fhbeqfc08bwx7"},{"post_id":"clcgavftv000nhbeqeoh4hj46","tag_id":"clcgavfu80029hbeqeru5fuaj","_id":"clcgavfua002ghbeq95030249"},{"post_id":"clcgavftv000nhbeqeoh4hj46","tag_id":"clcgavfu8002ahbeqglp3bb7d","_id":"clcgavfua002hhbeqa9gw78ww"},{"post_id":"clcgavftw000phbeq2ygb1akb","tag_id":"clcgavfu2001khbeqepuxaev3","_id":"clcgavfua002ihbeqh7kw6sda"},{"post_id":"clcgavftw000phbeq2ygb1akb","tag_id":"clcgavfu4001zhbeqd9tn0n50","_id":"clcgavfua002jhbeq6yiy84vq"},{"post_id":"clcgb13ud0000j6eqcpb90er7","tag_id":"clcgb13um0003j6eqfcr04p8l","_id":"clcgb13uv000fj6eq9pg47354"},{"post_id":"clcgb13ud0000j6eqcpb90er7","tag_id":"clcgb13up0008j6eq0n0xb9en","_id":"clcgb13uv000gj6eq6kjo2wyl"},{"post_id":"clcgb13ud0000j6eqcpb90er7","tag_id":"clcgb13ut000bj6eqeiovapl1","_id":"clcgb13uv000kj6eqczqcbdem"},{"post_id":"clcgb13uh0001j6eqcl1d209z","tag_id":"clcgb13uu000ej6eq21468gaf","_id":"clcgb13ux000rj6eq1fea2tc2"},{"post_id":"clcgb13uh0001j6eqcl1d209z","tag_id":"clcgb13uv000jj6eq97uf7ipw","_id":"clcgb13ux000sj6eq92l5di3f"},{"post_id":"clcgb13uh0001j6eqcl1d209z","tag_id":"clcgb13uv000mj6eqe8gydmmz","_id":"clcgb13ux000uj6eq7gx82krz"},{"post_id":"clcgb13uh0001j6eqcl1d209z","tag_id":"clcgb13uw000oj6eq5hw46tlf","_id":"clcgb13ux000vj6eq70t67l0v"},{"post_id":"clcgb13uh0001j6eqcl1d209z","tag_id":"clcgb13uw000pj6eqenk01xi0","_id":"clcgb13ux000xj6eq3rjx65ll"},{"post_id":"clcgb13um0004j6eq25msh21k","tag_id":"clcgb13uw000qj6eqg22d7nn9","_id":"clcgb13uy000yj6eq7a3b852v"},{"post_id":"clcgb13um0004j6eq25msh21k","tag_id":"clcgb13ux000tj6eqdn6x9ns7","_id":"clcgb13uy0010j6eqhawc4dow"},{"post_id":"clcgb13un0005j6eq25mp4v55","tag_id":"clcgb13ux000wj6eq3qym1rbu","_id":"clcgb13v00015j6eq82566o3h"},{"post_id":"clcgb13un0005j6eq25mp4v55","tag_id":"clcgb13uy000zj6eq9nyq23pf","_id":"clcgb13v00016j6eq7rplcwdj"},{"post_id":"clcgb13un0005j6eq25mp4v55","tag_id":"clcgb13uy0011j6eqftri775c","_id":"clcgb13v00018j6eq6105fidu"},{"post_id":"clcgb13un0005j6eq25mp4v55","tag_id":"clcgb13uy0012j6eqhoe3hgxx","_id":"clcgb13v00019j6eqfknsbwks"},{"post_id":"clcgb13un0005j6eq25mp4v55","tag_id":"clcgb13uz0013j6eqb7lgezpf","_id":"clcgb13v0001bj6eqd33793co"},{"post_id":"clcgb13uo0006j6eqfpxxew8z","tag_id":"clcgb13uz0014j6eqbfazdyk0","_id":"clcgb13v2001dj6eq8p1p98wo"},{"post_id":"clcgb13uo0006j6eqfpxxew8z","tag_id":"clcgb13v00017j6eq8wacb8xi","_id":"clcgb13v2001ej6eqdsl0gpar"},{"post_id":"clcgb13uo0006j6eqfpxxew8z","tag_id":"clcgb13v0001aj6eq1jt6hgil","_id":"clcgb13v2001fj6eq8de89ojb"},{"post_id":"clcgb13uo0006j6eqfpxxew8z","tag_id":"clcgb13v0001cj6eqeloi0ns3","_id":"clcgb13v2001gj6eq41bt2g3k"}],"Tag":[{"name":"caffe","_id":"clcgavftl0005hbeq36zfeo5i"},{"name":"deep learning","_id":"clcgavftp000chbeqew9o7qz5"},{"name":"momentum","_id":"clcgavftr000hhbeqaul1bms8"},{"name":"large scale ML framework","_id":"clcgavftu000mhbeq3ggs4j47"},{"name":"KunPeng","_id":"clcgavftx000thbeq82b3csbs"},{"name":"web technology","_id":"clcgavfty000xhbeq12dh7d9f"},{"name":"framework","_id":"clcgavftz0016hbeqdtfkdgb1"},{"name":"c++","_id":"clcgavfu00019hbeqeofi1ll6"},{"name":"python","_id":"clcgavfu1001ehbeq29tg99lq"},{"name":"embedding","_id":"clcgavfu2001ihbeq61nf33e2"},{"name":"reinforcement learning","_id":"clcgavfu2001khbeqepuxaev3"},{"name":"machine learning，贝尔曼公式推导","_id":"clcgavfu3001ohbeqbmj8hwxz"},{"name":"seq2seq","_id":"clcgavfu3001qhbeq3xvf4ih3"},{"name":"machine translation","_id":"clcgavfu3001thbeq5diw2wp2"},{"name":"Encoder-Decoder","_id":"clcgavfu3001uhbeq3yxkcgv6"},{"name":"Attention","_id":"clcgavfu4001vhbeq8sbg711i"},{"name":"machine learning","_id":"clcgavfu4001zhbeqd9tn0n50"},{"name":"pruning","_id":"clcgavfu40022hbeqg9veb0tj"},{"name":"int16","_id":"clcgavfu70025hbeqa5b41dh3"},{"name":"fp16","_id":"clcgavfu70027hbeq7r6u6td4"},{"name":"混合精度训练","_id":"clcgavfu80028hbeqfqbv7jsm"},{"name":"loss scaling","_id":"clcgavfu80029hbeqeru5fuaj"},{"name":"QVNNI16","_id":"clcgavfu8002ahbeqglp3bb7d"},{"name":"XLA","_id":"clcgb13um0003j6eqfcr04p8l"},{"name":"Deep Learning Compiler","_id":"clcgb13up0008j6eq0n0xb9en"},{"name":"FusionStitching","_id":"clcgb13ut000bj6eqeiovapl1"},{"name":"kaldi","_id":"clcgb13uu000ej6eq21468gaf"},{"name":"decision tree","_id":"clcgb13uv000jj6eq97uf7ipw"},{"name":"决策树","_id":"clcgb13uv000mj6eqe8gydmmz"},{"name":"HMM","_id":"clcgb13uw000oj6eq5hw46tlf"},{"name":"上下文相关音素","_id":"clcgb13uw000pj6eqenk01xi0"},{"name":"TVM","_id":"clcgb13uw000qj6eqg22d7nn9"},{"name":"PackedFunc","_id":"clcgb13ux000tj6eqdn6x9ns7"},{"name":"图替换","_id":"clcgb13ux000wj6eq3qym1rbu"},{"name":"超优化","_id":"clcgb13uy000zj6eq9nyq23pf"},{"name":"graph optimization","_id":"clcgb13uy0011j6eqftri775c"},{"name":"super optimization","_id":"clcgb13uy0012j6eqhoe3hgxx"},{"name":"substitution","_id":"clcgb13uz0013j6eqb7lgezpf"},{"name":"XRT","_id":"clcgb13uz0014j6eqbfazdyk0"},{"name":"Compiler","_id":"clcgb13v00017j6eq8wacb8xi"},{"name":"TensorFlow XLA","_id":"clcgb13v0001aj6eq1jt6hgil"},{"name":"TensorRT","_id":"clcgb13v0001cj6eqeloi0ns3"}]}}